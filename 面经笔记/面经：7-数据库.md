# 面经：7-MySQL

> 个人整理 :muscle: 个人专用 :muscle: 暑期实习 :muscle: 秋招 :muscle: 后端开发 :muscle: 八股文 :no_mouth:

### MySQL 的架构 :exclamation:

先看下 MySQL 的基本架构图：

![mysql基本架构图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251811812.jpg)

大体来说，MySQL 可以分为 **Server层** 和 **存储引擎** 两部分。

**Server 层：涵盖了 MySQL 的大多数核心服务功能**；

1. 包括了：连接器、查询缓存、分析器、优化器、执行器等；
2. 所有的内置函数（如：日期、时间、数学和加密函数等）；
3. 所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。

**存储引擎层：负责数据的存储和提取**。

1. 其架构是插件式的，支持 InnoDB、MyISAM 等多个存储引擎。
2. 不同存储引擎的表数据存取方式不同，支持的功能也不同。

> 从 MySQL5.5.5 版本开始默认的是 InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。

从上图中可以看出，**不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。**

> 进一步见：[MySQL：提高笔记-2：1. MySQL体系结构概览、2. 存储引擎](https://www.cnblogs.com/zhuchengchao/p/14456026.html)

### SQL 语句在数据库框架中的执行流程 :exclamation:

1. 应用程序把查询 SQL 语句发送给服务器端执行；
2. 查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；
3. 查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；
4. MySQL 根据相应的执行计划完成整个查询；
5. 将查询结果返回给客户端。

> 详细过程：https://blog.csdn.net/pcwl1206/article/details/86137408

### 数据库的三范式 :exclamation::exclamation:

- 第一范式：强调的是列的**原子性**，即数据库表的每一列都是不可分割的原子数据项；

- 第二范式：要求实体的属性**完全依赖**于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；

  > 简而言之， 第二范式就是在第一范式的基础上**所有列完全依赖于主键列**。当存在一个复合主键包含多个主键列的时候，才会发生不符合第二范式的情况。  
  >
  > 第二范式的特点：
  >
  > 1. 一张表只描述一件事情。
  > 2. 表中的每一列都完全依赖于主键  

- 第三范式：任何非主属性不依赖于其它非主属性，即任何非主属性**不能传递依赖**于主属性。

  > 所谓传递依赖， 指的是如果存在"A → B → C"的决定关系， 则 C 传递依赖于 A。因此， 满足第三范式的数据库表应该不存在如下依赖关系：主键列 → 非主键列 x → 非主键列  y

> 详见：[MySQL：基础语法-3：数据库设计](https://www.cnblogs.com/zhuchengchao/p/14453811.html)

### MySQL 中的数据类型

 MySQL 中的数据类型主要有数值类型、时间/日期类型、字符串类型，如下图所示：

![mysql数据类型](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251811526.jpg)

### char & varchar 的区别 :exclamation:

**char(n) ：**固定长度类型，比如：定义 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。

- char 优点：效率高；
- 缺点：占用空间；
- 适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

**varchar(n) ：**可变长度字符串类型，每个varchar值都只占用刚好够用的字节再加上一个用来记录其长度的字节，即总长度为 L+1 字节

> 需要注意的是varchar中如果存放的字符串长度不超过255，varchar 会额外申请一个字节用于存放实际字符串的长度，如果超过255，会额外申请两个字节的空间用于存放实际字符串的长度

所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

**进一步：varchar(10) 和 varchar(20) 的区别**

varchar(10) 中 10 的含义最多存放 10 个字符，而 varchar(20) 当然最多能存放 20 个字符；

varchar(10) 和 varchar(20) 存储  hello 所占空间一样，**但后者在排序时会消耗更多内存**，因为 order by col 采用 fixed_length 计算 col 长度。

### 对索引的优缺点及建立原则 :exclamation::exclamation::exclamation:

**索引概述：**

* **索引的出现是为了提高数据的查询效率**。

  > 就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

* 但是索引也会带来很多负面影响：**创建索引和维护索引需要耗费时间**，这个时间随着数据量的增加而增加；**索引需要占用物理空间**，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候**索引也要动态维护**，这样就降低了数据的维护速度。

**建立索引的原则：**

1. 在最频繁使用的、用以缩小查询范围的字段上建立索引；
2. 在频繁使用的、需要排序的字段上建立索引。

**不适合建立索引的情况：**

1. 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；
2. 对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。

**索引分类：**后面有更详细的

1. 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引

2. 唯一索引 ：索引列的值必须唯一，但允许有空值

   > 在 mysql 的 innodb 引擎中，是允许在唯一索引的字段中出现多个 null 值的

3. 复合索引 ：即一个索引包含多个列

> 详见：[MySQL：提高笔记-1](https://www.cnblogs.com/zhuchengchao/p/14454598.html)

### 索引实现：B+树 :exclamation:

**索引的底层使用的数据结构**：

1. 索引的数据结构和具体的存储引擎实现有关，在 MySQL 中使用较多的索引有 Hash 索引、B+树索引等。
2. 而经常使用的 **InnoDB 存储引擎的默认索引实现为 B+ 树索引**。

**对 B+ 树的理解：**

![B+树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251811452.JPG)

**B+Tree 为 BTree 的变种**，B+Tree与BTree的区别为：

1. n叉B+Tree最多含有n个key，而BTree则最多含有n-1个key；
2. **B+树的非叶结点仅具有索引作用**，也就是说，非叶子结点只存储key，不存储value；
3. B+Tree的叶子节点保存所有的key，value 信息，依key大小顺序排列；
4. **B+树的所有叶结点构成一个有序链表**，可以按照key排序的次序遍历全部数据。 

由于B+Tree只有叶子节点保存value信息，查询任何value都要从root走到叶子节点。所以B+Tree的**查询效率更加稳定**。

**同时MySQL对经典的B+Tree进行了优化。**在原B+Tree的基础上，**增加一个指向相邻叶子节点的链表指针**，就形成了带有顺序指针的B+Tree，**提高区间访问的性能**。

MySQL中的 B+Tree 索引结构示意图: 

![优化的B+树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251811497.png)

**InnoDB 存储引擎选用 B+ 树而不是 B 树原因/B+ 树的优点在于：**

- 用B+树不用B树**考虑的是 IO 对性能的影响**；
- 由于B树的每个节点都存储数据，而B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此**在内存相同的情况下，能够存放更多的key**；这样**查找相同数据量的情况下，B 树IO更频繁**。
- B+树的叶子结点都是相连的，因此**对整棵树的遍历只需要依次线性遍历叶子结点即可**。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

> 详见：[MySQL：提高笔记-1](https://www.cnblogs.com/zhuchengchao/p/14454598.html)

### 对聚簇索引的理解 :exclamation::exclamation:

聚簇索引：对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。**特点是存储数据的顺序和索引顺序一致。**

> 拿查字典做一个比喻：
>
> * 字典的页面就好比是物理排列顺序，物理排列顺序是固定的，查询的方式就好比是索引；
> * **区别是聚簇索引就好比是拼音查询**，每一个字母查询出来的页面顺序是跟你字母的顺序一致的，a字母查询出来的页面一定是在c字母查询出来的页面前面；
> * **而非聚簇索引就好比是笔画查询**，笔画少的查出来的页面不一定在笔画多的查出来的页面前面，也就是你通过笔画查询的顺序和页面的顺序并不是一致的

一般情况下主键会默认创建聚簇索引，**且一张表只允许存在一个聚簇索引**

> 这是因为聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。
>
> 正因为一个表最多只能有一个聚簇索引，所以它显得更为珍贵，一个表设置什么为聚簇索引对性能很关键

**聚簇索引和非聚簇索引的区别：**

1. 聚簇索引的顺序就是数据的物理存储顺序；非聚簇索引的索引顺序与数据物理排列顺序无关
2. 聚簇索引的**叶子节点就是数据节点**；而非聚簇索引的**叶子节点仍然是索引节点**，是指向对应数据块的指针。

### 对覆盖索引的认识

如果**一个索引包含了满足查询语句中字段与条件的数据**就叫做覆盖索引，也就是平时说的**不需要回表操作**。

**判断标准**

使用 explain，可以通过输出的 extra 列来判断，对于一个索引覆盖查询，显示为 **using index**，MySQL 查询优化器在执行查询前会决定是否有索引覆盖查询

**具有以下优点：**

1. 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
2. 一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
3. 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

> 详见：[MySQL：提高笔记-3](https://www.cnblogs.com/zhuchengchao/p/14457419.html)

### 索引的分类 :exclamation:

**从数据结构角度**

> 索引是在 MySQL 的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL 目前提供了以下 4 种索引。
>
> 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。其中聚簇索引、复合索引、前缀索引、唯一索引默认都是使用 B+树索引，统称为索引。

1. 树索引  O(logn)： 最常见的索引类型，大部分索引都支持 B 树索引。

2. Hash 索引 O(1)：只有 Memory 引擎支持 ， 使用场景简单

   > 哈希索引能**以 O(1) 时间进行查找，但是失去了有序性。**无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找。
   >
   > InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。

3. R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，**不做特别介绍**。

4. Full-Text（全文索引） ：全文索引也是 MyISAM 的一个特殊索引类型，主要用于全文索引，InnoDB 从Mysql5.6 版本开始支持全文索引。

**从物理存储角度**：

1. 聚簇索引（clustered index）
2. 非聚簇索引（non-clustered index）

> 上面有相应的讲解

**从逻辑角度**

1. 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。

2. 唯一索引：索引列中的值必须是唯一的，**但是允许为空值**。

3. 主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）

4. 联合索引/复合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，即使用组合索引时遵循**最左前缀集合**。

5. 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在`CHAR,VARCHAR,TEXT`类型字段上使用全文索引。但一般开发中，不会用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。

   > 全文索引：就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个大煞笔，二货 ..." 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思。

> **主键与唯一索引的区别**：
>
>   1. 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
>
>   2. 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键，即主键索引在创建时，已经默认为非空值+ 唯一索引了。
>
>   3. **唯一性索引列允许空值，而主键列不允许为空值**。
>
>   5. 一个表最多只能创建一个主键索引，但可以创建多个唯一索引。
>
>   6. 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。
>
>   7. 主键可以被其他表引用为外键，而唯一索引不能。

> 详见：[MySQL：提高笔记-1](https://www.cnblogs.com/zhuchengchao/p/14454598.html)

### 最左前缀原则 :exclamation:

MySQL 使用**联合索引**时，需要满足最左前缀原则。下面举例对其进行说明：

1. 一个2列的索引 (name, age)，对 (name)、(name, age) 上建立了索引；
2. 一个3列的索引 (name, age, sex)，对 (name)、(name, age)、(name, age, sex) 上建立了索引。

B+ 树的数据项是复合的数据结构，比如：`(name, age, sex)` 的时候，B+ 树是按照**从左到右的顺序来建立搜索树**的，比如：当`(小明, 22, 男)`这样的数据来检索的时候，B+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是**第一个比较因子**，必须要先根据 name 来搜索才能知道下一步去哪里查询。当 (小明, 男) 这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于小明的数据都找到，然后再匹配性别是男的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

> **关于最左前缀的补充：**
>
> 最左前缀匹配原则会一直向右匹配直到**遇到范围查询（>、<、between、like）就停止匹配**，比如：`a = 1 and b = 2 and c > 3 and d = 4` 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引的。而如果建立 (a, b, d, c) 的索引则都可以用到，a、b、d 的顺序可以任意调整（见下面说明）。
>
> **= 和 in 可以乱序**，比如：`a = 1 and b = 2 and c = 3` 建立 (a, b ,c) 索引可以任意顺序，MySQL 的优化器会优化成索引可以识别的形式。

> 详见：[MySQL：提高笔记-3](https://www.cnblogs.com/zhuchengchao/p/14457419.html)

### 索引 / SQL语句 执行情况分析

**怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因？**

使用 **explain命令** 来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。

> 详见：[MySQL：提高笔记-2](https://www.cnblogs.com/zhuchengchao/p/14456026.html)

### 索引失效 :exclamation:

下面列举几种不走索引的 SQL 语句：

1. **索引列参与表达式计算**：

   ```mysql
   SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30;
   ```

2. **违反最左前缀法则**：

   - 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。
   - 匹配最左前缀法则，则索引；
   - 违反最左前缀法则，索引失效：
   - 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：

3. **在范围查询条件右边的列，不能使用索引**：

   ```mysql
   explain select * from tb_seller where name='小米科技' and status>'1' and address='北京市';  
   -- 根据前面的两个字段name, status 查询是走索引的， 但是最后一个条件address没有用到索引。
   ```

4. **函数运算**：

   ```mysql
   SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1990; 
   ```

5. **以 % 开头的 Like 模糊查询，索引失效**。

   如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

   ```mysql
   SELECT * FROM 'manong' WHERE `uname` LIKE '码农%'  -- 走索引 
   SELECT * FROM 'manong' WHERE `uname` LIKE "%码农%" -- 不走索引 
   ```

6. **字符串与数字比较不走索引/字符串不加单引号，造成索引失效**：

   ```mysql
   CREATE TABLE 'a' ('a' char(10)); 
   EXPLAIN SELECT * FROM 'a' WHERE 'a'="1" -- 走索引 
   EXPLAIN SELECT * FROM 'a'WHERE 'a'=1 -- 不走索引，同样也是使用了函数运算 
   ```

   即：在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。

7. 查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，**就是用or进行连接的所有字段都必须建立索引，才会走索引**：

   ```mysql
   select * from dept where dname='xxx' or loc='xx' or deptno = 45;
   ```

8. **正则表达式不使用索引**。

9. **MySQL 内部优化器**会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。

10. `is NULL` ， `is NOT NULL`  **有时**索引失效：

    依据：若所查询的列数据中，根据数据是 NULL 还是 NOT NULL 的占比来决定是否使用索引。

11. **in 则索引， not in 索引失效**。

    ```mysql
    explain select * from tb_seller where sellerid in ("alibaba", "baidu", "xiaomi");  -- 会走索引
    
    explain select * from tb_seller where sellerid not in ("alibaba", "baidu", "xiaomi");  -- 不会走索引
    ```

> 详见：[MySQL：提高笔记-3](https://www.cnblogs.com/zhuchengchao/p/14457419.html)

### 提高查询性能的方法 :exclamation:

**减少请求的数据量**

1. 只返回必要的列：最好不要使用 SELECT * 语句。
2. 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
3. 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

**减少服务器端扫描的行数**：最有效的方式是使用索引来覆盖查询。

> 详见：[MySQL：提高笔记-3](https://www.cnblogs.com/zhuchengchao/p/14457419.html)

### InnoDB & MyISAM 比较 :exclamation::exclamation:

1. **事务**：MyISAM 不支持事务，InnoDB 支持事务；

2. **全文索引**：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引，之后就支持了；

3. **关于 `count(*)`**：MyISAM 会直接存储总行数，~~InnoDB 则不会，需要按行扫描~~（优化了，见下面）。

4. **外键**：MyISAM 不支持外键，InnoDB 支持外键；

5. **锁**：MyISAM 只支持表锁，InnoDB 可以支持行锁。

> 对于 InnoDB 存储引擎下的 count 做进一步说明：
>
> - **`count(可空字段)`**：扫描全表，读到server层，判断字段可以为空，拿出该字段所有值，判断每一个值是否为空，不为空则累加
>
> - **`count(非空字段)`与`count(主键 id)`**：扫描全表，读到server层，判断字段不可为空，按行累加
>
> - **`count(1)`**：扫描全表，但不取值，server 层收到的每一行都是1，判断不可能是null，按值累加
>
>   > 注意：`count(1)` 执行速度比 `count(主键 id)` 快的原因，因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。
>
> - **`count(*)`**：MySQL 执行 `count(*)`在优化器做了专门优化。因为 `count(*)` 返回的行一定不是空。扫描全表，但是不取值，按行累加。
>
> - **性能对比结论**：**`count(可空字段) < count(非空字段) = count(主键 id) < count(1) ≈ count(*)`**

> 详见：[MySQL：提高笔记-2](https://www.cnblogs.com/zhuchengchao/p/14456026.html)

### 水平切分 & 垂直切分 :exclamation::exclamation:

> 待完善

**水平切分**

水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而减小单个数据库的压力。

**垂直切分**

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。

### 数据库的主从复制

从数据库（Slave）是主数据库的备份，当主数据库（Master）变化时，从数据库要进行更新操作。

**主从分工**：

其中 Master 负责写操作负载，而读操作则分摊到 Slaver 上进行。这样一来的可以大大提高读取的效率。

> 在一般的互联网应用中，经过一些数据调查得出结论，读/写的比例大概在 10：1左右 ，也就是说大量的数据操作是集中在读的操作，这也就是为什么我们会有多个Slave的原因。

进行读写分工的原因：写操作涉及到锁的问题，不管是行锁还是表锁还是行锁，都是比较降低系统执行效率的事情。我们这样的分离是把写操作集中在一个节点上，而读操作其其他的N个节点上进行，从另一个方面有效的提高了读的效率，保证了系统的高可用性

**基本过程**

1. MySQL 的主从同步就是当 master（主库）发生数据变化的时候，会实时同步到 slave（从库）
2. 主从复制可以水平扩展数据库的负载能力，容错，高可用，数据备份。
3. 不管是delete、update、insert，还是创建函数、存储过程，都是在master上，当master有操作的时候，slave 会快速的接受到这些操作，从而做同步。

**用途和条件**

1. MySQL 主从复制用途
   * 实时灾备，用于故障切换
   * 读写分离，提供查询服务
   * 备份，避免影响业务
2. 主从部署必要条件
   * **主库开启 binlog 日志（设置log-bin参数）**
   * 主从server-id不同
   * 从库服务器能连通主库

**主从同步的三种主要实现粒度说明**

1. statement：会将对数据库操作的**SQL 语句**写到 binlog 中
2. row：会将每一条**数据的变化**写到 binlog 中
3. mixed：**statement与row的混合**。MySQL 决定何时写 statement 格式的binlog，何时写 row 格式的 binlog。

### 主从复制的流程及涉及的三个线程 :exclamation:

**在 master 机器上的操作**：

* 当 master 上的数据发生变化时，该事件变化会按照**顺序写入 binlog 中**。
* 当 slave 链接到 master 的时候，master 机器会为 slave 开启 binlog dump 线程。
* 当 master 的 binlog 发生变化的时候，binlog dump 线程会**通知slave**，并将相应的binlog内容发送给slave。

**在 slave 机器上的操作：**

* 当主从同步开启的时候，slave上会创建两个线程：**I\O线程**。
* 该线程连接到 master 机器，master 机器上的binlog dump 线程会将 binlog 的内容发送给该 I\O 线程。
* 该 I/O 线程接收到 binlog 内容后，**再将内容写入到本地的 relay log**。
* sql 线程，该线程读取到 I/O 线程写入的 relay log。并且根据relay log 的内容对 slave 数据库做相应的操作。

**上述过程主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。**

1. **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
2. **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）中。
3. **SQL 线程** ：负责读取中继日志并重做中继日志中SQL语句，将改变反映它自己的数据。

![mysql主从复制](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251811695.jpg)

### 主从同步的延迟原因及解决办法

**主从同步的延迟的原因：**

假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是**从服务器的里面读取 binlog 的线程仅有一个（单线程）**，因为**从服务器上的SQL thread 也是一个单线程**，当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

> 而 主服务器 上的 SQL 线程是可以并发的，因此不会存在相应的问题，而 从服务器 上的 I/O线程 和 SQL 线程都是一个单线程。

**主从同步延迟的解决办法：**

实际上主从同步延迟根本没有什么一招制敌的办法，因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。

1. 我们知道因为主服务器要负责更新操作，**它对安全性的要求比从服务器高**，所有有些设置可以修改，比如`sync_binlog=1`，`innodb_flush_log_at_trx_commit=1` 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 `sync_binlog` 设置为 0 或者关闭 `binlog`、`innodb_flushlog`、`innodb_flush_log_at_trx_commit` 也可以设置为 0 来提高 SQL 的执行效率。
2. 增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。

> sync_binlog：该参数控制着二进制日志写入磁盘的过程，默认`sync_binlog=0`，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新；这时候的性能是最好的，但是风险也是最大的；一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。
>
> innodb_flush_log_at_trx_commit：默认值1的意思是提交事务的时候将 redo 日志写入磁盘中

### 对数据库读写分离的理解

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

**读写分离能提高性能的原因在于：**

1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
2. 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
3. 增加冗余，提高可用性。

### 数据库的事务 :exclamation::exclamation::exclamation:

**概述**：事务执行是一个整体，所有的 SQL 语句都必须执行成功。如果其中有 1 条 SQL 语句出现异常， 则所有的 SQL 语句都要回滚，整个业务执行失败。

MySQL 中可以有两种方式进行事务的操作 ：

* 手动提交事务：

  * 开启事物：`start transaction;`
  * 提交事务：`commit;`
  * 回滚事务：`rollback;`

* 自动提交事务（默认）

  MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务，MySQL 默认开始自动提交事务  

**事务原理**

事务开启之后，所有的操作都会临时保存到**事务日志**中，事务日志只有在得到 commit 命令才会同步到数据表中，其他任何情况都会清空事务日志（rollback，断开连接）

**事务的步骤**

1. 客户端连接数据库服务器，连接时创建此用户**临时日志文件**
2. 开启事务以后，所有的操作都会先写入到临时日志文件中
3. 所有的查询操作从表中查询，但会**经过日志文件加工后才返回**
4. 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件。  

### 数据库事务的特性 ACID :exclamation::exclamation:

> https://zhuanlan.zhihu.com/p/270209292

1. **原子性A**：每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都失败。

   > 通过 undolog 实现： **当事务对数据库进行修改的时候，InnoDB会生成对应的undo log ；如果此时事务执行失败或者调动了 rollback，导致事务出现回滚情况，可以利用undo log中的信息将数据回滚到修改前的样子**

2. **一致性C**：执行事务前后，数据库从一个正确的状态转换到另一个正确的状态。

   > 这个正确的状态指的是**数据库的数据是符合一定的数据约束条件的**；
   >
   > 而 ACID 就是说事务能够通过 AID 来保证这个 C 的过程，C是目的，AID都是手段。

3. **隔离性I**：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；

   > 读写锁+MVCC 实现

4. **持久性D**：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

   > 通过 redolog 进行保证

> 详见：[MySQL：基础语法-3](https://www.cnblogs.com/zhuchengchao/p/14453811.html)

### 脏读 & 不可重复读 & 幻读 :exclamation::exclamation:

**脏读：**表示一个事务能够读取另一个事务中还未提交的数据。比如：某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

**不可重复读 ：**是指在一个事务内，多次读同一数据，出现了读取的数据不一样的情况，这是由于一个事务可以读取另一个事务已经提交的数据而导致的。

**幻读：**指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。**发生幻读的原因**也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

> 详见：[MySQL：基础语法-3](https://www.cnblogs.com/zhuchengchao/p/14453811.html)

### 事务的隔离级别 :exclamation::exclamation:

1. **READ_UNCOMMITTED（RU，读未提交）**: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；

2. **READ_COMMITTED（RC，读已提交）**: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；Oracle 默认采用的 READ_COMMITTED 隔离级别。

3. **REPEATABLE_READ（RR，可重复读）**: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；MySQL 默认采用的 REPEATABLE_READ 隔离级别。

4. **SERIALIZABLE（串行化）**: 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

> 详见：[MySQL：基础语法-3](https://www.cnblogs.com/zhuchengchao/p/14453811.html)

### 对多版本并发控制(MVCC)的了解 :exclamation::exclamation:

> https://www.jianshu.com/p/8845ddca3b23

**数据库并发场景：**

1. 读-读：不存在任何问题，也不需要并发控制；
2. **读-写**：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；（**MVCC解决**）
3. 写-写：有线程安全问题，可能会存在更新丢失问题。

**多版本并发控制**（MVCC，Multi-Version Concurrency Control）是一种用来解决**读-写冲突的无锁并发控制**：

1. 在并发读写数据库时，可以做到在**读操作时不用阻塞写操作，写操作也不用阻塞读操作**，提高了数据库并发读写的性能；
2. 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但**不能解决更新丢失问题**。

3. 也就是为事务分配单向增长的时间戳，**为每个修改保存一个版本**，版本与事务时间戳关联，**读操作只读该事务开始前的数据库的快照**。 

**当前读/快照读：**

* **当前读**：加共享锁/排它锁都是一种当前读，**读数据库记录的最新版本**，读取时还要保证其他并发事务不能修改当前记录，**会对读取的记录进行加锁**，是悲观锁的实现；
* **快照读**：不加锁的非阻塞读，快照读的实现是基于多版本并发控制，既然是基于多版本，即**快照读可能读到的并不一定是数据的最新版本**，而有可能是之前的历史版本；
* MVCC 就是为了实现**读-写冲突不加锁**，而这个读指的就是快照读，而非当前读；

**MVCC实现原理**：

* MVCC 模型在 MySQL 中的具体实现则是由 **3 个隐式字段**，**undo日志** ，**Read View** 等去完成的；

* **隐式字段**：

  - DB_TRX_ID，最近修改(修改/插入)事务ID；
  - DB_ROLL_PTR，回滚指针，指向这条记录的上一个版本，（存储于rollback segment里）；
  - DB_ROW_ID，隐含的自增ID，隐藏主键；

* **undo日志**：

  * insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃；
  * update undo log：事务在进行 update 或 delete 时产生的 undo log，不仅在事务回滚时需要，**在快照读时也需要**，不能随便删除，不需要时会被 purge；**对MVCC有帮助的实质是update undo log**

  不同事务或者相同事务的对同一记录的修改，**会导致该记录的 undo log 成为一条记录版本线性表**，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录

* **Read View(读视图)**

  * **事务进行快照读操作的时候产生的读视图**，在该事务执行的快照读的那一刻，**会生成数据库系统当前的一个快照**，记录并维护系统当前活跃事务的 ID (当每个事务开启时，都会被分配一个 ID，这个ID是递增的，所以最新的事务，ID值越大)
  * Read View 主要是用来做可见性判断的，对该记录创建一个 Read View 读视图，把它**比作条件用来判断当前事务能够看到哪个版本的数据**（既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据）
  * Read View 遵循一个**可见性算法**，根据 DB_TRX_ID 来判断，不符合可见性，则通过 DB_ROLL_PTR 回滚指针去 Undo Log 里取 DB_TRX_ID 再进行比较；
  
  > 比较规则：
  >
  > 1. 事物进行快照读会产生一个 ReadView，ReadView 维护生成时刻系统获取的 事物ID，假定产生一个列表（trx_list）；然后再记录事物列表中最小的事物ID（up_limit_id）; 在记录此时尚未分配的下一个事物 ID（low_limit_id，即当前出现过的最大事物ID+1）；
  > 2. DB_TRX_ID < up_limit_id，当前事物可以看见 DB_TRX_ID 所在的所有记录；
  > 3. DB_TRX_ID >= low_limit_id，说明 DB_TRX_ID 所在记录是在 ReadView 出现后再出现的，则数据对当前事物不可见；
  > 4. 再判断 DB_TRX_ID 是否在 trx_list 中，如果在，说明 ReadView 生成时刻，当前事物还在活跃汇中，还没有 Commit，则修改对当前事物也不可见；如果不在，当前事物在 ReadView 生成时刻已经 Commit 了，对数据修改的结果当前事物能看见。

### MySQL 的行锁和表锁 :exclamation::exclamation:

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

**表级锁**：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。

**行级锁**：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

InnoDB 实现了以下两种类型的行锁：

* **共享锁（S）**：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是**只能读不能修改**。
* **排他锁（X）**：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据进行读取和修改。

**无索引行锁升级为表锁**：如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。

**间隙锁**：当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； **对于键值在条件范围内但并不存在的记录，叫做 "间隙（GAP）"** ， InnoDB也会对这个 "间隙" 加锁，这种锁机制就是所谓的间隙锁（Next-Key锁） 。

> 详情：[MySQL：提高笔记-4](https://www.cnblogs.com/zhuchengchao/p/14458881.html)

### InnoDB 存储引擎的锁的算法

1. Record lock：单个行记录上的锁；
2. Gap lock：间隙锁，锁定一个范围，不包括记录本身；
3. Next-key lock：record+gap 锁定一个范围，包含记录本身。

### MySQL 问题排查的手段

1. 使用 show processlist 命令查看当前所有连接信息；
2. 使用 Explain 命令查询 SQL 语句执行计划；
3. 开启**慢查询日志**，查看慢查询的 SQL。

### 数据库 CPU 飙升到 500% 如何处理

1. 列出所有进程  show processlist，观察所有进程，多秒没有状态变化的(干掉)；
2. 查看超时日志或者错误日志 ，一般会是查询以及大批量的插入会导致 CPU与 I/O 上涨，当然不排除网络状态突然断了，导致一个请求服务器只接受到一半。

