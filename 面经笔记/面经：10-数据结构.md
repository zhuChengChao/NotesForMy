# 面经：10-数据结构\

> 个人整理 :muscle: 个人专用 :muscle: 暑期实习 :muscle: 秋招 :muscle: 后端开发 :muscle: 八股文 :no_mouth:

## 排序算法

### 判定标准

**时间复杂度**

时间复杂度其实就代表了一个算法执行的效率，我们在分析排序算法的时间复杂度时要分别给出**最好情况、最坏情况、平均情况下的时间复杂度**。

为什么要区分这三种时间复杂度呢？

* 第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。
* 第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

复杂度反映的是一个算法随着 n 的变化的一个增长趋势，在表示的时候往往会忽略表达式中的系数，低阶，常量，但是实际的软件开发中，我们排序的可能是 50 个、100 个、1000 个这样规模很小的数据，所以，**在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来**。

对于排序算法中的不同实现，其中有些排序算法是基于数据比较的排序算法，这些算法在执行过程中会涉及到比较元素大小，然后元素的交换或者移动，所以**在分析基于比较的排序算法时要将元素比较/交换/移动的次数也考虑进来**。

**空间复杂度**

空间复杂度在一个层面代表了算法对存储空间的消耗程度，我们可以简单的理解为算法的内存消耗，在这里我们还引入另外一个概念：**in-place** 和 **out-place**；其中 in-place 可以称为原地排序就是特指空间复杂度为 `O(1)` 的排序算法，**算法只占用常数内存，不占用额外内存**，而 out-place 的算法需要**占用额外内存**。

**算法稳定性**

如果我们只用上面提到的时间复杂度和空间复杂度来度量一个排序算法其实是不够的，针对排序算法，还有一个指标就是：**稳定性。所谓排序算法的稳定性指的是：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。**

* 举个例子：有一组数据：3 7 2 7 5 8 9，我们按照大小排序之后的数据为：2 3 5 7 7 8 9，在这组数据中有两个 7，如果经过某种排序算法后两个 7 的前后顺序没有发生改变则称该算法是稳定的排序算法，否则称为该算法是不稳定的排序算法。

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813400.PNG" alt="快排稳定性" style="zoom: 50%;" />

* 稳定性的意义：

  如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。

  > 例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。 

### 冒泡排序

**概述**

冒泡排序(Bubble Sort)是一种简单的排序算法，它通过依次比较两个相邻的的元素，看两个元素是否满足大小关系要求，如果不满足则交换两个元素。每一次冒泡会让至少一个元素移动到它应该在的位置上，这样 n 次冒泡就完成了 n 个数据的排序工作。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

接下来对整个算法的过程进行描述：

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上两个步骤，除了最后一个；
4. 重复前三步，直到排序完成。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813301.PNG" alt="冒泡排序" style="zoom: 67%;" />

**实现**

```java
public class BubbleSort {

    /**
     *	冒泡排序算法
     *	冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
     *	走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
     *	这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端
     *
     *	步骤:
     *	1：比较相邻的元素。如果第一个比第二个大，就交换它们两个；
     *  2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
     *  3：针对所有的元素重复以上的步骤，除了最后一个；
     *  4：重复步骤 1~3，直到排序完成。
     */

    // 最为基础的冒泡排序算法
    public static void bubbleSort1(int[] array){
        int len = array.length;
        if(len<=1){
            return;
        }

        // 开始冒泡
        for (int i = 0; i < len-1; i++) {
            for (int j = 0; j < len-i-1; j++) {
                // 判断前后数据是否需要交换 如果前一个数据大于后一个数据则进行交换否则不交换
                if(array[j]>array[j+1]){
                    int tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
    }

    // 测试冒泡排序
    public static void main(String[] args) {
        // 准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3};
        // 进行排序
        bubbleSort1(array);
        System.out.println(Arrays.toString(array));
    }
}
```

实际上，这里的冒泡排序算法还可以**继续优化**：因为当某次冒泡时发现已经没有数据需要进行交换时，说明所有元素都已经达到有序状态了，此时就不用再执行后续的冒泡操作了，接下来对之前的冒泡进行优化的代码实现如下：

```java
public static void bubbleSort2(int[] array){
    int len = array.length;
    if(len<=1){
        return;
    }

    // 开始冒泡
    for (int i = 0; i < len-1; i++) {
        // 是否需要提前结束冒泡的标识
        boolean flag = true;
        for (int j = 0; j < len-i-1; j++) {
            // 判断前后数据是否需要交换 如果前一个数据大于后一个数据则进行交换否则不交换
            if(array[j]>array[j+1]){
                int tmp = array[j];
                array[j] = array[j+1];
                array[j+1] = tmp;

                flag = false;
            }
        }
        // 在当前这次冒泡中如果所有元素都不需要进行交换则证明所有元素都已有序,则无需进行后续的冒泡操作了
        if(flag){
            break;
        }
    }
}
```

**总结**

对于冒泡排序我们要使用之前学习的三个标准来进行评判：

1. **冒泡排序的时间复杂度是多少？**

   最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以**最好情况时间复杂度是O(n)**。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行n次冒泡操作，所以**最坏情况时间复杂度为O(n^2)**。

2. **冒泡排序的空间复杂度是多少？** 

   冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，**是一种 in-place 排序算法**。

3. **冒泡排序是稳定的排序算法吗？** 

   在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是**稳定的排序算法**。

### 插入排序

**概述**

插入排序(Insertion Sort)的原理是：将数组中的数据分为两个区间，**已排序区间和未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤 2~5。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813492.PNG" alt="插入排序2" style="zoom:67%;" />

**实现**

```java
public class InsertionSort {
    /**
     *	插入排序算法
     *	插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。
     *	我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
     *
     *	步骤：
     *    1：从第一个元素开始，该元素可以认为已经被排序；
     *    2：取出下一个元素，在已经排序的元素序列中从后向前扫描；
     *    3：如果该元素（已排序）大于新元素，将该元素移到下一位置；
     *    4：重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
     *    5：将新元素插入到该位置后；
     *    6：重复步骤 2~5。
     */
    private static void insertionSort1(int[] arr){
        int len = arr.length;
        if(len <= 1) {
            return;
        }

        // 开始排序：第一个元素默认已经排序完成
        for (int i = 1; i < len; i++) {
            // 取出未排序的下一个元素，及当前参与比较的元素
            int current = arr[i];
            // 在已经排序的元素序列中从后向前扫描,定义前置索引
            int preIndex = i - 1;
            //从后向前依次和当前元素进行比较,
            while (preIndex >= 0 && (arr[preIndex]>current)){
                // 比较过程中如果元素大于当前的元素则将元素后移一位
                arr[preIndex+1]=arr[preIndex];
                preIndex--;
            }
            // 比较过程中如果该元素小于等于当前元素,则将当前元素放在该元素后面
            arr[preIndex+1] = current;
        }
    }

    public static void main(String[] args) {
        // 准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3};
        // 进行排序
        System.out.println(Arrays.toString(array)); insertionSort1(array);
        // 输出排序结果
        System.out.println(Arrays.toString(array));
    }
}
```

**总结**

1. **插入排序的时间复杂度是多少？**

   如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，**最好时间复杂度为** **O(n)**。注意，这里是从尾到头遍历已经有序的数据。

   如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以**最坏情况时间复杂度为O(n^2)**。

   > 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以**平均时间复杂度为O(n^2)**。

2. **插入排序的空间复杂度是多少？**

   从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以**空间复杂度是** **O(1)**，也就是说，这是一个 **in-place（原地排序）排序算法**。

3. **插入排序是稳定的排序算法吗？**

   在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以**插入排序是稳定的排序算法**。

### 希尔排序

**概述**

希尔排序是插入排序的一种，又称“**缩小增量排序**”，是插入排序算法的一种更高效的改进版本。 

前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为 [2,5,7,9,10]，未排序的分组元素为 [1,8]，那么下一个待插入元素为 1，我们需要拿着1从后往前，依次和 [10,9,7,5,2] 进行交换位置，才能完成真正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数，这样的需求如何实现呢？接下来我们来看看希尔排序的原理。 

排序原理：

1. 选定一个**增长量h**，按照增长量h作为数据分组的依据，对数据进行分组；
2. 对分好组的每一组数据完成插入排序；
3. 减小增长量，最小减为1，重复第二步操作。 

![希尔排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813594.PNG)

增长量 h 的确定：增长量 h 的值每一固定的规则，我们这里采用以下规则

```java
int h=1
while(h < 数组长度/2){
    h = 2h+1;
}

// 循环结束后我们可以确定h的最大值
// h的减小规则为：
h=h/2
```

**实现**

```java
/**
 * 希尔排序算法：https://www.cnblogs.com/chengxiao/p/6104371.html
 */
public class ShellSort {

    /**
     * 希尔排序：针对有序序列在插入时采用交换法
     * @param arr
     */
    public static void sortCmp(int []arr){
        // 增量gap，并逐步缩小增量
        for(int gap = arr.length/2; gap > 0; gap /= 2){
            // 从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i = gap; i < arr.length; i++){
                int j = i;
                while(j-gap >= 0 && arr[j] < arr[j-gap]){
                    // 插入排序采用交换法
                    swap(arr, j, j-gap);
                    j -= gap;
                }
            }
        }
    }

    /**
     * 希尔排序 针对有序序列在插入时采用移动法。
     * @param arr
     */
    public static void sortMove(int arr[]){
        // 增量gap，并逐步缩小增量
        for(int gap = arr.length/2; gap > 0; gap /= 2){
            // 从第gap个元素，逐个对其所在组进行直接插入排序操作
            for (int i = gap; i < arr.length; i++){
                int j = i;
                int temp = arr[j];
                if(arr[j] < arr[j-gap]){
                    while (j-gap >= 0 && arr[j-gap] > arr[j]) {
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                }
                arr[j] = temp;
            }
        }
    }

    public static void swap(int[] arr, int a, int b){
        arr[a] = arr[a] + arr[b];
        arr[b] = arr[a] - arr[b];
        arr[a] = arr[a] - arr[b];
    }

    // 测试代码
    public static void main(String[] args) {
        int[] a = {9,1,2,5,7,4,8,6,3,5};
        // sortCmp(a);
        sortMove(a);
        System.out.println(Arrays.toString(a));
    }
}
```

**总结**

1. **希尔排序的时间复杂度是多少？**

   希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能，若增量选择上述 n/2,  (n/2)/2, ..., 1 则最坏的情况下杂度依然为 O(n^2)；而选择一些优化的增量序列其复杂度还可以更低，不做讨论了。

2. **希尔排序的空间复杂度是多少？**

   从实现过程可以很明显地看出，希尔排序算法的运行并不需要额外的存储空间，所以**空间复杂度是** **O(1)**，也就是说，这是一个 **in-place（原地排序）排序算法**。

3. **希尔排序是稳定的排序算法吗？**

   希尔排序是按照不同步长对元素进行插入排序，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是**不稳定**的。

### 选择排序

**概述**

选择排序(Selection Sort)的原理有点类似插入排序，也分已排序区间和未排序区间。但是**选择排序每次会从排序区间中找到最小的元素，将其放到已排序区间的末尾**。

算法描述如下：

1. 初始状态：无序区间为 R[1..n]，有序区为空；
2. 第 i 趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录交换，使 R[1..i] 和 R[i+1..n] 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；
3. n-1 趟结束，数组有序化了。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813432.PNG" alt="选择排序" style="zoom:67%;" />

**实现**

```java
public class SelectionSort {
    /**
     *	选择排序算法
     *	选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。
     *	但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
     */
    public static void selectionSort(int[] arr){
        int len = arr.length;
        if(len <= 1){
            return;
        }
        for(int i=0; i<len; i++){
            // 接下来找到未排序区间的最小值的下标
            int minIndex = i;
            for (int j = i+1; j < len; j++) {
                if(arr[minIndex]>arr[j]){
                    minIndex = j;
                }
            }
            // 交换元素
            int current = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = current;
        }
    }

    public static void main(String[] args){
        // 准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3};
        // 排序前数组
        System.out.println(Arrays.toString(array)); 
        // 进行排序
        selectionSort (array);
        // 输出排序结果
        System.out.println(Arrays.toString(array));
    }
}
```

**总结**

1. **选择排序的时间复杂度是多少？**

   结合之前的分析方式分析可知选择排序的**最好情况时间复杂度为O(n^2)，最坏情况时间复杂度为:O(n^2)，平均情况下的时间复杂度为:O(n^2)**。

2. **选择排序的空间复杂度是多少？**

   通过算法的实现我们可以发现，选择排序的**空间复杂度为 O(1)，是一个in-place排序算法**

3. **选择排序是一个稳定的排序算法吗？**

   **选择排序不是一个稳定的排序算法**，为什么呢？选择排序每次都要找剩余未排序元素中的最小值，并和未排序区间的第一个元素进行交换位置，这样破坏了稳定性，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，从稳定性上来说选择排序相对于冒泡排序和插入排序就稍微逊色了。

### 归并排序

**概述**

归并排序(Merge Sort)的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序使用的是**分治思想**。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。**分治是一种解决问题的处理思想，递归是一种编程技巧**，这两者并不冲突。而对于递归就是要找到递推公式及终止条件，所以我们可以先写出归并排序的递推公式
$$
mergeSort(m...n) = merge(mergeSort(m...k),mergeSort(k+1..n));当 m=n时终止
$$
我们来解释一下这个公式：我们要对 [m...n] 之间的数列进行排序，其实可以拆分成对 [m...k] 之间的数列进行排序，以及对 [k+1...n] 之间的数列排序，然后将连个拍好序的数列进行合并就称为了最终的数列，同样的道理，每一段数列的排序又可以继续往下拆分，形成递归。

算法描述：

1. 把长度为 n 的输入序列分成两个长度为 n/2 的子序列；
2. 对这两个子序列分别采用归并排序；
3. 将两个排序好的子序列合并成一个最终的排序序列。

![归并排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813077.PNG)

**实现**：

```java
public class MergeSort {

    /**
      *	归并排序算法
      *	归并排序的核心思想还是蛮简单的。
      *	如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，
      *	再将排好序的两部分合并在一起，这样整个数组就都有序了
      */
    private static int[] mergeSort(int[] arr){
        if(arr.length < 2){
            return arr;
        }
        // 将数组从中间拆分成左右两部分
        int mid = arr.length/2;
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        return merge(mergeSort(left), mergeSort(right));
    }

    // 合并两个有序数组并返回新的数组
    private static int[] merge(int[] left, int[] right){
        // 创建一个新数组,长度为两个有序数组的长度之和
        int[] newArray = new int[left.length+right.length];
        // 定义两个指针,分别代表两个数组的下标
        int lindex = 0;
        int rindex = 0;
        for(int i=0; i<newArray.length;i++){
            if(lindex >= left.length){
                newArray[i] = right[rindex++];
            }else if(rindex >= right.length){
                newArray[i] = left[lindex++];
            }else if(left[lindex] > right[rindex]){
                newArray[i] = right[rindex++];
            }else{
                newArray[i] = left[lindex++];
            }
        }
        return newArray;
    }

    public static void main(String[] args) {
        // 准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3};
        System.out.println(Arrays.toString(array));
        // 进行排序
        array = mergeSort(array);
        // 输出排序结果
        System.out.println(Arrays.toString(array));
    }
}
```

**总结**

1. **归并排序的时间复杂度是多少？**

   归并排序涉及递归，递归适用的场景是一个问题 A 可以拆分成多个问题 B,C，问题 A 的解就等于问题 B 的解 + 问题 C 的解，同理，问题 B/C 可按照相同方式进行拆分，所以问题 A 的时间复杂度可以表示为：
   $$
   O(A) = O(B)+O(C)+O(k)
   $$
   
   
   其中 O(A) 代表A的时间复杂度，O(B) 代表求解问题B的时间复杂度，O(C) 代表求解问题C的时间复杂度，O(k) 代表将问题B的解和问题C的解合并称为最终的解的时间复杂度。
   
   从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
   
   我们假设对 n 个元素进行归并排序需要的时间是 O(n)，那分解成两个子数组排序的时间都是 O(n/2)。我们知道，`merge()` 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：
   $$
   O(1) = C;~~~~~~~~n=1时，只需要常量级的执行时间，所以表示为C \\O(n) = 2×O(n/2) + n； n>1
   $$
   
   
   可能这个公式看起来仍然不直观，那我们继续往下分解几步，
   $$
   O(n) = 2×O(n/2) + n \\ =2×(2×O(n/4)+n/2) + n=4×O(n/4)+2×n\\=	4×(2×O(n/8) + n/4) + 2×n = 8×O(n/8) + 3×n\\......\\=2^k × O(n/2^k) + k × n
   $$
   
   
   所以最终：得到**归并排序的时间复杂度为：O(nlogn)**
   
   从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)

2. **归并排序的空间复杂度是多少？**

   **O(n)**，因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解，但是如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？

   实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以**空间复杂度是** **O(n)**，因此归并排序并不是一种 in-place 排序算法而是**一种 out-place 排序算法**。

3. **归并排序是稳定的排序算法吗？**

   归并排序算法稳定取决于合并函数 `merge()`。也就是两个有序子数组合并成一个有序数组的那部分代码，通过分析 `merge()` 函数我们发现，**归并排序也是一个稳定的排序算法**。

### 快速排序 :exclamation:

**原理**

快速排序(Quick Sort)算法，简称快排，利用的也是分治的思想，初步看起来有点像归并排序，但是其实思路完全不一样，快排的思路是：如果要对 [m...n] 之间的数列进行排序，我们选择 [m...n] 之间的任意一个元素数据作为**分区点(Pivot)**，然后我们遍历 [m...n] 之间的所有元素，将小于 pivot 的元素放到左边，大于 pivot 的元素放到右边，pivot 放到中间，这样整个数列就被分成三部分了，[m...k-1] 之间的元素是小于 pivot 的，中间是 pivot，[k+1...n] 之间的元素是大于 pivot 的。然后再根据分治递归的思想处理两边区间的的元素数列，直到区间缩小为 1，就说明整个数列都已有序了。

算法描述如下：

1. 从数列中挑出一个元素，称为 **“基准”（pivot）**；
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为**分区（partition）操作**；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![快速排序原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813626.PNG)

如果我们用递推公式来将上面的过程写出来的话，就是这样：
$$
递推公式：quickSort(p...r)=quickSort(p...q-1)+quickSort(q+/1...r)
$$
终止条件：
$$
p>=r
$$
接下来将递推公式翻译成伪代码如下：

```java
//	快速排序，A 是数组，n 表示数组的大小 
quick_sort(A, n) {
	quickSort(A, 0, n-1)
}

//	快速排序递归函数，p,r 为下标 
quickSort(A, p, r) {
	if p >= r then return
	q = partition(A, p, r) // 获取分区点
	quickSort(A, p, q-1)
	quickSort(A, q+1, r)
}
```

我们这里有一个 `partition()` 分区函数。`partition()` 分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A:[p…r] 分区，函数返回 pivot 的下标。如果我们不考虑空间消耗的话，`partition()` 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]；

但是，如果按照这种思路实现的话，`partition()` 函数就需要很多额外的内存空间，快排就不是一种 in-place 排序算法了。如果我们希望快排的空间复杂度得是 O(1)，那 `partition()` 分区函数就不能占用太多额外的内存空间，我们就需要在 A:[p…r] 的原地完成分区操作,那如何去完成呢？其实这里的实现思路非常的巧妙，下面是实现分区的伪代码，一起来分析一下：

```java
partition(A, p, r) {
	pivot = A[r]  // 选择了最后一个元素作为分区点
	i = p		  // 用于记录交换到那个位置了
    for(j=p; j<=r-1; j++){
        if (A[j] < pivot) {
            // 发生了交换，则i++
        	swap A[i] with A[j]
        	i = i+1
        }
    }
    // 交换完成，对基准点进行交换操作
    swap A[i] with A[r]
    return i
}
```

**实现**

```java
public class QuickSort {

    /**
     * https://visualgo.net
     * 快速排序算法
     * 1：从数列中挑出一个元素，称为 “基准”（pivot）；
     * 2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
     * 3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
     */
    // 快排 借助递归和分区的思想来实现
    public static void quickSort(int arr[], int begin, int end){
        // 判断递归截止条件
        if(arr.length <= 1 || begin>=end){
            return;
        }

        // 进行分区 得到分区下标
        int pivotIndex = partition(arr, begin, end);
        // 对分区左侧进行快排
        quickSort(arr, begin, pivotIndex-1);
        // 对分区右侧进行快排
        quickSort(arr, pivotIndex+1, end);
    }

    private static int partition(int[] arr, int begin, int end){
        // 默认数组中待分区区间的最后一个是 pivot 元素
        // 当然也可以随机指定 pivot 元素
        int	pivot = arr[end];
        // 定义分区后 pivot 元素的下标
        int pivotIndex = begin;
        for(int i=begin; i<end; i++){
            // 判断如果该区间内如果有元素小于 pivot 则将该元素从区间头开始一直向后填充 有点类似选择排序
            if(arr[i] < pivot){
                if(i>pivotIndex){
                    swap(arr, i, pivotIndex);
                }
                pivotIndex++;
            }
        }
        swap(arr, pivotIndex, end);
        return pivotIndex;
    }

    // 交换数组内下标为 i j 的两个元素
    private static void swap(int[] arr,int i,int j){
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

    public static void main(String[] args) {
        // 准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3, 4};
        System.out.println(Arrays.toString(array));
        // 进行排序
        quickSort(array,0,array.length-1);
        // 输出排序结果
        System.out.println(Arrays.toString(array));
    }
}
```

**总结**

1. **快速排序的时间复杂度是多少？**

   快排的时间复杂度最好以及平均情况下的复杂度都是**O(nlogn)**，只有在极端情况下会变成O(n^2)。

   > 最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数(数组已经是有序的情况下容易出现这种情况)，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2); 
   >
   > <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813968.PNG" alt="快排最差情况" style="zoom: 50%;" />
   
2. **快速排序的空间复杂度是多少？**

   通过快排的代码实现我们发现，快排不需要额外的存储空间，所有的操作都能在既定的空间内完成，因此快排的**空间复杂度为O(1)**，也就是说快排是一种 in-place 的排序算法。

3. **快速排序是稳定的排序算法吗？**

   因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 [6_1, 8, 7, 6_2, 3, 5, 9, 4] 在经过第一次分区操作之后，若取最后一个元素作为 pivot ，则一次 partition 后的结果为：[3, 5, 4, 6_2, 6_1, 8, 9, 7]，两个 6 的相对先后顺序就会改变。所以，**快速排序并不是一个稳定的排序算法**。

   > **快排和归并的异同**
   >
   > 首先快排和归并都用到了分治递归的思想，在快排中对应的叫分区操作，递推公式和递归代码也非常相似，但是归并排序的处理过程是由下到上的**由局部到整体**，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下**由整体到局部**，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是一种 out-place 排序算法。主要原因是合并函数无法在原地(数组内)执行。**快速排序通过设计巧妙的原地(数组内)分区函数**，可以实现原地排序，解决了归并排序占用太多内存的问题。

截至目前：冒泡，插入，选择，归并，快排这几种排序，就复杂度而言：

* 冒泡，插入，选择都是：O(n^2);
* 归并和快排是：O(nlogn)；

接下来的三种排序算法：桶排序、计数排序、计数排序，其时间复杂度是 O(n) 。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作**线性排序（Linear sort）**。之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

### 桶排序*

**概述**

桶排序(Bucket Sort)顾名思义，会用到“桶”，桶我们可以将其想象成一个容器，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

换句话说：桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶，从值域上看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。

![桶排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813875.PNG)

桶排序过程中存在**两个关键环节**：

* **元素值域的划分**，也就是元素到桶的映射规则。映射规则需要根据待排序集合的元素分布特性进行选择，若规则设计的过于模糊、宽泛，则可能导致待排序集合中所有元素全部映射到一个桶上，若映射规则设计的过于具体、严苛，则可能导致待排序集合中每一个元素值映射到一个桶上。

* 从待排序集合中元素映射到各个桶上的过程，并不存在元素的比较和交换操作，在对各个桶中元素进行排序时，可以自主选择合适的排序算法，**每个桶内的排序算法的复杂度和稳定性，决定了最终的算法的复杂度和稳定性**。

那么桶排序的**时间复杂度**是多少呢？我们可以建议分析一下：

1. 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素；
2. 假设每个桶内部使用快速排序，时间复杂度为 O(k×logk)。
3. m 个桶排序的时间复杂度就是 O(m×k×logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n×log(n/m))。
4. 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

桶排序看起来是如此的优秀，那是不是可以替代我们之前讲到的排序算法呢？答案是否定的。

1. 首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
2. 其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。
3. 在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

**桶排序比较适合用在非内存排序中。所谓的非内存排序就是说数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。**

**此外由桶排序的过程可知，当待排序集合中存在元素值相差较大时，对映射规则的选择是一个挑战，有时可能导致元素集中分布在某一个桶中或者绝大多数桶是空桶的现象，对算法的时间复杂度或空间复杂度有较大影响，所以桶排序适用于元素值分布较为集中的序列，或者说待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间**。

> 举个例子：比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
>
> 如何借助桶排序的处理思想来解决这个问题？我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。
>
> 理想的情况下，如果订单金额在1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。
>
> 不过，你可能也发现了，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

接下来为了能对该算法做具体的实现，我们对该算法进一步做具体的描述：

1. 人为设置一个 BucketSize，作为每个桶所能放置多少个不同数值（例如当 BucketSize=5 时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放 100 个 3）；
2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；
3. 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
4. 从不是空的桶里把排好序的数据拼接起来。

**注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小 BucketSize 增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。**

图片演示：

![桶排序示例](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813016.PNG)

**实现**

```java
public class BucketSort {
    /**
      *	桶排序
      * @param array	  待排序集合
      * @param bucketSize 桶中元素类型的个数即每个桶所能放置多少个不同数值（例如当 BucketSize==5 时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放 100 个 3）
      * @return	排好序后的集合
      */
    public static List<Integer> bucketSort(List<Integer> array, int bucketSize){
        if(array == null || array.size()<2 || bucketSize < 1){
            return array;
        }

        // 找出集合中元素的最大值,最小值
        int max = array.get(0);
        int min = array.get(0);
        for (int i = 0; i < array.size(); i++) {
            if(array.get(i) > max){
                max = array.get(i);
            }
            if(array.get(i) < min){
                min = array.get(i);
            }
        }

        // 计算桶的个数 最大值-最小值代表了集合中元素取值范围区间
        int bucketCount = (max - min)/bucketSize + 1;
        // 按序创建桶,创建一个 List,List 带下标是有序的,List 中的每一个元素是一个桶,也用 List 表示
        List<List<Integer>> bucketList = new ArrayList<>();
        for (int i = 0; i < bucketCount; i++) {
            bucketList.add(new ArrayList<Integer>());
        }
        // 将待排序的集合依次添加到对应的桶中
        for (int j = 0; j < array.size(); j++) {
            int bucketIndex = (array.get(j)-min)/bucketSize;
            bucketList.get(bucketIndex).add(array.get(j));
        }
        // 对每一个桶中的数据进行排序(可以使用别的排序方式),
        //  然后再将桶中的数据依次取出存放到一个最终的集合中
        //  创建最终的集合
        List<Integer> resultList = new ArrayList<>();
        for (int i = 0; i < bucketCount; i++) {
            List<Integer> everyBucker = bucketList.get(i);
            // 如果桶内有元素
            if(everyBucker.size()>0){
                // 递归的使用桶排序为每一个桶进行排序--最后都只做到每个桶中只有一个元素
                // 当某次桶排序待排序集合都分配到一个桶中时,缩小桶的范围以获得更多的桶
                if(bucketCount == 1){
                    bucketSize --;
                }
                List<Integer> tmp = bucketSort(everyBucker, bucketSize);
                for (int j = 0; j < tmp.size(); j++) {
                    resultList.add(tmp.get(j));
                }
            }
        }
        return resultList;
    }

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(5);
        list.add(2);
        list.add(2);
        list.add(6);
        list.add(9);
        list.add(0);
        list.add(3);
        list.add(4);
        System.out.println(list);
        List<Integer> bucketSort = bucketSort(list, 4);
        System.out.println(bucketSort);
    }
}
```

**总结**

1. **桶排序的时间复杂度是多少？**

   桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，如果我们将待排序元素映射到某一个桶的映射规则做的很好的话，很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。我们一般对每个桶内的元素进行排序时采用快排也可以采用递归桶排序（上述代码），通过我们刚开始的分析，当我们对每个桶采用快排时如果桶的个数接近数据规模 n 时，**复杂度为O(n)**，如果在极端情况下复杂度退化为 O(nlogn)。

   > 上面有更为详细的分析

2. **桶排序的空间复杂度是多少？**

   由于需要申请额外的空间来保存元素，并申请额外的空间来存储每个桶，所以**空间复杂度为** **O(N+M)**，其中 M 代表桶的个数。所以桶排序虽然快，但是它是采用了用空间换时间的做法。

3. **桶排序是稳定的排序算法吗？**

   桶排序是否稳定取决于对每一个桶内元素排序的算法的稳定性，如果我们对桶内元素使用快排时桶排序就是一个不稳定的排序算法。

### 计数排序*

**概述**

计数排序(Counting Sort) 使用了一个额外的数组C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。其实计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 m，我们就可以把数据划分成 m 个桶(其实是个数组)。每个桶内的数据值都是相同的，省掉了桶内排序的时间。每个桶内存储的也不是待排序的数据而是待排序数组 A 中值等于某个值的元素个数

> 接下来我们以一个例子来说明:
>
> 我们都经历过高考，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 100 万考生，如何通过成绩快速排序得出名次呢？
>
> 我们都知道高考的满分是750 分，最小是 0 分，这个数据的范围很小，所以我们可以分成751个桶，对应分数从 0 分到 750 分。根据考生的成绩，我们将这 100 万考生划分到这 751 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序，那具体如何来做呢？
>
> 在这里为了方便理解和说明，我们假设有 10 考生，大家的分数在 0-7 分之间，这10 个考生的成绩我们存放在一个数组 A[10]中，分别为：1，4，5，1，0，3，4，2，6，3；因为成绩的分布是在 0-7 之间，我们使用一个大小为 8 的数组 C[8] 代表8个桶，数组的下标对应的是考生的分数，数组 C 中存储的并不是考生信息，而是对应下标分数的考生个数，我们只需要编译一遍A[10]这样就可以得到C[8]的值如下：
> $$
> C[0]=1~~C[1]=2~~C[2]=1~~C[3]=2~~C[4]=2~~C[5]=1~~C[6]=1~~C[7]=0
> $$
> 从图中我们可以看出：分数为 3 的考生有 2 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在最终排序好的有序数组 R[10]中会保存在下标为：4，5 的位置上
>
> 那接下来就是计算出每个分数的考生在最终的有序数组中的存储位置，这个处理方案很是巧妙，下面是处理思路：对数组 C[8]顺序求和，就变成了下面这个样子，C[i]里存储的就是分数小于等于 i 的考生个数
> $$
> C[0]=1~~C[1]=3~~C[2]=4~~C[3]=6~~C[4]=8~~C[5]=9~~C[6]=10~~C[7]=10
> $$
> 下面就是计数排序中稍微复杂度一点的地方了，我们从后到前依次扫描待排序数组A。比如，当扫描到元素 3 时，我们可以从数组 C 中取出下标为 3 的值 6，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 6 个，也就是说 3 是最终有序数组 R 中的第 6 个元素（也就是数组 R 中下标为 5 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 5 个了，所以相应的 C[3] 要减 1，变成 5。
>
> 以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 5 个元素的位置（也就是下标为 4 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。
>
> 当然了这只是大致的思路，在代码的具体实现中我们还需要根据实际的情况来做出一些调整

**实现**

```java
public class CountingSort {
    /**
     *	计数排序
     * 		1:找出待排序的数组中最大和最小的元素；
     * 		2:统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；
     * 		3:对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
     * 		4:反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放一个元素就将 C(i)减去 1。
     */
    public static void countingSort(int[] array){
        // 1. 求出待排序数组的最大值,最小值,找出取值区间
        int max = array[0];
        int min = array[0];
        for (int i = 0; i < array.length; i++) {
            if(array[i] > max){
                max = array[i];
            }
            if(array[i] < min){
                min = array[i];
            }
        }
        // 2.1 定义一个额外的数组 C
        int bucketSize = max - min + 1;
        int[] bucket = new int[bucketSize];
        // 2.2 统计对应元素的个数,数组的下标不是单纯的值
        for (int i = 0; i < array.length; i++) {
            int bucketIndex = array[i]-min;
            bucket[bucketIndex]++;
        }
        // 3. 对数组 C 内元素进行累加
        for (int i = 1; i < bucket.length; i++) {
            bucket[i] += bucket[i-1];
        }
        // 4.1 创建临时数组 R 存储最终有序的数据列表
        int[] temp = new int[array.length];
        // 4.2 逆序扫描待排序数组 可保证元素的稳定性
        for(int i=array.length-1; i>=0; i--){
            int bucketIndex = array[i] - min;
            temp[bucket[bucketIndex]-1]=array[i];
            bucket[bucketIndex] -= 1;
        }

        // 4.3 将临时数据列表依次放入原始数组
        for(int i=0;i<temp.length;i++){
            array[i] = temp[i];
        }
    }

    public static void main(String[] args) {
        //准备一个 int 数组
        int[] array = new int[]{5, 2, 6, 9, 0, 3, 3, 4};
        //进行排序
        System.out.println(Arrays.toString(array)); countingSort(array);
        //输出排序结果
        System.out.println(Arrays.toString(array));
    }
}
```

**总结**

1. **计数排序的时间复杂度是多少？**

   通过代码的实现过程我们发现计数排序不涉及元素的比较，不涉及桶内元素(数组C)的排序，只有对待排序数组和用于计数数组的遍历操作，因此**计数排序的时间复杂度是O(n+k)**，其中 k 是桶的个数即待排序的数据范围，这是一种线性排序算法。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度 k 取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

2. **计数排序的空间复杂度是多少？**

   在计数排序的过程中需要创建额外的桶空间(数组C)来计数，因此我们可以得知**计数排序的口空间复杂度为：O(n+K)，其中n是数据规模大小，K是计数排序中需要的桶的个数**，其实也就是用来计数的数组 C 的长度，之前我们提到过它取决于待排序数组中数据的范围。

3. **计数排序是稳定的排序算法吗？**

   在计数排序中核心操作中我们是逆序的去扫描待排序数组，这样仍然可以使待排序数组中值相同但是位置靠后的元素在最终的已排序数组中保持着相同的位置关系，因此**计数排序是一个稳定的排序算法**。

**计数排序的适用场景**

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**。

> 比如若想给分数进行计数排序，如果分数精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到桶内。
>
> 再比如，如果要排序的数据中有负数，数据的范围是[-100, 100]，那我们就需要先对每个数据都加 100，转化成非负整数。

### 堆排序 :exclamation:

**概述**

堆的定义：堆是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满：

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813382.PNG" alt="大顶堆" style="zoom:50%;" />

本质上，二叉堆就是一颗特殊的完全二叉树，**父节点的权值不小于儿子的权值（大顶堆）**，即根节点就是最大值

通常用数组来堆进行实现：具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。

> 如果一个结点的位置为k，则它的父结点的位置为[k/2]，而它的两个子结点的位置则分别为2k和2k+1
>
> 这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层，就令k等于[k/2]，向下一层就令k等于2k或2k+1

核心的两个操作就是：**出堆/入堆**

**出堆操作**

* 一个常见的操作是，**把根结点和最后一个结点交换**。但是新的根结点可能不满足 **父节点的权值不小于儿子的权值（大顶堆）**，这个时候，其实只需要将新的根节点**下沉**到正确位置即可，有如下：

  ![删除堆顶元素](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813983.PNG)

* 时间复杂度分析：

  一个包含 n 个节点的完全二叉树，树的高度不会超过 [log2n]+1。堆化的过程是顺着节点所在路径比较交换的，所以**堆化的时间复杂度跟树的高度成正比，也就是O(logn)** 。插入数据和删除堆顶元素的主要逻辑就是堆化， 所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)

**入堆操作**

* 入堆和出堆类似。我们可以直接往树的最后插入一个节点。再进行**上浮**操作，上浮**只需要拿当前节点和父节点进行比对就可以了，** 由于省去了判断左右子节点哪个更小的过程，因此更加简单。

  ![堆的插入实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813472.PNG)

* 时间复杂度分析：往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)，具体见上述出堆的复杂度分析。

**实现：大顶堆/小顶堆**

* **小顶堆**：父节点的值始终不大于子节点的值

```java
import java.util.Arrays;

public class Heap{

    // 堆
    private int[] datas;
    // 堆中已存储的元素个数
    private int size = 0;

    public Heap(int initialCapacity){
        if (initialCapacity < 1)
            throw new IllegalArgumentException();

        this.datas = new int[initialCapacity + 1];
    }

    public Heap(int[] array){
        this.size = array.length;
        this.datas = new int[array.length + 1];

        int i=1;
        for(int val: array){
            this.datas[i++] = val;
        }
    }

    // 向堆中插入元素
    public void push(int val){
        if(size == this.datas.length-1){
            // 扩容操作
            this.datas = Arrays.copyOf(this.datas, size*2 + 1);
        }
        this.datas[++size] = val;
        swim(size);
    }

    // 堆中取出元素
    public int peek(){
        return this.datas[1];
    }

    // 弹出堆中元素
    public int pop(){
        // 弹出堆顶元素
        int res = this.datas[1];
        // 移除完成后要保证堆的完整性，需要寻找第二大的元素放到堆顶
        // 1.将最后一个元素直接放在堆顶，并减少数据
        this.datas[1] = this.datas[size--];
        // 2.堆化让其继续成为一个合格的堆，此时需要自上而下堆化
        sink(1);

        return res;
    }

    // 建堆
    public void buildHeap(){
        // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (this.datas.length)/2; i > 0; i--) {
            sink(i);
        }
    }

    // 上浮操作
    private void swim(int end){
        int i = end;
        while( i/2 >0 && this.datas[i/2] > this.datas[i]){
            // 有父节点，且父节点的值大于该节点，则交换
            swap(i, i/2);
            i /= 2;
        }
    }

    // 下沉操作
    private void sink(int start){
        // 通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，
        // 如果当前结点大，则需要交换位置
        while (2*start <= size){

            int min;
            if(2*start+1 <= size){
                // 有右节点的情况
                if(this.datas[2*start] < this.datas[2*start+1]){
                    // 左节点更小
                    min = 2*start;
                }else{
                    // 右节点更小
                    min = 2*start+1;
                }
            }else{
                // 无右节点的情况
                min = 2*start;
            }

            // 与当前节点比较判断是否需要交换
            if(this.datas[start] < this.datas[min]){
                break;
            }
            // 需要交换
            swap(start, min);
            start = min;
        }
    }

    private void swap(int i, int j){
        int tmp = this.datas[i];
        this.datas[i] = this.datas[j];
        this.datas[j] = tmp;
    }

    public static void main(String[] args) {

        int arr[] = new int[]{2,7,4,1,8,1};
        Heap heap = new Heap(arr);
        heap.buildHeap();
        System.out.println(heap.peek());
        heap.push(5);
        heap.push(10);
        heap.push(3);
        while (heap.size > 0) {
            int num = heap.pop();
            System.out.printf(num + "");
        }
    }
}
```

* **大顶堆**：父节点的值始终不小于子节点的值

```java
import java.util.Arrays;

public class Heap{

    // 堆
    private int[] datas;
    // 堆中已存储的元素个数
    private int size = 0;

    public Heap(int initialCapacity){
        if (initialCapacity < 1)
            throw new IllegalArgumentException();

        this.datas = new int[initialCapacity + 1];
    }

    public Heap(int[] array){
        this.size = array.length;
        this.datas = new int[array.length + 1];

        int i=1;
        for(int val: array){
            this.datas[i++] = val;
        }
    }

    // 向堆中插入元素
    public void push(int val){
        if(size == this.datas.length-1){
            this.datas = Arrays.copyOf(this.datas, size*2 + 1);
        }
        this.datas[++size] = val;
        swim(size);
    }

    // 堆中取出元素
    public int peek(){
        return this.datas[1];
    }

    // 弹出堆中元素
    public int pop(){
        // 弹出堆顶元素
        int res = this.datas[1];
        // 移除完成后要保证堆的完整性，需要寻找第二大的元素放到堆顶
        // 1.将最后一个元素直接放在堆顶，并减少数据
        this.datas[1] = this.datas[size--];
        // 2.堆化让其继续成为一个合格的堆，此时需要自上而下堆化
        sink(1);

        return res;
    }

    // 建堆
    public void buildHeap(){
        // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (this.datas.length)/2; i > 0; i--) {
            sink(i);
        }
    }

    // 上浮操作
    private void swim(int end){
        int i = end;
        while( i/2 >0 && this.datas[i/2] < this.datas[i]){
            // 有父节点，且父节点的值小于该节点，则交换
            swap(i, i/2);
            i /= 2;
        }
    }

    // 下沉操作
    private void sink(int start){

        // 通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，
        // 如果当前结点小，则需要交换位置
        while (2*start <= size){

            int max;
            if(2*start+1 <= size){
                // 有右节点的情况
                if(this.datas[2*start] > this.datas[2*start+1]){
                    // 左节点更大
                    max = 2*start;
                }else{
                    // 右节点更大
                    max = 2*start+1;
                }
            }else{
                // 无右节点的情况
                max = 2*start;
            }

            // 与当前节点比较判断是否需要交换
            if(this.datas[start] > this.datas[max]){
                break;
            }
            // 需要交换
            swap(start, max);
            start = max;
        }
    }

    private void swap(int i, int j){
        int tmp = this.datas[i];
        this.datas[i] = this.datas[j];
        this.datas[j] = tmp;
    }

    public static void main(String[] args) {

        int arr[] = new int[]{2,7,4,1,8,1};
        Heap heap = new Heap(arr);
        heap.buildHeap();
        System.out.println(heap.peek());
        heap.push(5);
        heap.push(10);
        heap.push(3);
        while (heap.size > 0) {
            int num = heap.pop();
            System.out.printf(num + "");
        }
    }
}
```

**堆排序实现**

借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定， **是O(nlogn)** ， 并且它还是原地排序**in-place**算法。我们可以把堆排序的过程大致分解成两个大的步骤，**建堆和排序**。

算法描述如下：

1. 将初始待排序关键字序列 [R1, R2, ...., Rn] 构建成大顶堆，此堆为初始的无序区；
2. 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 [R1, R2, ......, R{n-1}] 和新的有序区 [Rn]，且满足R[1, 2, ..., n-1]<= R[n]；
3. 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 [R1，R2，....R{n-1}] 调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区 [R1，R2...R{n-2}] 和新的有序区 [R{n-1}，Rn]。
4. 不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。

**建堆**

* **方案1：自下而上的堆化操作**，可以假设，起初堆中只包含一个数据，就是下标为1的数据。然后，我们调用前面讲的插入操作，将下标从2到n的数据依次插入到堆中。这样我们就将包含n个数据的数组，组织成了堆，这里面的堆化操作是属于自下而上的堆化操作。

* **方案2：自上而下的堆化操作**，是从后往前处理数组，并且每个数据都是从上往下堆化。下面以图示的形式解释一下第二种实现思路。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了，那第一个非叶子节点如何找呢？别忘记堆是一个完全二叉树，**堆中最后一个元素下标除以2取整就是第一个非叶子节点的下标位置**。

  ![初始堆有序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251813362.PNG)

  代码实现如下：

  ```java
  // 建堆：大顶堆，堆化是自上而下堆化
  public void buildHeap(){
      // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
      for (int i = (this.datas.length)/2; i > 0; i--) {
          sink(i);
      }
  }
  ```

* **建堆操作的时间复杂度**

  首先每个节点堆化的复杂度是：O(logn) ， 而建堆的过程中大约堆化了 n/2+1 个节点， 所以这么看时间复杂度是 O(nlogn)，当然了这么推导出来的也没有错误，只是不够精确，**实际上建堆操作的时间复杂度是O(n)**，由于推导的过程涉及很多数学知识在此先不做过多推导。

**排序**

* 建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的；

* 数组中的第一个元素就是堆顶，也就是最大的元素；

* 把它跟最后一个元素交换，那最大元素就放到了下标为n的位置，将剩下的n-1个元素重新构建成堆；

* 堆化完成之后，我们再取堆顶的元素，放到下标是n-1的位置；

* 一直重复这个过程，直到最后堆中只剩下标为的一个元素，排序工作就完成了，这个过程有点类似上面讲的“删除堆顶元素"的操作。

* **代码**：

  ```java
  while (heap.size > 0) {
      int num = heap.pop();
      System.out.printf(num + ", ");
  }
  ```

总结

1. **堆排序的时间复杂度是多少？**

   堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 `O(n)`，排序过程的时间复杂度是 `O(nlogn)`， 所以， 堆排序整体的时间复杂度是`O(nlogn)` 。

2. **堆排序的空间复杂度是多少？**

   整个堆排序的过程，都只需要极个别临时存储空间，其空间复杂度为**O(1)**，所以堆排序是原地排序 in-place 算法。

3. **堆排序是稳定的排序算法吗？**

   堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

4. **堆排序和快排等相同复杂度的同类排序算法的比较：**

   1. 堆排序**数据访问的方式**没有快速排序友好。对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。 
   2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。
   3. 从实际应用来说我们一般使用快排使用的多。

### 复杂度小结 :exclamation:

接下来我们以一幅图的形式来总结一下各种排序算法。

| 排序算法 | avg      | best     | worst    | space  | 稳定性   |
| -------- | -------- | -------- | -------- | ------ | -------- |
| 冒泡排序 | O(n^2)   | O(n)     | O(n^2)   | O(1)   | 稳定     |
| 插入排序 | O(n^2)   | O(n)     | O(n^2)   | O(1)   | 稳定     |
| 选择排序 | O(n^2)   | O(n^2)   | O(n^2)   | O(1)   | 不稳定   |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n)   | 稳定     |
| 快排排序 | O(nlogn) | O(nlogn) | O(n^2)   | O(1)   | 不稳定   |
| 桶排序   | O(n)     | O(n)     | O(nlogn) | O(n+k) | 可以稳定 |
| 计数排序 | O(n+k)   | O(n+k)   | O(n+k)   | O(n+k) | 可以稳定 |
| 堆排序   | O(nlogn) | O(nlogn) | O(nlogn) | O(1)   | 不稳定   |

1. 桶排序的复杂度和稳定性取决于用何种排序算法为每个桶进行排序，例如采用快排时，为不稳定的排序；其中k为桶的个数。
2. 计数排序中n为数据的规模，k为计数排序中需要的桶的个数，取决于待排序数组中数据的范围；当倒序遍历原数组时，为稳定排序。

## 树结构

### 概述

树是由n(n>0)个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

树具有以下特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

**节点的高度**：节点到叶子节点的最长路径(边数)，所有叶子节点的高度为 0。

**节点的深度**：根节点到这个节点所经历的边的个数，根的深度为 0。

**节点的层数**：节点的深度+1

**树的高度**：根节点的高度

### 二叉树

#### 概述

**基础定义**：二叉树就是度不超过2的树（每个结点最多有两个子结点）

**满二叉树：**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 

**完全二叉树：** 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树（最下层可以存在左满右不满的情况）

> 堆结构就是一种完全二叉树的结构，可以看上述堆排序内容

#### 二叉树遍历

**前序遍历，中序遍历，后续遍历**

前序遍历（根-左-右）：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历（左-根-右）：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后序遍历（左-右-根）：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

遍历二叉树的时间复杂度跟二叉树节点的个数 n 成正比，因此，**二叉树遍历的时间复杂度是O(n)**。

### 二叉查找树

#### 概述 :exclamation:

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**

详细可以分为以下 4点：

1. **若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；**
2. **若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；**
3. **任意节点的左、右子树也分别为二叉查找树；**
4. **没有键值相等的节点。**

**二叉查找树支持动态数据的快速插入，删除，查找操作**

#### 构建二叉树

- **查找节点操作**：

  从根节点开始：

  1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
  2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
  3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

  ![二叉查找树查找](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814035.PNG)

- **插入节点操作**：

  1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
  2. 如果当前树不为空，则从根结点开始：
     1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
     2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
     3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 

  ![二叉树插入](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814526.PNG)

- **删除节点操作**：

  删除操作总结下来有三种情况：

  1. **要删除的节点是叶子节点**即没有子节点，我们只需将父节点中指向该节点的指针置为 null 即可，这是最简单的一种形式。比如删除图中的节点 10
  2. **要删除的节点只有一个子节点**(只有左子节点或者只有右子节点)，我们只需要更新父节点中指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如删除图中的节点 38
  3. **要删除的节点有两个子节点**，这是最复杂的一种情况，我们需要找到这个节点的**右子树中的最小节点**，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如删除图中的节点 25

  ![二叉树删除2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814104.PNG)

**代码实现**：

```java
public class BinaryTree<Key extends Comparable<Key>, Value> {

    // 记录根结点
    private Node root;
    // 记录树中元素的个数
    private int N;
	
    // 节点类的定义
    private class Node{
        // 存储键
        public Key key;
        // 存储值
        public Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
	
    // 默认构造函数
    public BinaryTree() {
        this.N = 0;
    }

    // 获取树中元素的个数
    public int size(){
        return N;
    }

    // 插入节点操作：向树中添加元素key-value
    public void put(Key key, Value val){
        root = put(root, key, val);
    }

    // 向指定的树x中添加key-value,并返回添加元素后新的树
    private Node put(Node x, Key key, Value value){
        // 如果x子树为空
        if(x == null){
            // 树节点个数+1
            N++;  
            x = new Node(key, value, null, null);
            return x;
        }

        // 如果x子树不为空
        // 比较key和x结点的key的大小：Comparable接口中的compareTo函数一般实现逻辑为：大于0说明我比你大，等于0说明相等，小于0说明我比你小
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            // 如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right, key, value);
        }else if(cmp < 0){
            // 如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left, key, value);
        }else{
            // 如果key等于x结点的键，则替换x结点的值为value即可
            x.value = value;
        }
        return x;
    }

    // 查询节点操作：查询树中指定key对应的value
    public Value get(Key key){
        return get(root, key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key){

        //如果x子树为空
        if(x == null){
            return null;
        }

        //如果x子树不为空
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right, key);
        }else if(cmp < 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.left, key);
        }else{
            //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可
            return x.value;
        }
    }

    // 删除节点操作：删除树中key对应的value
    public void delete(Key key){
        root = delete(root, key);
    }

    // 删除指定树x中的key对应的value，并返回删除后的新树
    private Node delete(Node x, Key key){
        // x树为null，没有要删除的节点，直接返回
        if (x==null){
            return null;
        }

        // 如果x子树不为空 先找到要删除的节点
        // 比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            // 如果key大于x结点的键，则继续找x结点的右子树
            x.right = delete(x.right, key);
        }else if(cmp < 0){
            // 如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left, key);
        }else{
            // 如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；
            // 让元素个数-1
            N--;
            // ☆得找到右子树中最小的结点☆
            if(x.right == null){
                // 当结点没有右节点 直接返回它的左节点
                return x.left;
            }

            if(x.left == null){
                // 当结点没有左节点 直接返回它的右节点
                return x.right;
            }

            // 当左右节点都存在时，☆寻找右子树的最左节点☆
            Node minNode = x.right;
            // 删除右子树中最小的结点
            Node n = x.right;  // n为minNode节点的父节点
            while (minNode.left != null){
                minNode = minNode.left;
                if(n.left.left != null){
                    // 使n一直是minNode的父节点
                    n = n.left;
                }
            }
            // minNode的父节点n，断开n的左子节点minNode的连接
            n.left = null;

            // 让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            // 让x结点的父结点指向minNode，在返回的时候会改变指向
            x = minNode;
        }
        return x;
    }
}

// 测试代码
public class BinaryTreeTest {

    public static void main(String[] args) {

        // 创建二叉查找树对象
        BinaryTree<Integer, String> tree = new BinaryTree<>();

        // 测试插入
        tree.put(1,"张三");
        tree.put(2,"李四");
        tree.put(3,"王五");

        // 测试获取
        System.out.println("键2对应的元素是："+tree.get(2));

        // 测试删除
        tree.delete(3);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键3对应的元素:"+tree.get(3));

        tree.delete(1);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键2对应的元素:"+tree.get(2));

        tree.delete(2);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键1对应的元素:"+tree.get(1));
    }
}
```

#### 二叉树遍历

**深度优先遍历dfs**：二叉树的遍历同样可以分为以下三种方式：

1. **前序遍历：**先访问根结点，然后再访问左子树，最后访问右子树 
2. **中序遍历：**先访问左子树，中间访问根节点，最后访问右子树 
3. **后序遍历：**先访问左子树，再访问右子树，最后访问根节点 

在上述代码中添加**前序遍历、中序遍历、后序遍历**的代码

- **前序遍历：**

  1. 把当前结点的key放入到队列中;
  2. 找到当前结点的左子树，如果不为空，递归遍历左子树
  3. 找到当前结点的右子树，如果不为空，递归遍历右子树 

  ```java
  // 前序遍历获取整个树中所有的键
  public Queue<Key> preOrder(){
      Queue<Key> keys = new LinkedList<>();
      preOrder(root, keys);
      return keys;
  }
  
  // 获取指定树x的所有键，并放到keys队列中
  private void preOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先处理自身：把x结点的key放入到keys中
      keys.offer(x.key);
  
      // 再处理左节点：递归遍历x结点的左子树
      if (x.left != null){
          preOrder(x.left, keys);
      }
  
      // 再处理右节点：递归遍历x结点的右子树
      if(x.right != null){
          preOrder(x.right, keys);
      }
  }
  ```

- **中序遍历：**二叉查找树的中序遍历的结果是有序的

  1. 找到当前结点的左子树，如果不为空，递归遍历左子树
  2. 把当前结点的key放入到队列中;
  3. 找到当前结点的右子树，如果不为空，递归遍历右子树

  ```java
  // 中序遍历获取整个树中所有的键
  public Queue<Key> inOrder(){
      Queue<Key> keys = new LinkedList<>();
      inOrder(root, keys);
      return keys;
  }
  
  //获取指定树x的所有键，并放到keys队列中
  private void inOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先递归，把左子树中的键放到keys中
      if (x.left != null){
          inOrder(x.left, keys);
      }
  
      // 把当前结点x的键放到keys中
      keys.offer(x.key);
  
      // 在递归，把右子树中的键放到keys中
      if(x.right != null){
          inOrder(x.right, keys);
      }
  }
  ```

- **后序遍历：**

  1. 找到当前结点的左子树，如果不为空，递归遍历左子树
  2. 找到当前结点的右子树，如果不为空，递归遍历右子树
  3. 把当前结点的key放入到队列中; 

  ```java
  // 后序遍历获取整个树中所有的键
  public Queue<Key> postOrder(){
      Queue<Key> keys = new LinkedList<>();
      postOrder(root, keys);
      return keys;
  }
  
  // 获取指定树x的所有键，并放到keys队列中
  private void postOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先递归，把左子树中的键放到keys中
      if (x.left != null){
          postOrder(x.left, keys);
      }
  
      // 在递归，把右子树中的键放到keys中
      if(x.right != null){
          postOrder(x.right, keys);
      }
  
      // 把当前结点x的键放到keys中
      keys.offer(x.key);
  }
  ```

**广度优先遍历bfs**：层序遍历

1. 创建队列，存储每一层的结点；
2. 使用循环从队列中弹出一个结点：
   1. 获取当前结点的key；
   2. 如果当前结点的左子结点不为空，则把左子结点放入到队列中
   3. 如果当前结点的右子结点不为空，则把右子结点放入到队列中

```java
// 使用层序遍历，获取整个树中所有的键
public Queue<Key> layerErgodic(){

    // 存储树中的键和树中的结点
    Queue<Key> keys = new Queue<>();
    Queue<Node> nodes = new Queue<>();

    // 默认，往队列中放入根结点
    nodes.offer(root);
    while (!nodes.isEmpty()){
        // 当前层的节点数
        int size = nodes.size();
        for(int i=0; i<size; i++){
            // 从队列中弹出一个结点，把key放入到keys中
            Node n = nodes.poll();
            keys.offer(n.key);
            // 判断当前结点还有没有左子结点，如果有，则放入到nodes中
            if(n.left!=null){
                nodes.offer(n.left);
            }
            // 判断当前结点还有没有右子结点，如果有，则放入到nodes中
            if(n.right!=null){
                nodes.offer(n.right);
            }
        }
    }
    return keys;
}
```

#### 其他操作

- 查找整个树中最小的键

  ```java
  // 查找整个树中最小的键
  public Key min(){
      return min(root).key;
  }
  
  // 在指定树x中找出最小键所在的结点
  public Node min(Node x){
      // 需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点
      if(x.left != null){
          return min(x.left);
      }else{
          return x;
      }
  }
  ```

- 在整个树中找到最大的键

  ```java
  // 在整个树中找到最大的键
  public Key max(){
      return max(root).key;
  }
  
  // 在指定的树x中，找到最大的键所在的结点
  public Node max(Node x){
      // 判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点
      if(x.right != null){
          return max(x.right);
      }else{
          return x;
      }
  }
  ```

- 求二叉树的最大深度

  1. 如果根结点为空，则最大深度为0；
  2. 计算左子树的最大深度；
  3. 计算右子树的最大深度；
  4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 

  ```java
  // 获取整个树的最大深度
  public int maxDepth(){
      return maxDepth(root);
  }
  
  // 获取指定树x的最大深度
  private int maxDepth(Node x){
      if (x==null){
          return 0;
      }
  
      // x的最大深度
      int max = 0;
      // 左子树的最大深度
      int maxL=0;
      // 右子树的最大深度
      int maxR=0;
  
      //计算x结点左子树的最大深度
      if(x.left != null){
          maxL = maxDepth(x.left);
      }
  
      //计算x结点右子树的最大深度
      if(x.right != null){
          maxR = maxDepth(x.right);
      }
  
      // 比较左子树最大深度和右子树最大深度，取较大值+1即可
      max = maxL > maxR ? maxL+1:maxR+1;
      return max;
  }
  ```

- **重复值处理**：对于有重复数据的二叉查找树，有两种方案：

  1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
  2. 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理，当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

  ![二叉树中有相同的值](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814076.PNG)

#### 复杂度分析 :exclamation:

分析一下二叉查找树的查找，插入，删除的相关操作的时间复杂度

由于二叉查找树的形态各异，时间复杂度也不尽相同，根据下图的几棵树来看一下插入，查找，删除的时间复杂度

![不同形态的二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814493.PNG)

对于图中第一种情况属于最坏的情况，**二叉查找树已经退化成了链表**，左右子树极度不平衡，此时查找的**时间复杂度肯定是 O(n)**。

对于图中第二种或者第三种情况是属于一个比较理想的情况，我们代码的实现逻辑以及图中所示表明**插入，查找，删除的时间复杂度其实和树的高度成正比**，那也就是说时间复杂度为**O(height)**

**求一颗完全二叉树的高度**：

对于一棵满二叉树而言：树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从上图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 k 层包含的节点个数就是 2^(k-1)。

但是对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(k-1) 个之间（我们假设最大层数是 k）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：
$$
1+2+4+8+...+2^{(k-2)} +1 =< n <= 1+2+4+8+...+2^{(k-2)} +2^{(k-1)}
$$
这是一个等比数列，根据等比数列求和公式
$$
S= \frac{a_1-a_nq}{1-q},其中q是公比,a_n为数列的第n项，a_1为首项
$$
所以：我们利用求和公式对上述式子进行计算后得知，k 的取值范围为：
$$
log_2(n+1) \leq k \leq log_2(n) + 1
$$
推导得，也就是说完全二叉树的高度小于等于：**[log2n]+1**

> 还需要看书斟酌一番

通过我们的分析我们发现一棵极度不平衡的二叉查找树，它的查找性能和单链表一样。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这种特殊的二叉查找树也可以叫做**平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)**。

### 平衡二叉树(AVL)

#### 概述 :exclamation:

**平衡二叉查找树**：简称平衡二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的**高度平衡的二叉树**，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树，即其并且高度之差的绝对值不超过 1**

**对于给定结点数为n的AVL树，最大高度为O(log2n)**，也就说，从 n 个数中，查找一个特定值时，最多需要 log2n 次。因此，AVL 是一种特别适合进行查找操作的树。

#### 失衡及调整

在平衡二叉树中，当我们插入新的元素时，为了保证二叉搜索树的特性，很容易导致某些结点**失衡**，即该结点的平衡因子大于 1。

而在二叉树中，任意结点孩子最多只有左右两个，而且导致失去平衡的必要条件就是当前结点的两颗子树的高度差等于 2。因此，致使一个结点失衡的插入操作有以下 4 种

1. 在结点的左子树的左子树插入元素，LL 插入；
2. 在结点的左子树的右子树插入元素，LR 插入；
3. 在结点的右子树的左子树插入元素，RL 插入；
4. 在结点的右子树的右子树插入元素，RR 插入。

![avl树失衡的情况](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814093.PNG)

> LL插入(情况1)中结点 1 的插入导致结点 8 失衡，而插入的位置是在其左子树的左子树上，同样 LL(情况2）中，结点 3 插入同样导致结点 8 失衡，**这里需要注意子树是从受影响的结点算起，虽然 3 插在了右边，但他依旧是在 8（失衡结点）左子树的左子树上，因此属于 LL 插入。**
>
> LR(情况1)中结点 5 插入导致结点 8 失衡，插入位置是在其左子树的右子树上，同样 LR(情况2)结点 7 的插入也是同理，因此这二者都属于 LR 插入。

**面对以上4种失衡的情况，在AVL树中将采用LL(左左)，LR(左右)，RR(右右)和RL(右左)四种旋转方式进行调整。**

> 为了对这四种情况进行说明，我们先来定义 AVL 树的结构：
>
> AVL 树首先是二叉查找树，因此它的结点也必须是可比较。同时为了方便，加入一个表示当前结点高度的 height 字段，同时定义了返回节点高度和树的高度的方法，也定了一个返回两个高度中最大高度的方法。
>
> ```java
> public class AVLTree <T extends Comparable<T>>{
> 
>        // AVL树根节点，root节点
>        private AVLNode tree;
> 
>        // 获取某一节点的高度
>        public int height(AVLNode node){
>            // 特殊说明：这里的高度对于叶子节点而言，其高度其实为1
>            return node==null? 0: node.height;
>        }
> 
>        // 获取 avl 树的高度
>        public int height(){
>            return tree.height;
>        }
> 
>        // 返回两个高度中的最大值
>        private int getMax(int height1, int height2){
>            return height1>height2 ? height1 : height2;
>        }
> 
>        // 方法我们使用前中后序遍历的方式打印树
>        @Override
>        public String toString() {
>            System.out.println("前序遍历的结果:");
>            preOrder(tree);
>            System.out.println();
>            System.out.println("中序遍历的结果:");
>            inOrder(tree);
>            System.out.println();
>            System.out.println("后续遍历的结果:");
>            postOrder(tree);
>            System.out.println();
> 
>            return null;
>        }
> 
>        // 前序遍历
>        public void preOrder(AVLNode node){
>            if(node == null){
>                return;
>            }
>            System.out.print(node.data + "->");
>            preOrder(node.left);
>            preOrder(node.right);
>        }
> 
>        // 中序遍历
>        public void inOrder(AVLNode node){
>            if(node == null){
>                return;
>            }
>            preOrder(node.left);
>            System.out.print(node.data + "->");
>            preOrder(node.right);
>        }
> 
>        // 后续遍历
>        public void postOrder(AVLNode node){
>            if(node == null){
>                return;
>            }
>            preOrder(node.left);
>            preOrder(node.right);
>            System.out.print(node.data + "->");
>        }
> 
>        // 内部静态类，定义了avl树节点
>        private static class AVLNode<T extends Comparable<T>>{
>            // 节点中存储的数据
>            private T data;
>            // 左子树节点
>            private AVLNode<T> left;
>            // 右子树节点
>            private AVLNode<T> right;
>            // 节点的高度
>            private int height;
> 
>            public AVLNode(T data, AVLNode<T> left, AVLNode<T> right, int height) {
>                this.data = data;
>                this.left = left;
>                this.right = right;
>                this.height = height;
>            }
> 
>            public AVLNode(T data, AVLNode<T> left, AVLNode<T> right) {
>                this.data = data;
>                this.left = left;
>                this.right = right;
>            }
>        }
> }
> ```

**LL插入：右旋转调整**

- 图解：

  ![右旋调整](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814162.PNG)

- 代码实现

  ```java
  // LL插入：右旋转调整
  public AVLNode leftRotate(AVLNode node){
      // 定义临时变量保存 失衡节点的左子树 该节点也是左旋后的根节点
      AVLNode node_left = node.left;
      // 将失衡节点左子树的右子树作为失衡节点的左子树
      node.left = node_left.right;
      // 将失衡节点作为旋转后根节点的右子树
      node_left.right = node;
      // 重新计算失衡节点和旋转后根节点的高度
      node.height = getMax(height(node.left), height(node.right)) + 1;
      node_left.height = getMax(height(node_left.left), height(node_left.right)) + 1;
      return node_left;
  }
  ```

**RR插入：左旋转调整**

- 图解

  ![左旋调整](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814791.PNG)

- 代码实现

  ```java
  // RR插入：左旋转调整
  public AVLNode rightRotate(AVLNode node){
      // 定义临时变量保存右旋后的根节点 也就是失衡节点的右子树
      AVLNode node_right = node.right;
      // 将新的根节点的左子树当作失衡节点的右子树
      node.right = node_right.left;
      // 将失衡节点当作新的根节点的左子树
      node_right.left = node;
      // 重新计算失衡节点和新的根节点的高度
      node.height = getMax(height(node.left), height(node.right)) + 1;
      node_right.height = getMax(height(node_right.left), height(node_right.right)) + 1;
      return node_right;
  }
  ```

**LR插入：左右旋调整**

- 图解

  ![左右旋转](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814648.PNG)

- 代码实现

  ```java
  // LR插入：左右旋调整
  public AVLNode leftRightRotate(AVLNode node){
      node.left = rightRotate(node.left);
      return leftRotate(node);
  }
  ```

**RL插入：右左旋转**

- 图解

  ![右左旋转](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814125.PNG)

- 代码实现

  ```java
  // RL插入：右左旋转
  public AVLNode rightLeftRotate(AVLNode node){
      node.right = leftRotate(node.right);
      return rightRotate(node);
  }
  ```

#### 插入节点调整

```java
// 插入操作
public void insert(T value){
    this.tree = insert(tree, value);
}

private AVLNode insert(AVLNode<T> node, T data){
    // 将data添加到node节点的子节
    if(node == null){
        node = new AVLNode<T>(data, null, null);
    }else{
        // 找到要插入的位置
        int compare = data.compareTo(node.data);
        if(compare > 0){
            // 要添加的值大于当前节点的值,将 data 存储到当前节点的右子树上
            // 递归的插入
            node.right = insert(node.right, data);
            //	如插入后 avl 树变得不平衡,则应该重新调节该树的结构---旋转
            if(height(node.right) - height(node.left) >= 2){
                //	判断是 RR 还是 RL
                if(data.compareTo(node.right.data) > 0){
                    // RR
                    node = rightRotate(node);
                }else{
                    node = rightLeftRotate(node);
                }
            }

        }else if(compare < 0){
            // 要添加的值小于当前节点的值,将 data 存储到当前节点的左子树上
            // 递归的插入
            node.left = insert(node.left, data);
            //	如插入后 avl 树变得不平衡,则应该重新调节该树的结构---旋转
            if(height(node.left) - height(node.right) >= 2){
                if(data.compareTo(node.left.data) < 0){
                    // LL
                    node = leftRotate(node);
                }else{
                    node = leftRightRotate(node);
                }
            }
        }else{
            // 要添加的值和该节点的值相同，不做处理
        }
    }

    // 计算节点 node 的高度
    // +1解释：hight为左右子树的双亲节点，故此处需要+1
    node.height = getMax(height(node.left), height(node.right)) + 1;
    return node;
}
```

### 2-3 查找树

#### 概述

将一棵标准的二叉查找树中的结点称为**2-结点(含有一个键和两条链)**，而现在引入**3-结点，它含有两个键和三条链**。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。 

一棵2-3查找树要么为空，要么满足满足下面两个要求： 

- **2-结点**： 

  含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 

- **3-结点**：

  含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 

![2-3树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814577.PNG)

#### 性质

2-3树在插入/删除的时候，需要做一些局部的变换来保持2-3树的平衡，后续对其进行图解

一棵完全平衡的2-3树具有以下性质：

1. **任意空链接到根结点的路径长度都是相等的**。
2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，**分解根结点时，树高+1**。
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是**自底向上生长**。 

#### 查找 & 插入

**查找**

- 文字说明

  将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。 

- 图解

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814346.PNG" alt="2-3树查找" style="zoom: 67%;" />

**插入**

- 文字说明

  往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点麻烦。 

- **图解：向2-结点中插入新键**

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814302.PNG" alt="2-3树插入" style="zoom:67%;" />

- **图解：向一棵只含有一个3-结点的树中插入新键** 

  假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素，**暂时使其变成一个4-结点**，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814654.PNG" alt="2-3树插入2" style="zoom:67%;" />

- **图解：向一个父结点为2-结点的3-结点中插入新键** 

  和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814182.PNG" alt="2-3树插入3" style="zoom:67%;" />

- **图解：向一个父结点为3-结点的3-结点中插入新键** 

  当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点，插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其变为3-结点，不需要继续进行拆分。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814367.PNG" alt="2-3树插入4" style="zoom:67%;" />

- **图解：分解根结点** 

  当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814155.PNG" alt="分解根节点" style="zoom:67%;" />

### 红黑树 :exclamation:

#### 概述

> 上述分析的 2-3 树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为 logN，相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以这里**介绍一种2-3树思想的简单实现：红黑树**。 

红黑树主要是对2-3树进行编码，红黑树背后的基本思想是**用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树**。我们将树中的链接分为两种类型： 

**红链接：将两个2-结点连接起来构成一个3-结点；** 

**黑链接：则是2-3树中的普通链接，即2-结点。** 

确切的说，我们将3-结点表示为由一条**左斜**的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们**无需修改就可以直接使用标准的二叉查找树的get方法**。 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814246.PNG" alt="红黑树" style="zoom:67%;" />

**定义**

红黑树是含有红黑链接并满足下列条件的二叉查找树： 

1. **红链接均为左链接**；
2. 没有任何一个结点**同时和两条红链接相连**；
3. 该树是**完美黑色平衡的**，即任意空链接到根结点的路径上的黑链接数量相同； 

下面是红黑树与2-3树的对应关系： 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814624.PNG" alt="红黑树与2-3关系" style="zoom:67%;" />

#### 结点实现

因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的**Node结点中添加一个布尔类型的变量color来表示链接的颜色**。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为 false

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814518.PNG" alt="红黑树2" style="zoom:67%;" />

**API设计：** 

| 类名     | Node<Key, Value>                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | `Node(Key key, Value value, Node left, Node right, boolean color)`：创建Node对象 |
| 成员变量 | 1.`public Node left`:记录左子结点 <br />2.`public Node right`:记录右子结点 <br />3.`public Key key`:存储键 <br />4.`public Value value`:存储值 <br />5.`public boolean color`:**由其父结点指向它的链接的颜色** |

**代码：** 

```java
private class Node{
    // 存储键
    public Key key;
    // 存储值
    public Value value;
    // 记录左子结点
    public Node left;
    // 记录右子结点
    public Node right;
    // 由其父结点指向它的链接的颜色
    public boolean color;

    public Node(Key key, Value value, Node left, Node right, boolean color) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        this.color = color;
    }
}

```

#### 平衡化

在对红黑树进行一些增删改查的操作后，很有可能会出现：

1. 红色的右链接；
2. 两条连续红色的链接；

而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。

**左旋**

- **情况**：当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。 

- **前提：**当前结点为h，它的右子结点为x；

- **左旋过程：** 

  1. 让x的左子结点变为h的右子结点：`h.right=x.left;`
  2. 让h成为x的左子结点：`x.left=h;`
  3. 让x的color属性变为h的color属性值：`x.color=h.color;`
  4. 让h的color属性变为RED：`h.color=true;`

- **图解**：

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814543.PNG" alt="左旋" style="zoom:67%;" />

**右旋**

- **情况**：当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋 

- **前提：**当前结点为h，它的左子结点为x；

- **右旋过程：**

  1. 让x的右子结点成为h的左子结点：`h.left = x.right;`
  2. 让h成为x的右子结点：`x.right=h;`
  3. 让x的color变为h的color属性值：`x.color = h.color;`
  4. 让h的color为RED；

  > 这时候也是不满足的，还需要进行调整，即需要进行颜色变换，后续有说明

- **图解**：

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814965.PNG" alt="右旋" style="zoom:67%;" />

#### 插入操作

**向单个2-结点中插入新键** 

- 一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。

  - 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。 

    <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814515.PNG" alt="红黑树插入1" style="zoom:67%;" />

  - 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红色链接。 

    <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814709.PNG" alt="红黑树插入2" style="zoom:67%;" />

**向底部的2-结点插入新键**

- 用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814358.PNG" alt="红黑树插入3" style="zoom:67%;" />

**颜色反转** 

- 当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814242.PNG" alt="红黑树插入4" style="zoom:67%;" />

**向一棵双键树(即一个3-结点)中插入新键** 

- 这种情况有可以分为三种子情况： 

  1. 新键大于原树中的两个键

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814122.PNG" alt="红黑树插入5" style="zoom:67%;" />

  2. 新键小于原树中的两个键 

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814908.PNG" alt="红黑树插入6" style="zoom:67%;" />

  3. 新键介于原数中两个键之间

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814694.PNG" alt="红黑树插入7" style="zoom:67%;" />

**根结点的颜色总是黑色**

- 在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。 

**向树底部的3-结点插入新键**

- 假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点为止。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251814775.PNG" alt="红黑树插入8" style="zoom:67%;" />

#### 代码实现

| 类名     | `RedBlackTree<Key extends Comparable<Key>, Value>`           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | `RedBlackTree()`:创建RedBlackTree对象                        |
| 成员方法 | 1.`private boolean isRed(Node x)`:判断当前结点的父指向链接是否为红色 <br />2.`private Node rotateLeft(Node h)`:**左旋调整** <br />3.`private Node rotateRight(Node h)`:**右旋调整** <br />4.`private void flipColors(Node h)`：**颜色反转**,相当于完成拆分4-结点 <br />5.`public void put(Key key, Value val)`:在整个树上完成插入操作 <br />6.`private Node put(Node h, Key key, Value val)`:在指定树中，完成插入操作,并返回添加元素后新的树 <br />7.`public Value get(Key key)`:根据key，从树中找出对应的值 <br />8.`private Value get(Node x, Key key)`:从指定的树x中，找出key对应的值 <br />9.`public int size()`:获取树中元素的个数 |
| 成员变量 | 1.`private Node root` : 记录根结点 <br />2.`private int N`:记录树中元素的个数 <br />3.`private static final boolean RED`：红色链接标识 <br />4.`private static final boolean BLACK`:黑色链接标识 |

```java
public class RedBlackTree <Key extends Comparable<Key>, Value> {

    // 根节点
    private Node root;
    // 记录树中元素的个数
    private int N;
    // 红色链接
    private static final boolean RED=true;
    // 黑色链接
    private static final boolean BLACK=false;


    // 结点类
    private class Node{
        // 存储键
        public Key key;
        // 存储值
        public Value value;
        // 记录左子结点
        public Node left;
        // 记录右子结点
        public Node right;
        // 由其父结点指向它的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

    // 获取树中元素的个数
    public int size(){
        return this.N;
    }

    /**
     * 判断当前节点的父指向链接是否为红色
     *
     * @param x
     * @return
     */
    private boolean isRed(Node x){
        if(x == null){
            return false;
        }
        return x.color==RED;
    }

    /**
     * 左旋转
     *
     * @param h
     * @return
     */
    private Node rotateLeft(Node h){
        // 找到h结点的右子结点x
        Node x = h.right;
        // 找到x结点的左子结点，让x结点的左子结点成为h结点的右子结点
        h.right = x.left;
        // 让h结点称为x结点的左子结点
        x.left = h;
        // 让x结点的color属性变为h结点的color属性
        x.color = h.color;
        // 让h结点的color属性变为RED
        h.color = RED;

        return x;
    }

    /**
     * 右旋
     *
     * @param h
     * @return
     */
    private Node rotateRight(Node h){
        // 找到h结点的左子结点 x
        Node x = h.left;
        // 让x结点的右子结点成为h结点的左子结点
        h.left = x.right;
        // 让h结点成为x结点的右子结点
        x.right = h;
        // 让x结点的color属性变为h结点的color属性
        x.color = h.color;
        // 让h结点的color属性为RED
        h.color = RED;

        return x;
    }

    /**
     * 颜色反转,相当于完成拆分4-节点
     *
     * @param h
     */
    private void flipColors(Node h){
        // 当前结点变为红色
        h.color = RED;
        // 左子结点和右子结点变为黑色
        h.left.color = BLACK;
        h.right.color = BLACK;
    }

    /**
     * 在整个树上完成插入操作
     *
     * @param key
     * @param val
     */
    public void put(Key key, Value val){
        root = put(root, key, val);
        // 根结点的颜色总是黑色
        root.color = BLACK;
    }

    /**
     * 在指定树中，完成插入操作,并返回添加元素后新的树
     *
     * @param h
     * @param key
     * @param val
     */
    private Node put(Node h, Key key, Value val){
        // 判断h是否为空，如果为空则直接返回一个红色的结点就可以了
        if(h == null){
            //数量+1
            N++;
            return new Node(key, val, null, null, RED);
        }

        // 比较h结点的键和key的大小
        int cmp = key.compareTo(h.key);

        if (cmp < 0){
            // 继续往左
            h.left = put(h.left, key, val);
        }else if(cmp > 0){
            // 继续往右
            h.right = put(h.right, key, val);
        }else{
            // 发生值的替换
            h.value = val;
        }

        // 进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }
        // 进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        // 颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        return h;
    }

    // 根据key，从树中找出对应的值
    public Value get(Key key){
        return get(root, key).value;
    }

    // 从指定的树x中，查找key对应的值
    private Node get(Node n, Key key){
        if (n==null){
            return null;
        }

        // 比较x结点的键和key的大小
        int cmp = key.compareTo(n.key);
        if(cmp > 0){
            return get(n.right, key);
        }else if(cmp < 0){
            return get(n.left, key);
        }else {
            return n;
        }
    }

    public static void main(String[] args) {

        RedBlackTree<String, String> tree = new RedBlackTree<>();

        // 往树中插入元素
        tree.put("1","张三");
        tree.put("2","李四");
        tree.put("3","王五");

        // 从树中获取元素
        String r1 = tree.get("1");
        System.out.println(r1);


        String r2 = tree.get("2");
        System.out.println(r2);

        String r3 = tree.get("3");
        System.out.println(r3);
    }
}

```

### 红黑树 vs AVL树 :exclamation::exclamation:

1. **红黑树并不追求“完全的平衡”**，它只要求达到部分的平衡，降低了对旋转的要求，从而提高了性能，但也是由于其平衡要求不如 AVL 树严格，因此理论上查找要慢些，实际也如此，不过差距并不大
2. 红黑树能够以 O(log2n) 的时间复杂度进行搜索/插入/删除操作，由于它的设计，**任何不平衡都会在三次旋转之内解决**。
3. 还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，**但红黑树能够给我们一个比较“便宜”的解决方案**。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高

**总结**

1. **查找比较**

   显然，AVL树 要比红黑树更平衡，因此 AVL树 的查找效率更高

   > AVL 树满足：
   >
   > 1. 可以是空树。
   > 2. 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1**

2. **插入比较**

   如果插入一个节点引起了树的不平衡，AVL 和 红黑树 都是**最多只需要2次旋转操作**，即两者都是O(1)

3. **删除比较**

   在删除节点引起树的不平衡时，最坏情况下，AVL 需要维护从被删节点到根节点这条路径上所有节点的平衡性，**因此需要旋转的量级 O(logN)，而红黑树最多只需3次旋转，只需要O(1)的复杂度**。

AVL 的结构相较 红黑树 来说更为平衡，**在插入和删除节点更容易引起树的不平衡**，因此在大量数据需要插入或者删除时，**AVL 需要调整的频率会更高**。因此，红黑树在需要大量插入和删除节点的场景下，效率更高。自然，由于 AVL 高度平衡，因此 AVL 的查找效率更高。

红黑树的查询性能略微逊色于 AVL，因为他比 AVL 会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的 AVL 最多多一次比较。但是，红黑树在插入和删除上完爆 AVL，AVL 树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于 AVL 为了维持平衡的开销要小得多。

> 参考：[数据结构-AVL树和红黑树的对比](https://blog.csdn.net/tiankong_/article/details/77150798?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)

### B 树

#### 概述

> 在前面提到的 2-3 树中，一个结点最多能有两个 key，它的实现红黑树中使用对链接染色的方式去表达这两个 key。在B树这种数据结构中，**一个结点允许多于两个 key 的存在**。 

B树是一种树状数据结构，它能够存储数据，对其进行排序并允许以 O(logn) 的时间复杂度进行查找、顺序读取、插入和删除等操作。

#### 特性

B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点： 

- 每个结点最多有**M-1个key**，并且以升序排列；
- 每个结点最多能有**M个子结点**；
- 根结点至少有两个子结点； 

![B树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251815920.PNG)

在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。

#### B树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。 

![B树存储数据](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251815165.PNG)

### B+树

#### 概述

B+树是对B树的一种变形树，它与B树的差异在于：

1. n叉B+Tree最多含有n个key，而BTree则最多含有n-1个key；
2. **非叶结点仅具有索引作用**，也就是说，非叶子结点只存储key，不存储value；
3. **树的所有叶结点构成一个有序链表**，可以按照key排序的次序遍历全部数据。 

#### B+树和B树的对比 

**B+ 树的优点在于：**

1. 由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此**在内存相同的情况下，能够存放更多的key**。 
2. B+树的叶子结点都是相连的，因此**对整棵树的遍历只需要依次线性遍历叶子结点即可**。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

**B树的优点在于：**

- 由于B树的每一个节点都包含key和value，因此我们根据key查找value时，**只需要找到key所在的位置，就能找到value**；
- 但B+树只有叶子结点存储数据，索引每一次查找，都必须一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。 

#### B+树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。 

![B+树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251815864.PNG)

