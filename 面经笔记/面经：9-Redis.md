# 面经：9-Redis

> 个人整理 :muscle: 个人专用 :muscle: 暑期实习 :muscle: 秋招 :muscle: 后端开发 :muscle: 八股文 :no_mouth:

### 关系型VS非关系型 数据库 :exclamation:

**概述**：

- 关系型数据库：通过二维表这种数据结构进行数据的存储；
- 非关系型数据库：NoSQL，Not Only SQL，不仅仅是SQL，主要通过 Key，Value 键值对进行数据保存，无需固定的表结构。

**查询速度**：非关系型数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，执行SQL进行查询时还需要进行相应的优化解析，因此非关系型数据库的查询速度较快；

**拓展性**：非关系型数据库之间的数据没有耦合性，非常容易进行水平扩展；而关系型数据库存在多表查询机制，导致其扩展比较麻烦，但也正因如此其可以实现在一个表以及多个表之间做非常复杂的数据查询；

**成本方面**：非关系型数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜，但由于其不提供对SQL的支持，较关系型数据库而言将产生一定的学习成本；

**事物**：关系型数据库支持事物，能通过事物保证ACID；而Redis仅支持事务中的一致性C和隔离性D，无法保证原子性A和隔离性I；

**总结**：

* 关系型数据库与非关系型数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用非关系型的时候使用非关系型数据库，让非关系型数据库对关系型数据库的不足进行弥补；
* 一般会将数据存储在关系型数据库中，在非关系型数据库中备份存储关系型数据库的热点数据。

### 使用 Redis 理由 :exclamation::exclamation::exclamation:

主要从“**高性能**”和“**高并发**”这两点来看待这个问题。

**高性能：**

1. 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。
2. 将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。
3. 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812833.png" alt="redis缓存" style="zoom: 80%;" />

**高并发：**

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812206.png" alt="redis高并发" style="zoom:80%;" />

### Redis 概述&优缺点:exclamation::exclamation:

**概述**：

Redis (Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）**高性能非关系型（NoSQL）的键值对数据库**。

Redis 可以存储键和五种不同类型的值之间的映射

* 键的类型只能为字符串；
* 值支持五种数据类型：字符串、列表、集合、散列表、有序集合。

与传统数据库不同的是 **Redis 的数据是存在内存中的，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向**，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。另外，**Redis 也经常用来做分布式锁**。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。

**优缺点**：

**优点**

- **读写性能优异**， Redis能读的速度是110000次/s，写的速度是81000次/s。
- 支持数据持久化，支持**AOF和RDB**两种持久化方式。
- 支持事务，**Redis的所有操作都是原子性的**，同时Redis还支持对几个操作合并后的原子性执行。
- 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
- 支持**主从复制**，主机会自动将数据同步到从机，可以进行读写分离。

**缺点**

- **数据库容量受到物理内存的限制**，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
- **数据一致性问题**，数据库和缓存双写一致性问题
- 主机宕机，宕机前有部分数据未能及时同步导致数据丢失问题
- 缓存雪崩、缓存击穿、缓存穿透等缓存异常问题

> **提高多核CPU的利用率**？
>
> Redis 的读取和处理性能非常强大，一般服务器的 CPU 都不会是性能瓶颈。**Redis的性能瓶颈主要集中在内存和网络方面**。所以，如果使用的Redis命令多为 `O(N)`、`O(log(N))` 时间复杂度，那么基本上不会出现 CPU瓶颈的情况。
>
> 但是如果你确实需要充分使用多核 CPU 的能力，那么需要**在单台服务器上运行多个Redis实例(主从部署/集群化部署)，并将每个Redis实例和CPU内核进行绑定**

### 缓存类型

缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用到

缓存的类型分为：**本地缓存**、**分布式缓存**和**多级缓存**

**本地缓存**：

* 以 Java 为例，可以使用自带的 map 来实现**本地缓存**，最主要的特点是轻量以及快速，生命周期随着 JVM 的销毁而结束；
* **但在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性**。
* 本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展

**分布式缓存**：

* 使用 redis 或 memcached 之类的称为分布式缓存；
* 在多实例的情况下，**各实例共用一份缓存数据**，缓存具有一致性。
* 缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。

**多级缓存**：

* 实际业务中一般采用**多级缓存**，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。
* 在目前的一线大厂中，这也是最常用的缓存方案，单靠单一的缓存方案往往难以撑住很多高并发的场景

### Redis 为什么那么快 :exclamation:

1. **完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。**数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；

2. 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；

3. **采用单线程，避免了不必要的上下文切换和竞争条件**，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. **使用多路 I/O 复用模型，非阻塞 IO**；

5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM（Virtual Memory） 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

   > 关于Redis自己构建的VM机制：https://blog.csdn.net/weixin_43618070/article/details/83894031

### Redis 数据类型 & 底层结构 & 应用场景 :exclamation:

> 关于底层数据结构：
>
> https://www.cnblogs.com/jaycekon/p/6227442.html
>
> https://www.cnblogs.com/jaycekon/p/6277653.html

Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求

**String**

* **String** 类型是 **Redis** 中最常使用的类型，内部的实现是通过 **SDS**（Simple Dynamic String ，简单动态字符串）来存储的。
* 这是最简单的类型，通过 set 和 get，做简单的 KV 缓存
* **应用场景**：
  * 计数器：可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
  * **缓存**：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率
  * **共享用户 Session**：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
  * **查找表**：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

**List**

* 列表类型，可以从两端压入或弹出数据，对单个或多个元素进行修剪，只保留一个范围内的元素
* **应用场景**：
  * 通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西
  * **消息队列(发布/订阅功能)**：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。

**Hash**

* 类似 **Map** 的一种结构，添加、获取、移除单个键值对；获所有键值对；检查某个键值对是否存在；
* **应用场景**：可以存储结构化的数据，比如一个对象

**Set**

* **Set** 是无序集合，会自动去重的那种；可以添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里随机获取元素
* **应用场景**：**交集、并集、差集**的操作，比如交集，可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁

**ZSET / Sorted Set**

* 有序集合：可以利用分数进行成员间的排序，而且是插入时就排序好，因而当需要一个有序且不重复的集合列表时，就可以选择**Sorted set**数据结构作为选择方案。
* **应用场景**：
  * 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。
  * 用**Sorted Sets**来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。

**其他数据结构**：

* **Bitmap** :位图是支持按 bit 位来存储信息，可以用来实现 **布隆过滤器（BloomFilter）**；
* **HyperLogLog**：供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；
* **Geospatial**：可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。

### Redis 实现异步队列 / 消息队列

可以使用 List 结构作为队列，通过 rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，可以适当的 sleep 后再重试。

> rpush：将一个值或者多个值，插入到列表尾部 （右）
>
> lpop：移除list的第一个元素（左）

当然也可以不用sleep，而是通过 **blpop** 获取消息，当没有消息时，它会**阻塞**住直到消息到来。

当要实现生产一次消费多次的情况：使用 Redis 发布订阅(pub/sub)的**消息通信模式**，具体见下一条内容

### 发布订阅

Redis 发布订阅(pub/sub)是一种**消息通信模式**：发送者(pub)发送消息，订阅者(sub)接收消息。例如：微信、微博、关注系统。

**原理**：

Redis 通过 `PUBLISH` 、`SUBSCRIBE` 和 `PSUBSCRIBE` 等命令实现发布和订阅功能。

通过 `SUBSCRIBE` 命令订阅某频道后，redis-server 里维护了一个**字典**，字典的键就是一个个 频道，而字典的值则是一个**链表**，链表中保存了所有订阅这个 channel 的客户端，`SUBSCRIBE` 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。  

通过 `PUBLISH` 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，**遍历这个链表**，将消息发布给所有订阅者。  

Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作**实时消息系统**，比如普通的即时聊天，群聊等功能。

**使用场景：**

1. 实时消息系统
2. 实时聊天：频道当做聊天室，将信息回显给所有人即可
3. 订阅，关注系统都是可以的

但是稍微复杂的场景我们就会使用 **消息中间件 MQ**。

### Redis 实现分布式锁  :exclamation:

首先考虑到：在分布式场景下，**无法使用单机环境下的锁来对多个节点上的进程进行同步**。

可以使用 Redis **自带的 SETNX 命令实现分布式锁**，除此之外，还可以使用**官方提供的 RedLock 分布式锁**实现。

> 使用 SETNX 命令实现分布式锁：
>
> * 当且仅当 key 不存在，将 key 的值设为 value；
> * 若给定的 key 已经存在，则 SETNX 不做任何动作，即无法获得锁
> * 返回值：设置成功，返回 1 ；设置失败，返回 0 

**使用SETNX完成同步锁的流程及事项如下：**

* 使用 SETNX 命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功；

* 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入**死锁**状态，需要为该key设置一个“合理”的过期时间；
* 释放锁，使用 DEL 命令将锁数据删除。

释放锁，使用DEL命令将锁数据删除。

进一步：先拿**setnx**来争抢锁，抢到之后，再用**expire**给锁加一个过期时间防止锁忘记了释放。

> setnx：不存在则设置，set if not exist
>
> expire：设置过期时间
>
> 问：当setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
>
> 答：通过命令setex：设置过期时间，set with expire，在set创建是就指定了过期时间

### RedLock 实现分布式锁

Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 `Redlock`，**此种方式比原先的单节点的方法更安全**。它可以保证以下特性：

1. 安全特性：互斥访问，即永远只有一个 client 能拿到锁
2. 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client 宕机了或者出现了网络分区
3. 容错性：只要大部分 Redis 节点存活就可以正常提供服务

### Redis持久化RDB&AOF&各自的优缺点 :exclamation:

**持久化**：持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

Redis 提供两种持久化机制 **RDB（默认）** 和 **AOF** 机制:

**RDB：是Redis DataBase缩写快照**

* ![redis中rdb持久化](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812732.png)

* RDB 是 Redis 默认的持久化方式。按照一定的时间**将内存的数据以快照的形式保存到硬盘中**，对应产生的数据文件为 dump.rdb。

* 通过配置文件中的 save 参数来定义快照的周期。

* 优点：

  * RDB把整个Redis数据保存在单一文件中，**方便持久化**。
  * **容灾性好**，一个文件可以保存到安全的磁盘。
  * 性能最大化，**主进程 fork 子进程来完成写操作**，而主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
  * 相对于数据集大时，RDB 比 AOF 的**启动效率更高**。

* 缺点

  * **数据安全性低**。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

    > 默认五分钟甚至更久的时间才会生成一次

  * 还有就是**RDB**在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候**fork**了一个子进程去生成一个大快照，哦豁，出大问题！

**AOF：持久化**

* ![redis中aof持久化](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812346.png)
* AOF 持久化(即Append Only File持久化)，则是**将Redis执行的每次写命令记录到单独的日志文件中**，当重启Redis会重新将持久化的日志中文件恢复数据。
* 当两种方式同时开启时，数据恢复Redis会**优先选择AOF恢复**。
* 优点：
  * **数据安全**，aof 持久化可以配置 appendfsync 属性，有 always：每进行一次命令操作就记录到 aof 文件中一次。
  * 通过 **append-only 模式**写文件：
    * 一方面：只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人
    * 一方面：即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题
  * AOF 机制的 **rewrite 模式**。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）
* 缺点
  * AOF 文件比 RDB 文件大，且恢复速度慢。
  * 数据集大的时候，比 rdb 启动效率低。

**优缺点总结**

- AOF文件比RDB更新频率高

  > 因此，RDB 更适合做**冷备份**，AOF更适合做**热备份**

- AOF比RDB更安全也更大

- RDB性能比AOF好

  > 可以先用RDB恢复数据，之后再用AOF补充恢复数据

- 如果两个都配了优先加载AOF

### 如何选择合适的持久化方式

**我全都要**，单独用**RDB**你会丢失很多数据，单独用**AOF**，数据恢复没**RDB**来的快，当真有问题出现是：第一时间用**RDB**恢复，然后**AOF**做数据补全。

进一步说明：

- 一般来说，应该**同时使用两种持久化功能**。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
- 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
- 有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的bug。
- 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。

### RDB 持久化详解

> 优缺点等已经在上述说明了

 **Redis Database：持久化快照保存流程**

![rdb保存流程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812413.PNG)

> 在主从复制中，`.rdb `一般起到备用作用，在从机上。 

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是 Snapshot 快照，它恢复时是将快照文件直接读到内存里。

Redis会单独创建（fork）一个**子进程来进行持久化**，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件**替换**上次持久化好的文件。**整个过程中，主进程是不进行任何IO操作的**。这就确保了极高的性能。

如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。**RDB的缺点是最后一次持久化后的数据可能丢失**。我们默认的就是RDB，一般情况下不需要修改这个配置。

有时候在生产环境我们会将这个文件进行备份。

**配置文件中的属性：**

rdb 默认保存的文件是 `dump.rdb` 都是在我们的配置文件中的快照选项(SNAPSHOTTING)中进行配置的

```bash
# 1.保存策略
save 900 1
save 300 10
save 60 10000
# 2.在rdb文件保存出错时，是否继续接受redis的写请求
stop-writes-on-bgsave-error yes
# 3.保存rdb文件时是否进行压缩操作
rdbcompression yes
# 4. 是否对rdb文件进行校验
rdbchecksum yes
# 5. rdb文件默认的文件名
dbfilename dump.rdb
# 6. rdb文件默认保存路径
dir ./
```

**触发机制**：

1. 在save的规则满足的情况下，会自动触发rdb规则；
2. 执行 flushall/flushdb 命令，也会触发我们的rdb规则；
3. 退出redis （shutdown），也会产生 rdb 文件

**恢复rdb文件**：

1. 只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会**自动检查** dump.rdb 恢复其中的数据； 

2. 查看需要存在的位置

   ```bash
   127.0.0.1:6379> config get dir
   1) "dir"
   2) "C:\\Software\\redis"
   ```

### AOF 持久化详解

Append Only File：**将我们的所有命令都记录下来**，类似history，**恢复的时候就把这个文件全部再执行一遍**

![aof保存流程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812469.PNG)

以日志的形式来记录每个写操作，**将Redis执行过的所有指令记录下来**（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据；

换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

**配置文件中的属性：**

```bash
# 1.是否开启aof
# 默认是不开启的，修改为yes即可开启
appendonly no

# 2.aof默认的名字
appendfilename "appendonly.aof"

# 3.追加写入文件的策略 ☆☆☆
# appendfsync always  # 每次修改都写入，最慢最安全
appendfsync everysec  # 默认值，每隔1s写入
# appendfsync no	  # 让操作系统决定什么时候写入，更快

# 4. 参考：https://blog.csdn.net/jingkyks/article/details/46956905
# 在 1.重写aof文件操作 && 2.主进程写aof文件操作时，选择哪一个操作阻塞：
# no：令重写阻塞，是安全的方式；
# yes：重写aof文件不阻塞，但是主进程写aof阻塞，会出现数据丢失情况
no-appendfsync-on-rewrite no

# 5.aof大小相关属性，当aof文件超过设定值时，会触发重写aof文件操作
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

> **错误处理：**
>
> 当 .aof 文件出错后，可以通过相应的工具对文件进行修复，将错误部分的内容删除

### Redis 过期键的删除策略

Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。

Redis 的过期策略就是指**当Redis中缓存的key过期了，Redis如何处理**。

首先过期策略通常有以下三种：

- **定时过期**：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，**对内存很友好**；但是**会占用大量的CPU资源去处理过期的数据**，从而影响缓存的响应时间和吞吐量。

- **惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以**最大化地节省CPU资源，却对内存非常不友好**。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

- **定期过期**：每隔一定的时间，会扫描一定数量的数据库的**expires字典**，检查expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

  > expires字典（过期字典）会保存所有设置了过期时间key的过期时间，其中，expires字典的key是一个指针，指向键空间的某个键对象；value是该键的毫秒精度的UNIX时间戳，表示过期时间。
  >
  > 键空间是指该Redis集群中保存的所有键。

Redis中同时使用了**惰性过期和定期过期**两种过期策略。

两者各有优劣：

* 第一种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！
* 第二种的缺点是维护大量缓存的key是比较麻烦的，具体用哪种方案，大家可以根据自己的应用场景来权衡。

> **Redis key的过期时间和永久有效分别怎么设置？**
>
> - 过期时间：expire；
> - 永久有效：persist

### Redis 缓存失效策略/内存淘汰策略

Redis 的内存淘汰策略是指在Redis的用于**缓存的内存不足时**，怎么处理需要新写入且需要申请额外空间的数据。

**全局的键空间选择性移除**：

- **noeviction**：当内存不足以容纳新写入数据时，新的写入操作会报错。这是**默认的策略**，

  > 即如果达到设置的上限，默认情况下，Redis的写命令会返回错误信息（但是读命令还可以正常返回）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

- **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）

- **allkeys-random**：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

**设置过期时间的键空间选择性移除**：

- **volatile-lru**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- **volatile-random**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- **volatile-ttl**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

**注意点**：

* 如果没有**设置expire的key**, 即不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为，和 noeviction 基本上一致

* Redis的**内存淘汰策略的选取并不会影响过期的key的处理**。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；而过期策略用于处理过期的缓存数据。

* 关于使用的LRU（Least Recently Used）算法，Redis 使用的并不是完全LRU算法，见下方参考资料解释。

  > **Redis为什么不使用真实的LRU实现是因为这需要太多的内存。不过近似的LRU算法对于应用而言应该是等价的。**
  >
  > 辅助理解：https://blog.csdn.net/ligupeng7929/article/details/79603060

> 上述配置策略需要通过配置文件进行修改：
>
> ```bash
> # 设置能连接上redis的最大客户端的数量
> maxclients 10000  
> 
> # redis 配置最大的内存容量
> maxmemory <bytes> 
> 
> # 内存到达上限之后的处理策略
> maxmemory-policy noeviction  # 默认策略，即：
> # volatile-lru ->    根据LRU算法删除带有expire的key
> # allkeys-lru ->     根据LRU算法删除任何的key
> # volatile-random -> 随机删除带有expire的key
> # allkeys-random ->  随机删除
> # volatile-ttl ->    删除最小ttl值的key
> # noeviction ->      永不过期，直接返回错误
> ```

### 缓存和数据库数据的一致性 :exclamation:

数据不一致的问题，可以说只要使用缓存，就要考虑如何面对这个问题。

1. 从理论上说，只要我们**设置了合理的键的过期时间**，我们就能保证缓存和数据库的数据**最终是一致**的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。
2. 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。

而当更新失败时，也会出现数据不一致的情况，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。

解决的办法是：

* 如果服务对耗时不是特别敏感可以**增加重试**；
* 如果服务对耗时敏感可以通过**异步补偿任务**来处理失败的更新

短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。

### 缓存更新方式

缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。

更新的方式可以是主动更新。

- **数据源是 DB 时**，可以在更新完 DB 后就直接更新缓存。

- 当数据源不是 DB 而是其他远程服务，可能无法及时主动感知数据变更，这种情况下一般会**选择对缓存数据设置失效期**，也就是数据不一致的最大容忍时间。

  这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。

  但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是**异步更新**，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种**纯异步更新方式**，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。

### Redis 事物

**事物概念**：

* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。

* 事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

* 事物具有四大特性：ACID

  * 原子性（Atomicity）

    原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

  * 一致性（Consistency）

    事务前后数据的完整性必须保持一致。

  * 隔离性（Isolation）

    多个事务并发执行时，一个事务的执行不应影响其他事务的执行

  * 持久性（Durability）

    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

**Redis 中的事物**：

* 概念：Redis 事务的本质是通过 `MULTI / EXEC / WATCH` 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

  **总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。**

* Redis事务的三个阶段

  1. 事务开始 MULTI
  2. 命令入队
  3. 事务执行 EXEC

  事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

* **注意点**：

  * **Redis的事务总是具有ACID中的一致性和隔离性**，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性
  * Redis 是**单进程(单线程)程序**，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止**。因此，Redis 的事务是总是带有隔离性的**。
  * Redis中，单条命令是原子性执行的，**但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。**

> Redis事务其他实现
>
> - 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完
> - 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐

### Redis 集群：主从架构&主从同步 :exclamation:

单机的 Redis，能够承载的 QPS（每秒查询 Query Per Second） 大概就在上万到几万不等。**对于缓存来说，一般都是用来支撑读高并发的**。

因此架构做成**主从(master-slave)架构**，一主多从，**主负责写**，并且将数据复制到其它的 slave 节点，**从节点负责读**。所有的读请求全部走从节点。这样也可以**很轻松实现水平扩容，支撑读高并发**。

![redis主从架构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812216.png)

**主从复制过程**：

![redis主从复制的核心原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812723.png)

1. 当从节点和主节点建立 Master Slave 关系后，从节点会向主节点**发送 SYNC 命令**
2. 主节点接收到 SYNC 命令后会开始**在后台保存快照**(RDB 持久化过程，启动一个后台线程生成一份 .rdb 快照文件)，并将期间接收到的**写命令缓存起来**
3. 当快照完成后，主节点会将快照文件和所有缓存的写命令发送给从节点
4. 从节点接收到后，先将文件写入本地磁盘，然后从本地磁盘中载入快照文件并且执行收到的缓存的命令（**全量复制**）
5. 之后，主节点每当接收到写命令时就会将命令发送从节点，从而保证数据的一致（**增量复制**）

缺点：所有的从节点数据的复制和同步都由主节点来处理，会照成主节点压力太大，使用**主从从结构**来解决

> 主从从结构：除了上一种一对多的模型，主从节点构建的另一种模式：类似链路模式
>
> ![链式模式](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812197.png)

**全量复制**：用于初次复制或其他无法进行部分复制的情况，将主节点中的**所有数据**都发送给从节点，是一个非常重型的操作，当从节点在接收到主节点的数据后，将其存盘并加载到内存中。

**增量复制**：主节点继续将新的所有收集到的修改命令依次传给从节点，完成同步

**主从复制的核心机制**

- redis 采用**异步方式**复制数据到 slave 节点；

  > 不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；

- 一个 master node 是可以配置多个 slave node 的；

- slave node 也可以连接其他的 slave node；

- slave node 做复制的时候，不会阻塞 master node 的正常工作；

- slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；

- slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。

> 注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果**你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了**。
>
> 另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。

### Redis 集群：哨兵模式 :exclamation:

![多哨兵模式](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812910.PNG)

**哨兵的介绍**：

sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：

- **集群监控**：负责监控 redis 的 master 和 slave 进程是否正常工作。

- **消息通知**：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。

- **故障转移**：如果 master node 挂掉了，会自动转移到 slave node 上。

  > 选主的策略简单来说有三个：
  >
  > - slave 的 priority 设置的越小，优先级越高；
  > - 同等情况下，slave 复制的数据越多优先级越高；
  > - 相同的条件下 runid 越小越容易被选中。

- **配置中心**：如果故障转移发生了，通知 client 客户端新的 master 地址。

**哨兵用于实现 redis 集群的高可用**，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。

- 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。
- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。

**哨兵的注意点**：

- 哨兵至少需要 3 个实例，来保证自己的健壮性。
- 哨兵 + redis 主从的部署架构，是**不保证数据零丢失的，只能保证 redis 集群的高可用性**。
- 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。

### Redis集群：分区:exclamation:

Redis 分区是将你的数据分布在多个 Redis 实例上，以至于**每个实例只包含一部分数据**。

Redis分区有两个主要目标：

1. 分区可以让Redis**管理更大的内存**，Redis将可以使用所有机器的内存。如果不进行分区，你将会受限于单台计算机的内存。
2. 分区使Redis的**计算能力**通过简单地增加计算机得到成倍提升，Redis的**网络带宽**也会随着计算机和网卡的增加而成倍增长。

### Redis 分区实现:exclamation:

**客户端分区**：就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读取。大多数客户端已经实现了客户端分区。

> ![基于客户端分配](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812708.jpeg)
>
> **简介**：其主要思想是采用哈希算法将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key 会映射到特定的 Redis 节点上。Java 的 redis 客户端驱动库 jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及结合缓存池的 ShardedJedisPool。
>
> **优点**：优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强
>
> **缺点**
>
> - 由于 sharding 处理放到客户端，规模进一步扩大时给运维带来挑战。
> - 客户端 sharding 不支持动态增删节点。服务端 Redis 实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化。

**代理分区**：意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy

> ![基于代理服务器分片](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812334.jpeg)
>
> **简介**：客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端
>
> **优点：**
>
> - 透明接入，业务程序不用关心后端 Redis 实例，切换成本低
> - Proxy 的逻辑和存储的逻辑是隔离的
>
> **缺点**：代理层多了一次转发，性能有所损耗

**查询路由(Query routing)** 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个Redis节点，而是在客户端的帮助下直接 **redirected** 到正确的redis节点。

> ![redis官方cluster方案](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812765.png)
>
> **简介**：
>
> Redis Cluster 是一种服务端 Sharding(分片) 技术，3.0版本开始正式提供。**Redis Cluster 并没有使用一致性hash，而是采用slot(槽)的概念**，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。
>
> 在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加10000 的端口号，比如 16379：
>
> * 而 6379 端口号就是redis服务器入口
> * 16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。
>
> **方案说明**
>
> 1. 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位
> 2. 每份数据分片会存储在多个互为主从的多节点上
> 3. 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
> 4. 同一分片多个节点间的数据不保持一致性
> 5. 读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回**重定向指令**，指向正确的节点
> 6. 扩容时时需要需要把旧节点的数据迁移一部分到新节点
>
> > **分布式寻址算法：**
> >
> > - hash 算法（大量缓存重建）
> >
> > - 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）
> >
> > - redis cluster 的 hash slot 算法
> >
> >   > **Redis哈希槽的概念:**
> >   >
> >   > Redis集群没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。
>
> **优点**
>
> - 无中心架构，支持动态扩容，对业务透明
> - 具备Sentinel的监控和自动Failover(故障转移)能力
> - 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
> - 高性能，客户端直连redis服务，免去了proxy代理的损耗
>
> **缺点**
>
> - 运维也很复杂，数据迁移需要人工干预
> - Redis集群目前无法做数据库选择，默认在0数据库
> - 不支持批量操作(pipeline管道操作)
> - 分布式逻辑和存储模块耦合等

### Redis 分区问题

- **涉及多个 key 的操作通常不会被支持**。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例

  > 实际上这种情况也有办法，但是不能直接使用交集指令

- 涉及多个key的操作不能用Redis事务

- 分区是按照key为粒度进行划分，不可能使用大的 key（如很大的排序集）分片数据集

- 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集RDB/AOF 文件。

- 分区时动态扩容或缩容可能非常复杂。Redis Cluster在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。

### 缓存异常：缓存雪崩

**概念**：

缓存雪崩，是指在某一个时间段，**缓存集中过期失效**。

产生雪崩的原因之一：比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生**周期性的压力波峰**。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。  

![缓存雪崩](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812765.PNG)

其实集中过期，倒不是非常致命，**比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网**。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。  

**解决方案**：

1. **redis高可用**

   这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建集群。

2. **限流降级**

   这个解决方案的思想是，在缓存失效后，通过加锁或者队列来**控制读数据库写缓存的线程数量**。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

3. **数据预热**

   数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，**设置不同的过期时间，让缓存失效的时间点尽量均匀**。  

### 缓存异常：缓存穿透

**概念**：

缓存穿透的概念很简单，用户想要查询一个数据，**发现 redis 内存数据库没有**，也就是缓存没有命中，于是向持久层数据库查询，**发现数据库中也没有**，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

**解决方案**：

1. **布隆过滤器**  

   布隆过滤器是一种数据结构，**对所有可能查询的参数以 hash 形式存储**，在控制层先进行校验，不符合则丢弃，存在的话就去查询数据库然后再把结果返回，从而避免了对底层存储系统的查询压力

   ![布隆过滤器](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812535.PNG)

2. **缓存空对象**

   当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；  

   ![缓存空对象](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812753.PNG)

   但是这种方法会存在两个问题：

   1. 如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；
   2. 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响  

### 缓存异常：缓存击穿

**概述**：

这里需要注意缓存穿透和缓存击穿的区别，**缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库**，就像在一个屏障上凿开了一个洞。

当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。  

**解决方案**：

1. **设置热点数据永不过期**：从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。

2. **加互斥锁**

   分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。 

   ![缓存击穿-加互斥锁](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251812547.PNG)

### 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

**缓存降级的最终目的是保证核心服务可用，即使是有损的**。而且有些服务是无法降级的（如加入购物车、结算）。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

### 热点数据和冷数据

**热点数据，缓存才有价值**

> 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次；再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。

对于**冷数据**而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。

数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。

频繁修改的数据，看情况考虑使用缓存。

**问：那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？**

有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如：点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。