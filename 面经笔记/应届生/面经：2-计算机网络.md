# 面经：2-计算机网络

> 个人整理 :muscle: 个人专用 :muscle: 暑期实习 :muscle: 秋招 :muscle: 后端开发 :muscle: 八股文 :no_mouth:

### 七层网络协议体系结构的理解 :exclamation::exclamation::exclamation:

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

![5层网络协议](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806254.jpg)

- **应用层：**为操作系统或网络应用程序**提供访问网络服务的接口**；
- **表示层：**将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能处理的格式；主要**负责数据格式的转换**；
- **会话层：**进行**通讯管理**，负责建立和断开通讯连接；
- **传输层：**负责向两台不同网络下主机进程之间的通信提供通用的**数据传输服务**。
- **网络层：**提供逻辑地址(IP)，为不同局域网的主机通讯提供**路由寻址**，将数据传输到目标地址；
- **数据链路层：**管理**相邻节点**之间的数据通信；
- **物理层：**将数据转化为比特流，设备之间的比特流传输。

### 五层协议中各自对应的网络协议

计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：

* 应用层：
  * **超文本传输协议：HTTP，HyperText Transfer Protocol**
  * **文件传输协议：FTP，File Transfer Protocol**
  * **域名系统：DNS，Domain Name System**
  * 安全外壳协议：SSH，Secure Shell
  * 动态主机配置协议：DHCP，Dynamic Host Configuration Protocol
  * 远程登录协议：TELNET
* 传输层
  * **传输控制协议：TCP，Transmission Control Protocol**
  * **用户数据报文协议：DUP，User Datagram Protocol**
* 网络层
  * **网际协议：IP，Internet Protocol**
  * 地址转换协议：ARP，Address Resolution Protocol
  * 反地址转换协议：RARP，Reverse Address Resolution Protocol
  * 控制报文协议：ICMP，Internet Control Message Protocol
  * 网际组管理协议：IGMP，Internet Group Management Protocol
  * 路由信息协议：RIP，Routing Information Protocol
  * 路由器选择协议：OSPF，Open Shortest Path First
  * 边界网关协议：BGP，Border Gateway Protocol
* 数据链路层
  * 自动重传请求协议：ARQ，Automatic Repeat-reQuest
  * 停止等待协议：CSMA/CD，Carrier Sense Multiple Access with Collision Detection
  * 点对点协议：PPP，Point to Point Protocol

### ARP 协议的工作原理

**网络层的 ARP 协议完成了 IP 地址与物理地址(MAC地址)的映射**。

解释：ARP(Address Resolution Protocol)

首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。

此 ARP 请求数据包里包括：源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

> RARP（Reverse Address Resolution Protocol），逆地址解析协议，根据MAC地址来获取IP地址

### IP 地址分类的理解

IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。

每个 IP 地址包括两个标识码（ID），即**网络 ID** 和**主机 ID**。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：

A 类地址：以 0 开头，第一个字节范围：0~127；

B 类地址：以 10 开头，第一个字节范围：128~191；

C 类地址：以 110 开头，第一个字节范围：192~223；

D 类地址：以 1110 开头，第一个字节范围为 224~239；

E 类地址：以 1111 开头，保留地址

> 博客中更加完善：[计算机网络：计算机网络基础总结-网络层-IP地址](https://www.cnblogs.com/zhuchengchao/p/12899458.html)

### TCP 的主要特点 :exclamation::exclamation:

1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；
3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
5. TCP面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

### UDP 的主要特点 :exclamation::exclamation:

1. UDP 是无连接的；
2. UDP 支持一对一、一对多、多对一和多对多的交互通信；
3. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如：直播，实时视频会议等）；
5. UDP 是面向报文的；
6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

### TCP 和 UDP 的区别 :exclamation::exclamation::exclamation:

![tcp和udp区别](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806805.jpg)

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。且 TCP 不提供广播或多播服务。

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。

### TCP & UDP 对应的常见应用层协议

- **TCP 对应的应用层协议**

**FTP(File Transfer Protocol)：定义了文件传输协议，使用 21 端口。**常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。

**HTTP(Hyper Text Transfer Protocol)：超文本传输协议，使用80端口**，从 Web 服务器传输超文本到本地浏览器的传送协议。

**SMTP(Simple Mail Transfer Protocol)：定义了简单邮件传送协议**，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。

> Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。
>
> POP3(Post Office Protocol - Version 3)：邮局协议版本3，它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。

**2. UDP 对应的应用层协议**

**DNS(Domain Name System)：用于域名解析服务**，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。

> SNMP：Simple Network Management Protocol 简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
>
> TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。

### TCP 三次握手的过程 :exclamation::exclamation::exclamation:

**三次握手**：TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。

![三次握手](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806901.png)

服务端的 TCP 服务器进程首先创建传输控制块 TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。

**第一次握手**：

1. 客户端创建传输控制块，向服务器端发出请求报文段；
2. 报文段中包括：同步位 SYN=1，初始序号 seq = x；
3. TCP 客户端进程进入 SYN-SENT（同步已发送）状态。

**第二次握手**：

1. 服务端收到连接请求报文后，向客户端发送确认报文段；
2. 报文段中：同步位 SYN=1，确认位 ACK =1，选择一个初始序号 seq = y，确认号 ack = x + 1；
3. 服务端进程进入 SYN-RCVD（同步收到）状态

**第三次握手**：

1. 客户进程收到服务端的确认后，再向服务端发出确认应答报文；
2. 确认报文段：确认位 ACK =1，确认号 ack = y +  1，自己的序号 seq = x + 1
3. 这时，TCP 连接已经建立，客户端进入 ESTABLISHED（已建立连接）状态；
4. 服务器端收到这个信号后也进入 ESTABLISHED（已建立连接）状态。

### 两次握手不可以理由 :exclamation::exclamation:

**为了防止已经失效的连接请求报文段突然又传送到了，因而产生错误**。

比如下面这种情况：客户端发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达服务端。本来这是一个早已失效的报文段。但是服务端收到此失效的链接请求报文段后，就误认为客户端又发出一次新的连接请求。于是就向客户端发出确认报文段，同意建立连接。

对于上面这种情况，如果不进行第三次握手，服务端发出确认后就认为新的传输连接已经建立了，并一直等待客户端发来数据。这样服务端的许多资源就这样白白浪费了。

如果采用了三次握手，由于客户端实际上并没有发出建立连接请求，所以不会理睬服务端的确认，也不会向服务端发送数据。服务端由于收不到确认，就知道客户端并没有要求建立连接。

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806218.PNG" alt="为什么三次握手" style="zoom:50%;" />

### 不需要四次握手的理由 :exclamation:

有人可能会说客户端发出第三次握手的信息后在没有接收到服务器端的确认请求就已经进入了连接状态，那如果客户端的这个确认包丢失或者滞留了怎么办？

我们需要明白一点，**完全可靠的通信协议是不存在的**。**在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息**。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。

### 关于SYN的进一步说明

**服务端收到客户端的 SYN 后需要传回 SYN 理由？**

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

**SYN 是 TCP / IP 建立连接时使用的握手信号。**在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN+ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

> Acknowledgement，确认字符，在数据通信传输中，接收端发给发送端的一种传输控制字符。它表示确认发来的数据已经接受无误

**传了 SYN 还要传 ACK 理由？**

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

### TCP 四次挥手的过程 :exclamation::exclamation::exclamation:

据传输结束后，通信的双方都可以释放连接。现在 客户端 和 服务端 都处于 ESTABLISHED 状态。

![四次挥手](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806184.jpg)

> seq：sequence Number；ack：acknowledge Number

**第一次挥手：**

1. 客户端向服务器端发送连接释放报文段，主动关闭连接；

2. 报文段中：终止控制位 FIN = 1，序号 seq = u；

   > seq 等于前面已传送过的数据的最后一个字节的序号加 1

3. 客户端进入 FIN-WAIT-1（终止等待-1）状态，等待服务端的确认。

**第二次挥手：**

1. 服务端接受到连接释放报文段后立即发出确认；

2. 报文段中：确认位ACK =1，序号 seq = v，确认序列号ack = u + 1；

3. 服务端进入 CLOSE-WAIT（关闭等待）状态

   > TCP 服务端进程这时应通知高层应用进程，因而从客户端到服务端这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即客户端已经没有数据要发送了，但服务端若发送数据，客户端仍要接收。也就是说，从服务端到客户端这个方向的连接并未关闭，这个状态可能会持续一段时间。

4. 客户端收到来自服务端的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待服务端发出的连接释放报文段。

**第三次挥手：**

1. 服务端已经没有要向客户端发送的数据，服务端发出的连接释放报文段；
2. 报文段：终止控制位 FIN = 1，确认位ACK =1，序号 seq = w，确认序列号是 ack = u + 1；
3. 服务端就进入LAST-ACK(最后确认)状态，等待客户端的确认。

**第四次挥手**：

1. 客户端在收到服务端的连接释放报文后，必须对此发出确认；
2. 报文段：确认位ACK =1，序号seq = u + 1，确认序列号是 ack = w + 1；
3. 进入TIME-WAIT(时间等待) 状态；

> 此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间 2MSL（MSL Max Segment Lifetime：最长报文段寿命）后，客户端才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。
>
> 而服务端一收到客户端的确认报文就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，服务端结束 TCP 连接的时间要早于客户端。

### 需要四次挥手理由 :exclamation::exclamation::exclamation:

或者说是：**第二次跟第三次不能合并的理由**

**确保数据能够完成传输**；即当收到连接释放报文时（第一次挥手），仅表示对方已经没有数据发给你了，但是自己的数据却并不意味着已经完全发送给对方了；因此在收到对方的连接释放报文后，对其进行响应ACK后（第二次挥手），继续发送数据，直到自己的数据也发送完成后再发送连接释放报文（第三次挥手），告诉对方自己的数据也发送完成，表示已经可以进行连接的关闭了，对方接受到了连接释放报文后返回ACK确认报文（第四次挥手），双方关闭连接。

### TIME-WAIT 必须等待 2MSL 的时间理由 :exclamation::exclamation:

1. **是为了确保发送方发送的最后一个报文（第四次挥手报文）能成功抵达接受方。**这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的服务端收不到对已发送的FIN + ACK报文段的确认。服务端会超时重传这个FIN+ACK报文段，而客户端就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的FIN+ACK报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务端都正常进入到 CLOSED 状态。如果客户端在 TIME-WAIT 状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到服务端重传的 FIN + ACK报文段，因而也不会再发送一次确认报文段，这样，服务端就无法按照正常步骤进入CLOSED状态。
2. **确保当前连接的所有报文都已经过期了。**客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### 保活计时器的作用

除时间等待计时器外，TCP 还有一个保活计时器（keep alive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送10个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### TCP 协议是如何保证可靠传输的 :exclamation::exclamation::exclamation:

1. **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；

2. **对失序数据包重排序**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；

3. **丢弃重复数据**：对于重复数据，能够丢弃重复数据；

4. **应答机制**：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。

   > 这个确认不是立即发送，通常将推迟几分之一秒；

5. **超时重发**：当 TCP 发出一个段后，它启动一个超时重传定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

   > 超时重传定时器：重传时间设定为 2 × RTT，RTT，Round Trip Time，一个连接的往返时间，即数据发送时刻到接受到确认时刻的差值，RTT是动态计算的，具体计算过程不展开...

6. **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。

   > 这里有一个坚持定时器

### 对停止等待协议的理解

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

主要包括以下几种情况：

- 无差错情况；
- 出现差错情况（**会进行超时重传**）
  - 发送消息在路上丢失了；
  - 确认消息在路上丢失了；
  - 确认消息过了很久才到；

### 对 ARQ 协议的理解

ARQ：Automatic Repeat-reQuest，自动重传请求

**自动重传请求 ARQ 协议**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

**连续 ARQ 协议**

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

### 对滑动窗口的了解 :exclamation::exclamation:

**TCP 利用滑动窗口实现流量控制的机制**。滑动窗口（Sliding window）是一种流量控制技术。

> 早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，**滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据**。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外

1. 一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。

2. 另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

   > 这里涉及到了，TCP中的**坚持定时器**

### 对流量控制的理解

TCP 利用滑动窗口实现流量控制。**流量控制是为了控制发送方发送速率，保证接收方来得及接收**。接收方发送的确认报文中的**窗口字段**可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

> 于是发送方在一段时间后（**坚持定时器**），会再次发送窗口探测报文来确定窗口大小，避免出现死锁。

### TCP 的拥塞控制及其使用的算法 :exclamation::exclamation:

**流量控制：**考虑的是**点对点**的通信量的控制；

> 流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是**抑制发送端发送数据的速率，以便使接收端来得及接收**。

**拥塞控制：**考虑整个网络，是**全局性**的考虑；

> 拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。这是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。
>
> > 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。

**网络拥塞**：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。

为了进行拥塞控制，TCP 发送方要维持一个**拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。

> 发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即：**慢开始、拥塞避免、快重传和快恢复**。

> 在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 

慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，**即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值**。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。

> 加倍的说明：
>
> 开始时发送方的cwnd=1，发送并收到确认后，cwnd=2；
>
> 发送方再次发送时，cwnd=2，发送并收到确认后，此时会有两个确认信号，cwnd=4
>
> ...是一个指数增长过程，
>
> 继续上述过程，直到拥塞窗口cwnd的值已经等于**慢开始门限值（ssthresh）**，之后改用拥塞避免算法
>
> - 当 cnwd＜ ssthresh，使用慢开始算法
> - 当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
> - 当 cnwd＞ ssthresh，使用拥塞避免算法 

> 慢开始不是指 cwnd 的增长速度慢（指数增长），而是指 TCP 开始发送设置 cwnd=1 

- **拥塞避免：** 

拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。

> 慢开始和拥塞避免图示：**报文超时即判断是发生了拥塞**
>
> ![拥塞控制](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807590.PNG)

- **快重传与快恢复：** 

在 TCP/IP 中，快速重传和快恢复（Fast Retransmit and Recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。

没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。**有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段**。

有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

![FRR](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807362.PNG)

> 参考：https://blog.csdn.net/qq_41431406/article/details/97926927

### 关于TCP的粘包

**概念**：

在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 **TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界**；
2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。

基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。**一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。**

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

**TCP 黏包是如何产生的**

- **发送方产生粘包**

  采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

- **接收方产生粘包**

  接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

**解决拆包和粘包问题**

分包机制一般有两个通用的解决方法：

1. 特殊字符控制；
2. 在包头首都添加数据包的长度。

如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。

> UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。

### forward & redirect 的区别 :exclamation::exclamation:

forward 和 Redirect 代表了**两种请求转发方式**：直接转发和间接转发。

**直接转发方式（Forward），转发：**

1. 客户端和浏览器只发出**一次请求**，由服务器端进行页面跳转；
2. 地址栏不发生变化，显示的是上一个页面的地址；
3. 请求域(request)的数据不会丢失。

**间接转发方式（Redirect），重定向：**

1. 实际是**两次 HTTP 请求**，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的，即是由浏览器端进行的页面跳转；
2. 请求域（request）中的数据会丢失，因为是两次请求。

> 举个通俗的例子：
>
> 直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；
>
> 间接转发就相当于："A 找 B 借钱，B 说没有，让 A 去找 C 借"。

> 参考：https://blog.csdn.net/weixin_40001125/article/details/88663468

### 说下 HTTP 协议 :exclamation::exclamation::exclamation:

**HTTP(Hyper Text Transfer Protocol)：超文本传输协议，使用80端口**，其位于OSI7层模型的应用层，是 Web 服务器与本地浏览器之间传输超文本的传送协议。

一般为：客户端（IE）向服务器端发送 HTTP 请求，再由服务器将响应的内容返回给客户端的一个过程。

HTTP 链接是通过 TCP 链接，首先客户端和服务端会建立 TCP 连接，然后开始发送 HTTP 请求，接着由服务器返发响应的内容。

**再谈谈HTTP报文格式**

* **请求报文格式**

  ![请求报文](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807285.PNG)

* **响应报文格式**

  ![响应报文](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807819.PNG)

> 详细笔记：[计算机网络：HTTP](https://www.cnblogs.com/zhuchengchao/p/12925591.html)，里面记录了 HTTP 报文首部字段名及对应的意义等...

### HTTP 首部字段 :exclamation:

> 详细的内容请看[计算机网络：HTTP](https://www.cnblogs.com/zhuchengchao/p/12925591.html)

HTTP协议的请求和响应报文中必定包含着HTTP的首部，在上方HTTP的请求/响应报文的格式中可以看出，报文首部由如下部分组成：

- **请求报文**：请求行，请求首部字段，通用首部字段，实体首部字段；
- **响应报文**：状态行，响应首部字段，通用首部字段，实体首部字段。

格式：**首部字段名：字段值**

下面列出几个常用的字段：通用首部字段、请求首部字段、响应首部字段

* **通用首部字段：请求报文和响应报文都会使用的字段**。

  | 首部字段名        | 说明                       | 示例                                         |
  | ----------------- | -------------------------- | -------------------------------------------- |
  | Cache-Contorl     | 控制缓存行为               | Cache-Contorl: private, max-age=0, no-chache |
  | Connection        | 管理持久连接               | Connection: Keep-Alive                       |
  | Data              | 创建报文的日期时间         | Data: Thu, 26 Mar 2020 05:36:55 GMT          |
  | Transfer-Encoding | 指定报文主体的传输编码方式 | Transfer-Encoding: chunked                   |

* **请求首部字段：客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息。**

  | 首部字段名      | 说明                     | 示例                                                         |
  | --------------- | ------------------------ | ------------------------------------------------------------ |
  | Accept          | 用户代理可处理的媒体类型 | Accept：text/html, application/xhtml+xml, application/xml;q=0.9, image/apng,*/*;q=0.8 |
  | Accept-Charset  | 优先的字符集             | Accept-Charset:<br/>iso-8859-5.unicode-1-1;q=0.8             |
  | Accept-Encoding | 优先的内容编码           | Accept-Encoding: gzip, deflate, br                           |
  | Host            | 请求资源所在的服务器     | Host: www.baidu.com                                          |

* **响应首部字段：从服务器向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息。**

  | 首部字段名    | 说明                    | 示例                     |
  | ------------- | ----------------------- | ------------------------ |
  | Location      | 令客户端重定向到指定URI | Location: http://....... |
  | Accept-Ranges | 是否接受字节范围请求    | Accept-Ranges: bytes     |
  | Age           | 推算资源创建经过时间    | Age: 53                  |

* **实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等实体有关的信息。**

  | 首部字段名       | 说明                   | 示例                                         |
  | ---------------- | ---------------------- | -------------------------------------------- |
  | Allow            | 资源可支持的HTTP方法   | Allow: GET, HEAD                             |
  | Content-Encoding | 实体主体适用的编码方式 | Content-Encoding: gizp                       |
  | Last-Modified    | 资源的最后修改日期时间 | Last-Modified: Sat, 16 May 2020 01:41:38 GMT |

**非 HTTP 1.1 首部字段：Cookie**

* 由于HTTP是**无状态协议**，即无法记住之前与其通讯的客户端；Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态；

  | 首部字段   | 说明                           | 首部类型     |
  | ---------- | ------------------------------ | ------------ |
  | Set-Cookie | 开始状态管理所使用的Cookie信息 | 响应首部字段 |
  | Cookie     | 服务器接收到的Cookie信息       | 请求首部字段 |

**非 HTTP 1.1 首部字段：Session**

* **服务器端会话技术**，访问者从访问某个网站开始到离开为止；在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中；
* 由于HTTP是无协议的，因此会使用Cookie来管理Session，**因此Session的实现是依赖于Cookie的**；

> 关于 Cookie 和 Session 更多内容见后续的问题

### HTTP 状态码 :exclamation:

![HTTP状态码](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807503.jpg)

- **1XX 信息**

  * 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

- **2XX 成功**

  * 200 OK：从客户端发出的请求在服务器端被正确处理了；

  * 204 No Content ：请求已经被成功处理，返回的相应报文中不含主体数据；

    > 一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用

  * 206 Partial Content ：服务器对客户端的范围请求相应成功；

    > 响应报文包含由 Content-Range 指定范围的实体内容

- **3XX 重定向**

  * 301 Moved Permanently ：**永久性**重定向，为资源的请求分配了新的URI，以后都要使用这一个URI；

  * 302 Found ：**临时性**重定向，为资源的请求分配了新的URI，仅限于本次；

  * 303 See Other ：和 302 有着相同的功能，但明确表明需用GET方式获取资源；

  * 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码；

  * 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但307遵守不将POST变为GET请求。

- **4XX 客户端错误**

  * 400 Bad Request ：请求报文中存在语法错误，服务器无法理解；

  * 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败；

  * 403 Forbidden ：对资源的访问请求被服务器拒绝了；

  * 404 Not Found：服务器上无法找到请求的资源。

- **5XX 服务器错误**

  * 500 Internal Server Error ：服务器在执行请求时发生了错误，无法提供资源；

  * 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### HTTP 有哪些方法 :exclamation:

客户端发送的请求报文第一行为请求行，包含了方法字段。

> 方法字段           URI           协议版本
>
> POST          /from/entry   HTTP/1.1

- **GET**：获取指定的服务端资源；
- **HEAD**：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；
- **POST**：提交数据到服务器端；
- **PUT**：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
- **PATCH**：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
- **OPTIONS**：查询指定的 URL 支持的方法；

> **CONNECT**：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
>
> **TRACE**：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

### GET & POST 的区别 :exclamation::exclamation:

GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。

**本质区别**：GET 只是一次 HTTP 请求，POST 先发请求头再发请求体，实际上是两次请求。

> 稍微作展开：
>
> 对于GET请求，浏览器会把请求头和请求体一并发送，服务器响应200，即只会产生一个TCP数据包
>
> 对于POST，浏览器先发送请求头，服务器响应 100 continue；之后浏览器再发送请求体，服务器响应200，即产生了两个TCP数据包

1. 从**功能**上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；

2. 从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；即，**GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变**；

   > 因此在浏览器进行回退操作时，GET请求是无害的，而POST请求则会重新请求一次
   >
   > REST服务：即是一种WEB服务架构
   >
   > https://blog.csdn.net/qq_38129062/article/details/88786482

3. 从**请求参数形式**上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的请求头中；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的请求体中；

   > GET将请求数据附在URL之后，以 ? 分割 URL 和传输数据，参数之间以 & 相连。
   >
   > 特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)
   >
   > 但GET请求只能进行URL编码，而POST请求可以支持多种编码方式

4. 就**安全性**而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将以明文的形式出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；

5. 从**请求的大小**看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的；

6. 从**缓存**看：GET请求浏览器会主动cache；POST并不会，除非主动设置；且GET的请求参数会保存在浏览器历史记录内，POST请求则不会；

### 在浏览器中输入 URL 地址到显示主页的过程 :exclamation::exclamation::exclamation:

1. **DNS 解析**：浏览器查询 DNS，获取域名对应的 IP 地址：

   > 具体过程包括：
   >
   > * 浏览器搜索自身的 DNS 缓存；
   > * 搜索操作系统的 DNS 缓存；
   > * 读取本地的 Host 文件；
   > * 向本地 DNS 服务器进行查询等

2. **TCP 连接**：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；

3. **发送 HTTP 请求报文**：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求报文；

4. **服务器处理请求并返回 HTTP 报文**：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

5. **浏览器解析渲染页面**：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

6. **连接结束**：四次挥手。

### DNS 解析过程+ DNS 缓存:exclamation:

**DNS 解析过程**：

1. 主机向本地域名服务器的查询一般都是采用**递归查询**。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即**替主机继续查询**)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。
2. 本地域名服务器向根域名服务器的查询的**迭代查询**。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

> **对域名缓存的了解**
>
> 为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。
>
> 由于名字到地址的绑定并不经常改变，同时为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。**增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性**。
>
> 不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。

### HTTP 的长连接 & 短连接及其应用场景 :exclamation::exclamation::exclamation:

在 HTTP/1.0 中默认使用**短连接**。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会**重新建立一个 HTTP 会话**。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：`Connection:keep-alive`

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

> Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

### HTTP 1.0 & 1.1 & 2.0 主要变化 :exclamation::exclamation:

**HTTP1.1 的主要变化：**

1. HTTP1.0 经过多年发展，在 1.1 提出了改进。**首先是提出了长连接**，HTTP 可以在一次 TCP 连接中不断发送请求。
2. 然后 HTTP1.1 支持**只发送 header 而不发送 body**。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，**POST 请求默认就是这样做的**。
3. HTTP1.1 **增加了 host 字段**。因为随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机，且共享一个 IP 地址，即一个 IP 地址对应多个域名，而通过请求头中的 Host 字段区分访问这个服务器中的哪个站点。

**HTTP2.0 的主要变化：**

1. HTTP2.0 **支持多路复用**，同一个连接可以并发处理多个请求，方法是把 HTTP 数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP 请求顺序到达；
2. HTTP2.0 **支持服务端推送**，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；
3. HTTP2.0 **压缩了请求头**，同时基本单位是二进制帧流，这样的数据占用空间更少；
4. HTTP2.0 **适用于 HTTPS 场景**，因为其在 HTTP 和 TCP 中间加了一层 SSL（Secure Sockets Layer，安全套接层） 层。

### HTTPS 的工作过程 :exclamation::exclamation:

![HTTPS 的工作过程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807934.png)

1. 客户端发起一个HTTPS请求；

   > 该请求会告诉服务端自己支持的加密规则

2. 服务器在收到请求后，将自己的**数字证书**发送给客户端；

   > 服务器会选好相应的加密算法和Hash算法，这些应该也在证书的明文中吧...

3. 客户端对数字证书进行验证，如果验证通过则继续，不通过则显示警告信息；

   > 比如验证是否在有效期内，证书的用途是不是匹配客户端请求的站点，是不是在CRL吊销列表里，它的上一级证书是否有效...这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书/客户端内置的Root证书）。

4. 当验证通过，客户端继续：

   1. 使用伪随机数生成器生成加密所使用的**对称密钥**，然后用证书的公钥加密这个对称密钥，发送给服务端
   2. 用约定好的Hash算法计算握手消息，然后用生成的对称密钥进行加密，也发送给服务器；

5. 服务端接受到客户端传来的消息后：

   1. 使用自己的私钥解密这个消息，得到**对称密钥**；
   2. 使用对称密钥解析握手消息，验证Hash值是否与浏览器发送的一致

6. 解析结果若一致，则至此，客户端和服务端双方都持有了相同的对称密钥，后续双方通过对称密钥进行内容加解密进行通讯。

### HTTP 和 HTTPS 的区别 :exclamation::exclamation::exclamation:

1. **开销**：HTTPS 协议需要到 CA(Certification authority，证书颁发机构，颁发数字证书的机构) 申请证书，一般免费证书很少，需要交费；
2. **资源消耗**：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的SSL加密传输协议，需要消耗更多的 CPU 和内存资源；
3. **端口不同**：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；
4. **安全性**：HTTP 的连接很简单，是无状态的明文传输；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

### HTTPS 的优缺点 :exclamation::exclamation:

HTTPS（Secure）是安全的HTTP协议，不作为新协议，只是在HTTP通信接口部分加上了SSL（Secure Socket Layer，安全套接层）和TSL（Transport Layer Security，传输层安全），**HTTPS是身披SSL外壳的HTTP**；

![HTTPS](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807409.png)

**优点：**

1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL（Secure Sockets Layer） + HTTP 协议构建的，可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

**缺点：**

1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；
5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

### 数字签名

为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 解密，如果和签名一样，则说明数据确实是真的。

**数字签名生成过程：**将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文本一起传送给接受者。

![数字签名生成过程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807608.PNG)



**校验数字签名流程：**

1. 接受者只有用发送者的公钥才能解密被加密的摘要信息；
2. 然后用Hash函数对收到的原文产生一个摘要信息；
3. 上述两步中的消息摘要进行对比，如果相同说明收到的信息是完整的，在传输过程中没有被修改，否则说明数据信息被修改过。

![校验数字签名流程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807092.PNG)

### 数字证书

对称加密中，接收方通过使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。

所以为了保证发送方的公钥是真的，CA（Certificate Authority，证书颁发机构）证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

而 CA 为客户端和服务器双方都可信赖的第三方机构。以下是**CA业务流程**：

![数字证书](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807679.PNG)

数字证书中包含有：申请者的公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个数字签名。

> 数字签名产生的算法为：利用Hash函数计算公开明文的信息摘要，然后用CA的私钥对信息摘要进行加密，密文即签名。

而**浏览器中已经存有CA机构的公开秘钥**，当收到服务端的数字证书后，将证书中的明文信息用相同的Hash函数进行计算得到信息摘要，再利用CA的公钥解密数字签名得到消息摘要，两者进行对比，若一致，则可以确认服务器的公钥的真实性。

### 对称加密和非对称加密 :exclamation::exclamation:

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但**对称加密所使用的密钥我们可以通过非对称加密的方式发送出去**。

### Cookie 和 Session 辨析 :exclamation::exclamation:

> 我们都知道 HTTP 服务是无状态的，这里的无状态体现在两点：
>
> - 每一个 HTTP 请求是独立的，服务端不能鉴别出两个请求是不是来自同一个用户
> - Web 服务没有在内存中保留请求的任何内容（只有磁盘的信息才能在请求之间共享）
>
> 无状态这个特性对于开发人员是不友好的，因为在实际开发中有时候需要跟踪用户。Cookies和Session技术都是为了使**无状态**的HTTP成为**有状态**的。

**共同之处**：cookie 和 session 都是用来跟踪浏览器用户身份的会话方式，即：cookies和session技术都是为了使**无状态**的HTTP成为**有状态**的。

**区别之处**：总的来说，**cookie是一种客户端会话机制，session是一种服务端会话机制**

1. **数据存放位置不同**：cookie 数据保存在客户端，session 数据保存在服务端。
2. **安全程度不同**：cookie不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，如果主要考虑到安全应当使用 session
3. **性能使用程度不同**：session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用 cookie
4. **数据存储大小不同**：单个 cookie 在客户端的限制是 4K，就是说一个站点在客户端存放的 cookie 不能超过 4K，而 session 则存储与服务端，浏览器对其没有限制。
5. **会话机制不同**：
   * session 会话机制：session 会话机制是一种**服务器端机制**，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。
   * cookies 会话机制：cookie 是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web 服务器使用 HTTP 标头将 cookie 发送到客户端。在客户端终端，浏览器解析 cookie 并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些 cookie。

**Cookie的工作原理**：

* 浏览器端第一次发送请求到服务器端

* 服务器端创建cookie，该cookie中包含用户的信息，然后将该cookie发送到浏览器端

* 浏览器端再次访问服务器端时会携带服务器端创建的cookie

* 服务器端通过cookie中携带的数据区分不同的用户

* **总结**：浏览器使用的是cookie，那么所有数据都保存在浏览器端

  > 比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为 cookie 变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。
>
  > 如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。
>

如果cookie设置了有效值，那么cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有cookie，如果有的话，读取cookie，然后发送给服务器。

**Session的工作原理**：

* 浏览器端第一次发送请求到服务器端，服务器端创建一个session，同时会创建一个**特殊的cookie**（name 为 JSESSIONID 的固定值，value 为 session 对象的ID），然后将该 cookie 发送至浏览器端

  > Set-Cookie: JSESSIONID = SESSIONID

* 浏览器端发送第N(N>1)次请求到服务器端，浏览器端访问服务器端时就会携带该 name 为 JSESSIONID 的 cookie 对象

* 服务器端根据 name 为 JSESSIONID 的 cookie 的 value (SESSIONID)，去查询 Session 对象，从而区分不同用户

* **总结：**简单的说，当你登陆一个网站的时候，如果 web 服务器端使用的是 Session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话 SESSIONID，服务器根据当前 **SESSIONID** 判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。

### 负载均衡

**负载均衡概念**：

客户端的流量首先会到达**负载均衡服务器**，由负载均衡服务器通过一定的调度算法将流量分发到不同的**应用服务器**上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用

**实现负载均衡方式**：

* 四层负载均衡：
  * 发生在**传输层**，通过修改客户端数据报中的 **IP+Port** 进行路由转发；
  * 具体实现方式：通过修改报文中的 IP地址和端口，再加上负载均衡设备所采用的负载均衡算法，最终确定选择后端哪台下游服务器。以TCP为例，客户端向负载均衡发送 SYN 请求建立第一次连接，通过配置的负载均衡算法选择一台后端服务器，并且将报文中的 IP 地址信息修改为后台服务器的 IP 地址信息，因此**TCP三次握手连接是与后端服务器直接建立起来的。**
  * ![四层均衡负载](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807836.PNG)

* 七层负载均衡：
  * 发生在**应用层**，一般是基于请求 **URL 地址**的方式进行代理转发；
  * 具体实现方式：七层负载均衡在应用层选择服务器，只能先与负载均衡设备进行TCP连接，**然后负载均衡设备再与后端服务器建立另外一条TCP连接通道**。因此，七层设备在网络性能损耗会更多一些。
  * ![7层均衡负载](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251807298.PNG)
* 二层负载均衡：还有基于MAC地址信息(虚拟MAC地址到真实MAC地址)进行转发
* 三层负载均衡：基于IP地址(虚拟IP到真实IP)

**如何选择？从安全性的角度来看**

* 四层负载均衡与服务器直接建立起TCP连接，很容易遭受 SYN Flood 攻击。SYN Flood 是一种广为人知的 DDoS（Distributed Denial of Service，分布式拒绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽的攻击方式。

  > 后续有分析

* 从技术实现原理上可以看出，四层负载均衡很容易将垃圾流量转发至后台服务器，而七层设备则可以过滤这些恶意并清洗这些流量，但要求设备本身具备很强的抗 DDoS 流量的能力。

> 参考：
>
> https://blog.csdn.net/rocling/article/details/82954327
>
> https://zhuanlan.zhihu.com/p/34904010

### DDoS 攻击：SYN Flood

SYN Flood 攻击利用了 TCP 协议的缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能**造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问**。

攻击数据报的特征：攻击源发送了大量的SYN包，并且缺少三次握手的最后一步握手 ACK 回复

**攻击原理**：

1. 攻击者首先伪造地址对服务器发起 SYN 请求 （第一次握手报文：我可以建立连接吗？）
2. 服务器就会回应一个 ACK+SYN（第二次握手报文：可以+请确认）
3. 攻击者不做回应，服务器没有收到回应，会重试 3-5 次并且等待一个 SYN Time（一般30秒-2分钟）后，丢弃这个连接。

如果攻击者大量发送这种伪造源地址的 SYN 请求，服务器端将会消耗非常多的资源来处理这种半连接，保存遍历会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的 IP 进行 SYN+ACK 的重试；且半连接队列默认为1024，当队列被占满时，如果没有任何防护措施，后续无法建立连接无法响应正常的请求。最后的结果是服务器无暇理睬正常的连接请求：拒绝服务。

**如何防御**：

* **cookie源认证**：原理是 SYN 报文首先由 DDoS 防护系统来响应 SYN+ACK。带上特定的 sequence number（记为cookie）。真实的客户端会返回一个 ACK 并且 acknowledgment number 为 cookie+1。 而伪造的客户端，将不会作出响应。
* **reset认证**：Reset 认证利用的是 TCP 协议的可靠性，也是首先由 DDoS 防护系统来响应 SYN。防护设备收到 SYN 后响应 SYN+ACK，将acknowledgement number（确认号）设为特定值（记为cookie）。当真实客户端收到这个报文时，发现确认号不正确，将发送 reset 报文，并且sequence number 为 cookie。而伪造的源，将不会有任何回应。
* **TCP首包丢弃**：该算法利用了 TCP/IP 协议的重传特性，来自某个源 IP 的第一个 SYN 包到达时被直接丢弃并记录状态，在该源 IP 的第2个 SYN 包到达时进行验证，然后放行。但是：首包丢弃方案对用户体验会略有影响，因为丢弃首包重传会增大业务的响应时间。

> 参考：https://blog.csdn.net/qq_34777600/article/details/81946514