# 面经：1-操作系统:pray:

> 个人整理 :muscle: 个人专用 :muscle: 暑期实习 :muscle: 秋招 :muscle: 后端开发 :muscle: 八股文 :no_mouth:

### 对并发和并行的理解

1. 并行是指两个或者多个事件在**同一时刻**发生；而并发是指两个或多个事件在**同一时间间隔**发生；
2. 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；

### 同步 & 异步 & 阻塞 & 非阻塞概念:exclamation:

同步和异步关注的是消息通信机制：

* **同步**：当一个同步调用发出后，调用者要一直等待返回结果。即：调用者主动等待这个调用的结果。

* **异步**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**

* **阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。

* **非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。

### 进程 & 线程的基本概念:exclamation::exclamation::exclamation:

**总结：进程是操作系统进行资源分配和调度的最小单位，而线程是 CPU 分派和调度的最小单位**；

**进程**：

- 进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。 
- 在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。 

**线程：**

* 线程是进程的一个实体，也是 **CPU 调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程。

### 进程 & 线程的区别:exclamation::exclamation::exclamation:

- **进程是操作系统进行资源分配和调度的最小单位，而线程是 CPU 分派和调度的最小单位**；

- 进程基本上相互独立的，进程间不会相互影响；而线程存在于进程内，是进程的一个子集，一个线程挂掉将可能导致整个进程挂掉；

- 不同进程地址空间相互独立；而同一进程内的线程共享进程内部的地址空间；

  > 在 Java 中多个线程共享进程的堆和方法区资源，但**每个线程有自己的程序计数器、 虚拟机栈和本地方法栈**，所以系统在产生⼀个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 

- 进程间通信较为复杂；线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量；
  - 同一台计算机的进程通信称为 IPC（Inter-process communication）
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
  
- 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；

- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低；

### 有了进程还要线程的原因:exclamation:

进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：

1. 进程在同一时间只能干一件事情；
2. 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

基于以上的缺点，操作系统引入了比进程粒度更小的线程，**作为并发执行的基本单位**，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。

### 进程的状态转换

进程包括三种状态：就绪态、运行态和阻塞态。

![进程的状态](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806210.png)

1. **就绪 => 执行**：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；
2. **执行 => 阻塞**：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如：进程提出输入/输出请求而变成等待外部设备传输信息的状态；进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态；进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 
3. **阻塞 => 就绪**：处于阻塞状态的进程，在其等待的事件已经发生，如：输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；
4. **执行 => 就绪**：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中，当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

### 进程间的通信方式:exclamation::exclamation:

进程间通信（IPC，Inter-Process Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。

**管道 pipe**

1. 它是**半双工的**，具有固定的读端和写端；
2. 它**只能用于父子进程或者兄弟进程之间的进程的通信**；
3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**命名管道 named pipe**

1. 可以**在无关的进程之间交换数据**，与无名管道不同；
2. 有路径名与之相关联，它以**一种特殊设备文件**形式存在于文件系统中。

**消息队列 message queue**

1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；
2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
3. 消息队列独立于发送与接收进程。发送/接受进程终止时，消息队列及其内容并不会被删除；
4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

**信号量 semaphore**

1. 信号量是一个计数器。**用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；**
2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
3. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；
4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；
5. 支持信号量组。

> PV 操作：是一种实现进程互斥与同步的有效方法。PV 操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。
>
> https://baike.baidu.com/item/PV%E6%93%8D%E4%BD%9C/122128?fr=aladdin

**共享内存 Shared Memory**

1. 共享内存，指两个或多个进程共享一个给定的存储区；
2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

### 进程的调度算法:exclamation::exclamation::exclamation:

调度算法是指：**根据系统的资源分配策略所规定的资源分配算法**。常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先调度算法、高响应比优先调度算法、优先级调度算法等等。

**先来先服务调度算法**：

* 先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。**当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。**

**时间片轮转调度算法**

* 时间片轮转调度算法主要适用于**分时系统**。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，**但仅能运行一个时间片**。

**短作业优先调度算法**

* 短作业优先调度算法是指对短作业优先调度的算法，从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。短作业优先调度算法是一个**非抢占策略，他的原则是下一次选择预计处理时间最短的进程**，因此短进程将会越过长进程，跳至队列头。

**最短剩余时间优先调度算法**

* 最短剩余时间是针对最短进程优先**增加了抢占机制的版本**。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，**调度程序就能可能抢占当前正在运行的进程**。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。  

**高响应比优先调度算法**

* 高响应比优先调度算法主要用于作业调度，该算法是对**先来先服务调度算法和短作业优先调度算法的一种综合平衡**，同时考虑每个作业的等待时间和估计的运行时间。**在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行**。

**优先级调度算法**

* 优先级调度算法每次从后备作业队列中**选择优先级最髙**的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

### 死锁:exclamation::exclamation:

死锁，是指**多个进程在运行过程中因争夺资源而造成的一种僵局**，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。

![死锁](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206251806062.jpg)

### 产生死锁的原因:exclamation:

由于系统中存在一些**不可剥夺资源**，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。

- **竞争资源**

  > 例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞

  系统中的资源可以分为两类：

  1. **可剥夺资源**：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源；
  2. **不可剥夺资源**，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

- **进程推进顺序不当**

  > 例如：进程 A 和 进程 B 互相等待对方的数据。

### 死锁产生的必要条件:exclamation:

1. **互斥条件**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一个进程所占用。
2. **请求和保持条件**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不可剥夺条件**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. **环路等待条件**：在发生死锁时，必然存在一个"进程--资源"的环形链。

### 解决死锁的基本方法:exclamation:

**预防死锁**

1. **破坏请求条件**：一次性分配所有资源，这样就不会再有请求了；
2. **破坏保持条件**：只要有一个资源得不到分配，就不给这个进程分配其他的资源：
3. **破坏不可剥夺条件**：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；
4. **破坏环路等待条件**：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。

**避免死锁**

1. **银行家算法**

   当进程首次申请资源时，要**测试该进程对资源的最大需求量**，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。

   当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。

2. **安全序列**

   是指系统能按某种进程推进顺序（P1, P2, P3, ..., Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列（银行家算法的核心就是找到一个安全序列）。

3. **系统安全状态** 

   如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态。

**检测死锁**

* 通过相应的方法进行检测

**解除死锁**

1. **资源剥夺**：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
2. **撤销进程**：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
3. **进程回退**：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

### 缓冲区溢出及危害

缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。

计算机中，缓冲区溢出会造成的危害主要有以下两点：

* 程序崩溃导致拒绝服务；
* 跳转并且执行一段恶意代码。

### 分页 & 分段的区别

1. **段是信息的逻辑单位**，它是根据用户的需要划分的，因此段对用户是可见的；**页是信息的物理单位**，是为了管理主存的方便而划分的，对用户是透明的；
2. 段的**大小不固定**，由它所完成的功能决定；页的**大小固定**，由系统决定；
3. 段向用户提供**二维地址空间**；页向用户提供的是**一维地址空间**；
4. 段是信息的**逻辑单位**，便于存储保护和信息的共享，页的保护和共享受到限制。

### 物理地址 & 逻辑地址 & 虚拟内存的概念 :exclamation:

1. **物理地址**：它是地址转换的**最终地址**，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
2. **逻辑地址**：是指计算机**用户看到的地址**。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。
3. **虚拟内存**：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

### 页面置换算法:exclamation::exclamation:

请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。

而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。

为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以**尽量达到较低的错误率**。

常用的页面置换算法如下：

- **先进先出置换算法（FIFO）**

  先进先出，即淘汰最早调入的页面。

- **最佳置换算法（OPT，Optimal Page Replacement）**

  选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。

- **最近最久未使用（LRU，Least Recently Used）算法**

  即选择最近最久未使用的页面予以淘汰

- **时钟（Clock）置换算法**

  时钟置换算法也叫最近未用算法 NRU（Not Recently Used）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。

### 动态链接库 & 静态链接库

静态链接就是在编译链接时**直接将需要的执行代码拷贝到调用处**，优点就是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。

动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，**最终达到运行时连接的目的**。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。
