# 数据结构与算法：树结构之查找树

> 早先通过 《大话数据结构》学习了数据结构的知识，后续通过 Bilibili UP主 [黑马程序员](https://space.bilibili.com/37974444?spm_id_from=333.788.b_765f7570696e666f.2) 的两套视频又回顾了一遍，然后对其中的内容做了些笔记如下文所示。

## 2-3 查找树

### 概述

将一棵标准的二叉查找树中的结点称为**2-结点(含有一个键和两条链)**，而现在引入**3-结点，它含有两个键和三条链**。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。 

一棵2-3查找树要么为空，要么满足满足下面两个要求： 

- **2-结点**： 

  含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 

- **3-结点**：

  含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 

![2-3树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146663.PNG)

### 性质

2-3树在插入/删除的时候，需要做一些局部的变换来保持2-3树的平衡，后续对其进行图解

一棵完全平衡的2-3树具有以下性质：

1. **任意空链接到根结点的路径长度都是相等的**。
2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，**分解根结点时，树高+1**。
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是**自底向上生长**。 

### 查找 & 插入

**查找**

- 文字说明

  将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。 

- 图解

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146129.PNG" alt="2-3树查找" style="zoom: 67%;" />

**插入**

- 文字说明

  往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点麻烦。 

- **图解：向2-结点中插入新键**

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147123.PNG" alt="2-3树插入" style="zoom:67%;" />

- **图解：向一棵只含有一个3-结点的树中插入新键** 

  假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素，**暂时使其变成一个4-结点**，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146351.PNG" alt="2-3树插入2" style="zoom:67%;" />

- **图解：向一个父结点为2-结点的3-结点中插入新键** 

  和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146455.PNG" alt="2-3树插入3" style="zoom:67%;" />

- **图解：向一个父结点为3-结点的3-结点中插入新键** 

  当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点，插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其变为3-结点，不需要继续进行拆分。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146074.PNG" alt="2-3树插入4" style="zoom:67%;" />

- **图解：分解根结点** 

  当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146782.PNG" alt="分解根节点" style="zoom:67%;" />

## 红黑树 :exclamation:

### 概述

> 上述分析的 2-3 树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为 logN，相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以这里**介绍一种2-3树思想的简单实现：红黑树**。 

红黑树主要是对2-3树进行编码，红黑树背后的基本思想是**用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树**。我们将树中的链接分为两种类型： 

**红链接：将两个2-结点连接起来构成一个3-结点；** 

**黑链接：则是2-3树中的普通链接，即2-结点。** 

确切的说，我们将3-结点表示为由一条**左斜**的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们**无需修改就可以直接使用标准的二叉查找树的get方法**。 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146725.PNG" alt="红黑树" style="zoom:67%;" />

**定义**

红黑树是含有红黑链接并满足下列条件的二叉查找树： 

1. **红链接均为左链接**；
2. 没有任何一个结点**同时和两条红链接相连**；
3. 该树是**完美黑色平衡的**，即任意空链接到根结点的路径上的黑链接数量相同； 

下面是红黑树与2-3树的对应关系： 

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146910.PNG" alt="红黑树与2-3关系" style="zoom:67%;" />

### 结点实现

因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的**Node结点中添加一个布尔类型的变量color来表示链接的颜色**。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为 false

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146535.PNG" alt="红黑树2" style="zoom:67%;" />

**API设计：** 

| 类名     | Node<Key, Value>                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | `Node(Key key, Value value, Node left, Node right, boolean color)`：创建Node对象 |
| 成员变量 | 1.`public Node left`:记录左子结点 <br />2.`public Node right`:记录右子结点 <br />3.`public Key key`:存储键 <br />4.`public Value value`:存储值 <br />5.`public boolean color`:**由其父结点指向它的链接的颜色** |

**代码：** 

```java
private class Node{
    // 存储键
    public Key key;
    // 存储值
    public Value value;
    // 记录左子结点
    public Node left;
    // 记录右子结点
    public Node right;
    // 由其父结点指向它的链接的颜色
    public boolean color;

    public Node(Key key, Value value, Node left, Node right, boolean color) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        this.color = color;
    }
}

```

### 平衡化

在对红黑树进行一些增删改查的操作后，很有可能会出现：

1. 红色的右链接；
2. 两条连续红色的链接；

而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。

**左旋**

- **情况**：当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。 

- **前提：**当前结点为h，它的右子结点为x；

- **左旋过程：** 

  1. 让x的左子结点变为h的右子结点：`h.right=x.left;`
  2. 让h成为x的左子结点：`x.left=h;`
  3. 让x的color属性变为h的color属性值：`x.color=h.color;`
  4. 让h的color属性变为RED：`h.color=true;`

- **图解**：

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146129.PNG" alt="左旋" style="zoom:67%;" />

**右旋**

- **情况**：当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋 

- **前提：**当前结点为h，它的左子结点为x；

- **右旋过程：**

  1. 让x的右子结点成为h的左子结点：`h.left = x.right;`
  2. 让h成为x的右子结点：`x.right=h;`
  3. 让x的color变为h的color属性值：`x.color = h.color;`
  4. 让h的color为RED；

  > 这时候也是不满足的，还需要进行调整，即需要进行颜色变换，后续有说明

- **图解**：

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146135.PNG" alt="右旋" style="zoom:67%;" />

### 插入操作

**向单个2-结点中插入新键** 

- 一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。

  - 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。 

    <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146141.PNG" alt="红黑树插入1" style="zoom:67%;" />

  - 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红色链接。 

    <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146669.PNG" alt="红黑树插入2" style="zoom:67%;" />

**向底部的2-结点插入新键**

- 用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146210.PNG" alt="红黑树插入3" style="zoom:67%;" />

**颜色反转** 

- 当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146747.PNG" alt="红黑树插入4" style="zoom:67%;" />

**向一棵双键树(即一个3-结点)中插入新键** 

- 这种情况有可以分为三种子情况： 

  1. 新键大于原树中的两个键

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146140.PNG" alt="红黑树插入5" style="zoom:67%;" />

  2. 新键小于原树中的两个键 

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146114.PNG" alt="红黑树插入6" style="zoom:67%;" />

  3. 新键介于原数中两个键之间

     <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146521.PNG" alt="红黑树插入7" style="zoom:67%;" />

**根结点的颜色总是黑色**

- 在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。 

**向树底部的3-结点插入新键**

- 假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点为止。 

  <img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146329.PNG" alt="红黑树插入8" style="zoom:67%;" />

### 代码实现

| 类名     | `RedBlackTree<Key extends Comparable<Key>, Value>`           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | `RedBlackTree()`:创建RedBlackTree对象                        |
| 成员方法 | 1.`private boolean isRed(Node x)`:判断当前结点的父指向链接是否为红色 <br />2.`private Node rotateLeft(Node h)`:**左旋调整** <br />3.`private Node rotateRight(Node h)`:**右旋调整** <br />4.`private void flipColors(Node h)`：**颜色反转**,相当于完成拆分4-结点 <br />5.`public void put(Key key, Value val)`:在整个树上完成插入操作 <br />6.`private Node put(Node h, Key key, Value val)`:在指定树中，完成插入操作,并返回添加元素后新的树 <br />7.`public Value get(Key key)`:根据key，从树中找出对应的值 <br />8.`private Value get(Node x, Key key)`:从指定的树x中，找出key对应的值 <br />9.`public int size()`:获取树中元素的个数 |
| 成员变量 | 1.`private Node root` : 记录根结点 <br />2.`private int N`:记录树中元素的个数 <br />3.`private static final boolean RED`：红色链接标识 <br />4.`private static final boolean BLACK`:黑色链接标识 |

```java
public class RedBlackTree <Key extends Comparable<Key>, Value> {

    // 根节点
    private Node root;
    // 记录树中元素的个数
    private int N;
    // 红色链接
    private static final boolean RED=true;
    // 黑色链接
    private static final boolean BLACK=false;


    // 结点类
    private class Node{
        // 存储键
        public Key key;
        // 存储值
        public Value value;
        // 记录左子结点
        public Node left;
        // 记录右子结点
        public Node right;
        // 由其父结点指向它的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

    // 获取树中元素的个数
    public int size(){
        return this.N;
    }

    /**
     * 判断当前节点的父指向链接是否为红色
     *
     * @param x
     * @return
     */
    private boolean isRed(Node x){
        if(x == null){
            return false;
        }
        return x.color==RED;
    }

    /**
     * 左旋转
     *
     * @param h
     * @return
     */
    private Node rotateLeft(Node h){
        // 找到h结点的右子结点x
        Node x = h.right;
        // 找到x结点的左子结点，让x结点的左子结点成为h结点的右子结点
        h.right = x.left;
        // 让h结点称为x结点的左子结点
        x.left = h;
        // 让x结点的color属性变为h结点的color属性
        x.color = h.color;
        // 让h结点的color属性变为RED
        h.color = RED;

        return x;
    }

    /**
     * 右旋
     *
     * @param h
     * @return
     */
    private Node rotateRight(Node h){
        // 找到h结点的左子结点 x
        Node x = h.left;
        // 让x结点的右子结点成为h结点的左子结点
        h.left = x.right;
        // 让h结点成为x结点的右子结点
        x.right = h;
        // 让x结点的color属性变为h结点的color属性
        x.color = h.color;
        // 让h结点的color属性为RED
        h.color = RED;

        return x;
    }

    /**
     * 颜色反转,相当于完成拆分4-节点
     *
     * @param h
     */
    private void flipColors(Node h){
        // 当前结点变为红色
        h.color = RED;
        // 左子结点和右子结点变为黑色
        h.left.color = BLACK;
        h.right.color = BLACK;
    }

    /**
     * 在整个树上完成插入操作
     *
     * @param key
     * @param val
     */
    public void put(Key key, Value val){
        root = put(root, key, val);
        // 根结点的颜色总是黑色
        root.color = BLACK;
    }

    /**
     * 在指定树中，完成插入操作,并返回添加元素后新的树
     *
     * @param h
     * @param key
     * @param val
     */
    private Node put(Node h, Key key, Value val){
        // 判断h是否为空，如果为空则直接返回一个红色的结点就可以了
        if(h == null){
            //数量+1
            N++;
            return new Node(key, val, null, null, RED);
        }

        // 比较h结点的键和key的大小
        int cmp = key.compareTo(h.key);

        if (cmp < 0){
            // 继续往左
            h.left = put(h.left, key, val);
        }else if(cmp > 0){
            // 继续往右
            h.right = put(h.right, key, val);
        }else{
            // 发生值的替换
            h.value = val;
        }

        // 进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }
        // 进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        // 颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        return h;
    }

    // 根据key，从树中找出对应的值
    public Value get(Key key){
        return get(root, key).value;
    }

    // 从指定的树x中，查找key对应的值
    private Node get(Node n, Key key){
        if (n==null){
            return null;
        }

        // 比较x结点的键和key的大小
        int cmp = key.compareTo(n.key);
        if(cmp > 0){
            return get(n.right, key);
        }else if(cmp < 0){
            return get(n.left, key);
        }else {
            return n;
        }
    }

    public static void main(String[] args) {

        RedBlackTree<String, String> tree = new RedBlackTree<>();

        // 往树中插入元素
        tree.put("1","张三");
        tree.put("2","李四");
        tree.put("3","王五");

        // 从树中获取元素
        String r1 = tree.get("1");
        System.out.println(r1);


        String r2 = tree.get("2");
        System.out.println(r2);

        String r3 = tree.get("3");
        System.out.println(r3);
    }
}

```

## 红黑树 vs AVL树 :exclamation::exclamation:

1. **红黑树并不追求“完全的平衡”**，它只要求达到部分的平衡，降低了对旋转的要求，从而提高了性能，但也是由于其平衡要求不如 AVL 树严格，因此理论上查找要慢些，实际也如此，不过差距并不大
2. 红黑树能够以 O(log2n) 的时间复杂度进行搜索/插入/删除操作，由于它的设计，**任何不平衡都会在三次旋转之内解决**。
3. 还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，**但红黑树能够给我们一个比较“便宜”的解决方案**。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高

**总结**

1. **查找比较**

   显然，AVL树 要比红黑树更平衡，因此 AVL树 的查找效率更高

   > AVL 树满足：
   >
   > 1. 可以是空树。
   > 2. 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1**

2. **插入比较**

   如果插入一个节点引起了树的不平衡，AVL 和 红黑树 都是**最多只需要2次旋转操作**，即两者都是O(1)

3. **删除比较**

   在删除节点引起树的不平衡时，最坏情况下，AVL 需要维护从被删节点到根节点这条路径上所有节点的平衡性，**因此需要旋转的量级 O(logN)，而红黑树最多只需3次旋转，只需要O(1)的复杂度**。

AVL 的结构相较 红黑树 来说更为平衡，**在插入和删除节点更容易引起树的不平衡**，因此在大量数据需要插入或者删除时，**AVL 需要调整的频率会更高**。因此，红黑树在需要大量插入和删除节点的场景下，效率更高。自然，由于 AVL 高度平衡，因此 AVL 的查找效率更高。

红黑树的查询性能略微逊色于 AVL，因为他比 AVL 会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的 AVL 最多多一次比较。但是，红黑树在插入和删除上完爆 AVL，AVL 树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于 AVL 为了维持平衡的开销要小得多。

> 参考：[数据结构-AVL树和红黑树的对比](https://blog.csdn.net/tiankong_/article/details/77150798?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)

## B 树

### 概述

> 在前面提到的 2-3 树中，一个结点最多能有两个 key，它的实现红黑树中使用对链接染色的方式去表达这两个 key。在B树这种数据结构中，**一个结点允许多于两个 key 的存在**。 

B树是一种树状数据结构，它能够存储数据，对其进行排序并允许以 O(logn) 的时间复杂度进行查找、顺序读取、插入和删除等操作。

### 特性

B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点： 

- 每个结点最多有**M-1个key**，并且以升序排列；
- 每个结点最多能有**M个子结点**；
- 根结点至少有两个子结点； 

![B树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146835.PNG)

在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。

### B树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。 

![B树存储数据](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146313.PNG)

## B+树

### 概述

B+树是对B树的一种变形树，它与B树的差异在于：

1. **非叶结点仅具有索引作用**，也就是说，非叶子结点只存储key，不存储value；
2. **树的所有叶结点构成一个有序链表**，可以按照key排序的次序遍历全部数据。 

### B+树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。 

![B+树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146933.PNG)

### B+树和B树的对比

**B+ 树的优点在于：**

1. 由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此**在内存相同的情况下，能够存放更多的key**。 
2. B+树的叶子结点都是相连的，因此**对整棵树的遍历只需要依次线性遍历叶子结点即可**。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

**B树的优点在于：**

- 由于B树的每一个节点都包含key和value，因此我们根据key查找value时，**只需要找到key所在的位置，就能找到value**；
- 但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。 

