# 数据结构与算法：树结构之二叉树

> 总结一下**数据结构：树**这一结构，本文主要针对于树结构中的二叉树这一特殊类型。

## 概述

树是由n(n>0)个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

树具有以下特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

**节点的高度**：节点到叶子节点的最长路径(边数)，所有叶子节点的高度为 0。

**节点的深度**：根节点到这个节点所经历的边的个数，根的深度为 0。

**节点的层数**：节点的深度+1

**树的高度**：根节点的高度

## 二叉树

### 概述

**基础定义**：二叉树就是度不超过2的树（每个结点最多有两个子结点）

**满二叉树：**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 

**完全二叉树：** 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树（最下层可以存在左满右不满的情况）

> 堆结构就是一种完全二叉树的结构，可以看上述堆排序内容

### 二叉树遍历

**前序遍历，中序遍历，后续遍历**

前序遍历（根-左-右）：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历（左-根-右）：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后序遍历（左-右-根）：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

遍历二叉树的时间复杂度跟二叉树节点的个数 n 成正比，因此，**二叉树遍历的时间复杂度是O(n)**。

## 二叉查找树

### 概述 :exclamation:

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**

详细可以分为以下 4点：

1. **若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；**
2. **若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；**
3. **任意节点的左、右子树也分别为二叉查找树；**
4. **没有键值相等的节点。**

**二叉查找树支持动态数据的快速插入，删除，查找操作**

### 二叉查找树基础操作

#### 查找 & 插入 & 删除

**查找节点操作**：

从根节点开始：

1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

![二叉查找树查找](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147629.PNG)

**插入节点操作**：

1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
2. 如果当前树不为空，则从根结点开始：
   1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
   2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
   3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 

![二叉树插入](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147925.PNG)

**删除节点操作**：

删除操作总结下来有三种情况：

1. **要删除的节点是叶子节点**即没有子节点，我们只需将父节点中指向该节点的指针置为 null 即可，这是最简单的一种形式。比如删除图中的节点 10
2. **要删除的节点只有一个子节点**(只有左子节点或者只有右子节点)，我们只需要更新父节点中指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如删除图中的节点 38
3. **要删除的节点有两个子节点**，这是最复杂的一种情况，我们需要找到这个节点的**右子树中的最小节点**，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如删除图中的节点 25

![二叉树删除2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147130.PNG)

#### 代码实现

```java
public class BinaryTree<Key extends Comparable<Key>, Value> {

    // 记录根结点
    private Node root;
    // 记录树中元素的个数
    private int N;
	
    // 节点类的定义
    private class Node{
        // 存储键
        public Key key;
        // 存储值
        public Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
	
    // 默认构造函数
    public BinaryTree() {
        this.N = 0;
    }

    // 获取树中元素的个数
    public int size(){
        return N;
    }

    // 插入节点操作：向树中添加元素key-value
    public void put(Key key, Value val){
        root = put(root, key, val);
    }

    // 向指定的树x中添加key-value,并返回添加元素后新的树
    private Node put(Node x, Key key, Value value){
        // 如果x子树为空
        if(x == null){
            // 树节点个数+1
            N++;  
            x = new Node(key, value, null, null);
            return x;
        }

        // 如果x子树不为空
        // 比较key和x结点的key的大小：Comparable接口中的compareTo函数一般实现逻辑为：大于0说明我比你大，等于0说明相等，小于0说明我比你小
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            // 如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right, key, value);
        }else if(cmp < 0){
            // 如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left, key, value);
        }else{
            // 如果key等于x结点的键，则替换x结点的值为value即可
            x.value = value;
        }
        return x;
    }

    // 查询节点操作：查询树中指定key对应的value
    public Value get(Key key){
        return get(root, key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key){

        //如果x子树为空
        if(x == null){
            return null;
        }

        //如果x子树不为空
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right, key);
        }else if(cmp < 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.left, key);
        }else{
            //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可
            return x.value;
        }
    }

    // 删除节点操作：删除树中key对应的value
    public void delete(Key key){
        root = delete(root, key);
    }

    // 删除指定树x中的key对应的value，并返回删除后的新树
    private Node delete(Node x, Key key){
        // x树为null，没有要删除的节点，直接返回
        if (x==null){
            return null;
        }

        // 如果x子树不为空 先找到要删除的节点
        // 比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            // 如果key大于x结点的键，则继续找x结点的右子树
            x.right = delete(x.right, key);
        }else if(cmp < 0){
            // 如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left, key);
        }else{
            // 如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；
            // 让元素个数-1
            N--;
            // ☆得找到右子树中最小的结点☆
            if(x.right == null){
                // 当结点没有右节点 直接返回它的左节点
                return x.left;
            }

            if(x.left == null){
                // 当结点没有左节点 直接返回它的右节点
                return x.right;
            }

            // 当左右节点都存在时，☆寻找右子树的最左节点☆
            Node minNode = x.right;
            // 删除右子树中最小的结点
            Node n = x.right;  // n为minNode节点的父节点
            while (minNode.left != null){
                minNode = minNode.left;
                if(n.left.left != null){
                    // 使n一直是minNode的父节点
                    n = n.left;
                }
            }
            // minNode的父节点n，断开n的左子节点minNode的连接
            n.left = null;

            // 让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            // 让x结点的父结点指向minNode，在返回的时候会改变指向
            x = minNode;
        }
        return x;
    }
}

// 测试代码
public class BinaryTreeTest {

    public static void main(String[] args) {

        // 创建二叉查找树对象
        BinaryTree<Integer, String> tree = new BinaryTree<>();

        // 测试插入
        tree.put(1,"张三");
        tree.put(2,"李四");
        tree.put(3,"王五");

        // 测试获取
        System.out.println("键2对应的元素是："+tree.get(2));

        // 测试删除
        tree.delete(3);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键3对应的元素:"+tree.get(3));

        tree.delete(1);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键2对应的元素:"+tree.get(2));

        tree.delete(2);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键1对应的元素:"+tree.get(1));
    }
}
```

### 二叉查找树遍历

#### DFS

**深度优先遍历dfs**：二叉树的遍历同样可以分为以下三种方式：

1. **前序遍历：**先访问根结点，然后再访问左子树，最后访问右子树 
2. **中序遍历：**先访问左子树，中间访问根节点，最后访问右子树 
3. **后序遍历：**先访问左子树，再访问右子树，最后访问根节点 

在上述代码中添加**前序遍历、中序遍历、后序遍历**的代码

- **前序遍历：**

  1. 把当前结点的key放入到队列中;
  2. 找到当前结点的左子树，如果不为空，递归遍历左子树
  3. 找到当前结点的右子树，如果不为空，递归遍历右子树 

  ```java
  // 前序遍历获取整个树中所有的键
  public Queue<Key> preOrder(){
      Queue<Key> keys = new LinkedList<>();
      preOrder(root, keys);
      return keys;
  }
  
  // 获取指定树x的所有键，并放到keys队列中
  private void preOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先处理自身：把x结点的key放入到keys中
      keys.offer(x.key);
  
      // 再处理左节点：递归遍历x结点的左子树
      if (x.left != null){
          preOrder(x.left, keys);
      }
  
      // 再处理右节点：递归遍历x结点的右子树
      if(x.right != null){
          preOrder(x.right, keys);
      }
  }
  ```

- **中序遍历：**二叉查找树的中序遍历的结果是有序的

  1. 找到当前结点的左子树，如果不为空，递归遍历左子树
  2. 把当前结点的key放入到队列中;
  3. 找到当前结点的右子树，如果不为空，递归遍历右子树

  ```java
  // 中序遍历获取整个树中所有的键
  public Queue<Key> inOrder(){
      Queue<Key> keys = new LinkedList<>();
      inOrder(root, keys);
      return keys;
  }
  
  //获取指定树x的所有键，并放到keys队列中
  private void inOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先递归，把左子树中的键放到keys中
      if (x.left != null){
          inOrder(x.left, keys);
      }
  
      // 把当前结点x的键放到keys中
      keys.offer(x.key);
  
      // 在递归，把右子树中的键放到keys中
      if(x.right != null){
          inOrder(x.right, keys);
      }
  }
  ```

- **后序遍历：**

  1. 找到当前结点的左子树，如果不为空，递归遍历左子树
  2. 找到当前结点的右子树，如果不为空，递归遍历右子树
  3. 把当前结点的key放入到队列中; 

  ```java
  // 后序遍历获取整个树中所有的键
  public Queue<Key> postOrder(){
      Queue<Key> keys = new LinkedList<>();
      postOrder(root, keys);
      return keys;
  }
  
  // 获取指定树x的所有键，并放到keys队列中
  private void postOrder(Node x, Queue<Key> keys){
      if(x == null){
          return;
      }
  
      // 先递归，把左子树中的键放到keys中
      if (x.left != null){
          postOrder(x.left, keys);
      }
  
      // 在递归，把右子树中的键放到keys中
      if(x.right != null){
          postOrder(x.right, keys);
      }
  
      // 把当前结点x的键放到keys中
      keys.offer(x.key);
  }
  ```

#### BFS

**广度优先遍历bfs**：层序遍历

1. 创建队列，存储每一层的结点；
2. 使用循环从队列中弹出一个结点：
   1. 获取当前结点的key；
   2. 如果当前结点的左子结点不为空，则把左子结点放入到队列中
   3. 如果当前结点的右子结点不为空，则把右子结点放入到队列中

```java
// 使用层序遍历，获取整个树中所有的键
public Queue<Key> layerErgodic(){

    // 存储树中的键和树中的结点
    Queue<Key> keys = new Queue<>();
    Queue<Node> nodes = new Queue<>();

    // 默认，往队列中放入根结点
    nodes.offer(root);
    while (!nodes.isEmpty()){
        // 当前层的节点数
        int size = nodes.size();
        for(int i=0; i<size; i++){
            // 从队列中弹出一个结点，把key放入到keys中
            Node n = nodes.poll();
            keys.offer(n.key);
            // 判断当前结点还有没有左子结点，如果有，则放入到nodes中
            if(n.left!=null){
                nodes.offer(n.left);
            }
            // 判断当前结点还有没有右子结点，如果有，则放入到nodes中
            if(n.right!=null){
                nodes.offer(n.right);
            }
        }
    }
    return keys;
}
```

### 其他操作

- 查找整个树中最小的键

  ```java
  // 查找整个树中最小的键
  public Key min(){
      return min(root).key;
  }
  
  // 在指定树x中找出最小键所在的结点
  public Node min(Node x){
      // 需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点
      if(x.left != null){
          return min(x.left);
      }else{
          return x;
      }
  }
  ```

- 在整个树中找到最大的键

  ```java
  // 在整个树中找到最大的键
  public Key max(){
      return max(root).key;
  }
  
  // 在指定的树x中，找到最大的键所在的结点
  public Node max(Node x){
      // 判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点
      if(x.right != null){
          return max(x.right);
      }else{
          return x;
      }
  }
  
  ```

- 求二叉树的最大深度

  1. 如果根结点为空，则最大深度为0；
  2. 计算左子树的最大深度；
  3. 计算右子树的最大深度；
  4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 

  ```java
  // 获取整个树的最大深度
  public int maxDepth(){
      return maxDepth(root);
  }
  
  // 获取指定树x的最大深度
  private int maxDepth(Node x){
      if (x==null){
          return 0;
      }
  
      // x的最大深度
      int max = 0;
      // 左子树的最大深度
      int maxL=0;
      // 右子树的最大深度
      int maxR=0;
  
      //计算x结点左子树的最大深度
      if(x.left != null){
          maxL = maxDepth(x.left);
      }
  
      //计算x结点右子树的最大深度
      if(x.right != null){
          maxR = maxDepth(x.right);
      }
  
      // 比较左子树最大深度和右子树最大深度，取较大值+1即可
      max = maxL > maxR ? maxL+1:maxR+1;
      return max;
  }
  ```

- **重复值处理**：对于有重复数据的二叉查找树，有两种方案：

  1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
  2. 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理，当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

  ![二叉树中有相同的值](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147530.PNG)

### 复杂度分析 :exclamation:

分析一下二叉查找树的查找，插入，删除的相关操作的时间复杂度

由于二叉查找树的形态各异，时间复杂度也不尽相同，根据下图的几棵树来看一下插入，查找，删除的时间复杂度

![不同形态的二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147136.PNG)

对于图中第一种情况属于最坏的情况，**二叉查找树已经退化成了链表**，左右子树极度不平衡，此时查找的**时间复杂度肯定是 O(n)**。

对于图中第二种或者第三种情况是属于一个比较理想的情况，我们代码的实现逻辑以及图中所示表明**插入，查找，删除的时间复杂度其实和树的高度成正比**，那也就是说时间复杂度为**O(height)**

**求一颗完全二叉树的高度**：

对于一棵满二叉树而言：树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从上图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 k 层包含的节点个数就是 2^(k-1)。

但是对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(k-1) 个之间（我们假设最大层数是 k）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：
$$
1+2+4+8+...+2^{(k-2)} +1 =< n <= 1+2+4+8+...+2^{(k-2)} +2^{(k-1)}
$$
这是一个等比数列，根据等比数列求和公式
$$
S= \frac{a_1-a_nq}{1-q},其中q是公比,a_n为数列的第n项，a_1为首项
$$
所以：我们利用求和公式对上述式子进行计算后得知，k 的取值范围为：
$$
log_2(n+1) \leq k \leq log_2(n) + 1
$$
推导得，也就是说完全二叉树的高度小于等于：**[log2n]+1**

> 还需要看书斟酌一番

通过我们的分析我们发现一棵极度不平衡的二叉查找树，它的查找性能和单链表一样。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这种特殊的二叉查找树也可以叫做**平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)**。

## 平衡二叉树(AVL)

#### 概述 :exclamation:

**平衡二叉查找树**：简称平衡二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的**高度平衡的二叉树**，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树，即其并且高度之差的绝对值不超过 1**

**对于给定结点数为n的AVL树，最大高度为O(log2n)**，也就说，从 n 个数中，查找一个特定值时，最多需要 log2n 次。因此，AVL 是一种特别适合进行查找操作的树。

#### 失衡及调整

在平衡二叉树中，当我们插入新的元素时，为了保证二叉搜索树的特性，很容易导致某些结点**失衡**，即该结点的平衡因子大于 1。

而在二叉树中，任意结点孩子最多只有左右两个，而且导致失去平衡的必要条件就是当前结点的两颗子树的高度差等于 2。因此，致使一个结点失衡的插入操作有以下 4 种

1. 在结点的左子树的左子树插入元素，LL 插入；
2. 在结点的左子树的右子树插入元素，LR 插入；
3. 在结点的右子树的左子树插入元素，RL 插入；
4. 在结点的右子树的右子树插入元素，RR 插入。

![avl树失衡的情况](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147613.PNG)

> LL插入(情况1)中结点 1 的插入导致结点 8 失衡，而插入的位置是在其左子树的左子树上，同样 LL(情况2）中，结点 3 插入同样导致结点 8 失衡，**这里需要注意子树是从受影响的结点算起，虽然 3 插在了右边，但他依旧是在 8（失衡结点）左子树的左子树上，因此属于 LL 插入。**
>
> LR(情况1)中结点 5 插入导致结点 8 失衡，插入位置是在其左子树的右子树上，同样 LR(情况2)结点 7 的插入也是同理，因此这二者都属于 LR 插入。

**面对以上4种失衡的情况，在AVL树中将采用LL(左左)，LR(左右)，RR(右右)和RL(右左)四种旋转方式进行调整。**

> 为了对这四种情况进行说明，我们先来定义 AVL 树的结构：
>
> AVL 树首先是二叉查找树，因此它的结点也必须是可比较。同时为了方便，加入一个表示当前结点高度的 height 字段，同时定义了返回节点高度和树的高度的方法，也定了一个返回两个高度中最大高度的方法。
>
> ```java
> public class AVLTree <T extends Comparable<T>>{
> 
>     // AVL树根节点，root节点
>     private AVLNode tree;
> 
>     // 获取某一节点的高度
>     public int height(AVLNode node){
>         // 特殊说明：这里的高度对于叶子节点而言，其高度其实为1
>         return node==null? 0: node.height;
>     }
> 
>     // 获取 avl 树的高度
>     public int height(){
>         return tree.height;
>     }
> 
>     // 返回两个高度中的最大值
>     private int getMax(int height1, int height2){
>         return height1>height2 ? height1 : height2;
>     }
> 
>     // 方法我们使用前中后序遍历的方式打印树
>     @Override
>     public String toString() {
>         System.out.println("前序遍历的结果:");
>         preOrder(tree);
>         System.out.println();
>         System.out.println("中序遍历的结果:");
>         inOrder(tree);
>         System.out.println();
>         System.out.println("后续遍历的结果:");
>         postOrder(tree);
>         System.out.println();
> 
>         return null;
>     }
> 
>     // 前序遍历
>     public void preOrder(AVLNode node){
>         if(node == null){
>             return;
>         }
>         System.out.print(node.data + "->");
>         preOrder(node.left);
>         preOrder(node.right);
>     }
> 
>     // 中序遍历
>     public void inOrder(AVLNode node){
>         if(node == null){
>             return;
>         }
>         preOrder(node.left);
>         System.out.print(node.data + "->");
>         preOrder(node.right);
>     }
> 
>     // 后续遍历
>     public void postOrder(AVLNode node){
>         if(node == null){
>             return;
>         }
>         preOrder(node.left);
>         preOrder(node.right);
>         System.out.print(node.data + "->");
>     }
> 
>     // 内部静态类，定义了avl树节点
>     private static class AVLNode<T extends Comparable<T>>{
>         // 节点中存储的数据
>         private T data;
>         // 左子树节点
>         private AVLNode<T> left;
>         // 右子树节点
>         private AVLNode<T> right;
>         // 节点的高度
>         private int height;
> 
>         public AVLNode(T data, AVLNode<T> left, AVLNode<T> right, int height) {
>             this.data = data;
>             this.left = left;
>             this.right = right;
>             this.height = height;
>         }
> 
>         public AVLNode(T data, AVLNode<T> left, AVLNode<T> right) {
>             this.data = data;
>             this.left = left;
>             this.right = right;
>         }
>     }
> }
> ```

**LL插入：右旋转调整**

- 图解：

  ![右旋调整](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147696.PNG)

- 代码实现

  ```java
  // LL插入：右旋转调整
  public AVLNode leftRotate(AVLNode node){
      // 定义临时变量保存 失衡节点的左子树 该节点也是左旋后的根节点
      AVLNode node_left = node.left;
      // 将失衡节点左子树的右子树作为失衡节点的左子树
      node.left = node_left.right;
      // 将失衡节点作为旋转后根节点的右子树
      node_left.right = node;
      // 重新计算失衡节点和旋转后根节点的高度
      node.height = getMax(height(node.left), height(node.right)) + 1;
      node_left.height = getMax(height(node_left.left), height(node_left.right)) + 1;
      return node_left;
  }
  ```

**RR插入：左旋转调整**

- 图解

  ![左旋调整](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147118.PNG)

- 代码实现

  ```java
  // RR插入：左旋转调整
  public AVLNode rightRotate(AVLNode node){
      // 定义临时变量保存右旋后的根节点 也就是失衡节点的右子树
      AVLNode node_right = node.right;
      // 将新的根节点的左子树当作失衡节点的右子树
      node.right = node_right.left;
      // 将失衡节点当作新的根节点的左子树
      node_right.left = node;
      // 重新计算失衡节点和新的根节点的高度
      node.height = getMax(height(node.left), height(node.right)) + 1;
      node_right.height = getMax(height(node_right.left), height(node_right.right)) + 1;
      return node_right;
  }
  ```

**LR插入：左右旋调整**

- 图解

  ![左右旋转](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147721.PNG)

- 代码实现

  ```java
  // LR插入：左右旋调整
  public AVLNode leftRightRotate(AVLNode node){
      node.left = rightRotate(node.left);
      return leftRotate(node);
  }
  ```

**RL插入：右左旋转**

- 图解

  ![右左旋转](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252147989.PNG)

- 代码实现

  ```java
  // RL插入：右左旋转
  public AVLNode rightLeftRotate(AVLNode node){
      node.right = leftRotate(node.right);
      return rightRotate(node);
  }
  ```

#### 插入节点调整

```java
// 插入操作
public void insert(T value){
    this.tree = insert(tree, value);
}

private AVLNode insert(AVLNode<T> node, T data){
    // 将data添加到node节点的子节
    if(node == null){
        node = new AVLNode<T>(data, null, null);
    }else{
        // 找到要插入的位置
        int compare = data.compareTo(node.data);
        if(compare > 0){
            // 要添加的值大于当前节点的值,将 data 存储到当前节点的右子树上
            // 递归的插入
            node.right = insert(node.right, data);
            //	如插入后 avl 树变得不平衡,则应该重新调节该树的结构---旋转
            if(height(node.right) - height(node.left) >= 2){
                //	判断是 RR 还是 RL
                if(data.compareTo(node.right.data) > 0){
                    // RR
                    node = rightRotate(node);
                }else{
                    node = rightLeftRotate(node);
                }
            }

        }else if(compare < 0){
            // 要添加的值小于当前节点的值,将 data 存储到当前节点的左子树上
            // 递归的插入
            node.left = insert(node.left, data);
            //	如插入后 avl 树变得不平衡,则应该重新调节该树的结构---旋转
            if(height(node.left) - height(node.right) >= 2){
                if(data.compareTo(node.left.data) < 0){
                    // LL
                    node = leftRotate(node);
                }else{
                    node = leftRightRotate(node);
                }
            }
        }else{
            // 要添加的值和该节点的值相同，不做处理
        }
    }

    // 计算节点 node 的高度
    // +1解释：hight为左右子树的双亲节点，故此处需要+1
    node.height = getMax(height(node.left), height(node.right)) + 1;
    return node;
}
```
