# 数据结构与算法：排序算法之堆排序

> 之前已经记录了常用的排序算法：[数据结构与算法：排序算法小记]()，这里对堆排序做一个补充
>
> 同样：该部分内容主要参考的是 [**黑马程序员**](https://space.bilibili.com/37974444/) 中对于数据结构的视频

## 堆排序

### 概述

堆的定义：堆是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满：

<img src="https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252145757.PNG" alt="大顶堆" style="zoom:50%;" />

本质上，二叉堆就是一颗特殊的完全二叉树，**父节点的权值不小于儿子的权值（大顶堆）**，即根节点就是最大值

通常用数组来堆进行实现：具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。

> 如果一个结点的位置为k，则它的父结点的位置为[k/2]，而它的两个子结点的位置则分别为2k和2k+1
>
> 这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层，就令k等于[k/2]，向下一层就令k等于2k或2k+1

核心的两个操作就是：**出堆/入堆**

#### 出堆操作

- 一个常见的操作是，**把根结点和最后一个结点交换**。但是新的根结点可能不满足 **父节点的权值不小于儿子的权值（大顶堆）**，这个时候，其实只需要将新的根节点**下沉**到正确位置即可，有如下：

  ![删除堆顶元素](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252145687.PNG)

- 时间复杂度分析：

  一个包含 n 个节点的完全二叉树，树的高度不会超过 [log2n]+1。堆化的过程是顺着节点所在路径比较交换的，所以**堆化的时间复杂度跟树的高度成正比，也就是O(logn)** 。插入数据和删除堆顶元素的主要逻辑就是堆化， 所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)

#### 入堆操作

- 入堆和出堆类似。我们可以直接往树的最后插入一个节点。再进行**上浮**操作，上浮**只需要拿当前节点和父节点进行比对就可以了，** 由于省去了判断左右子节点哪个更小的过程，因此更加简单。

  ![堆的插入实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252145361.PNG)

- 时间复杂度分析：往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)，具体见上述出堆的复杂度分析。

### 堆实现

#### 小顶堆

- **小顶堆**：父节点的值始终不大于子节点的值

```java
import java.util.Arrays;

public class Heap{

    // 堆
    private int[] datas;
    // 堆中已存储的元素个数
    private int size = 0;

    public Heap(int initialCapacity){
        if (initialCapacity < 1)
            throw new IllegalArgumentException();

        this.datas = new int[initialCapacity + 1];
    }

    public Heap(int[] array){
        this.size = array.length;
        this.datas = new int[array.length + 1];

        int i=1;
        for(int val: array){
            this.datas[i++] = val;
        }
    }

    // 向堆中插入元素
    public void push(int val){
        if(size == this.datas.length-1){
            // 扩容操作
            this.datas = Arrays.copyOf(this.datas, size*2 + 1);
        }
        this.datas[++size] = val;
        swim(size);
    }

    // 堆中取出元素
    public int peek(){
        return this.datas[1];
    }

    // 弹出堆中元素
    public int pop(){
        // 弹出堆顶元素
        int res = this.datas[1];
        // 移除完成后要保证堆的完整性，需要寻找第二大的元素放到堆顶
        // 1.将最后一个元素直接放在堆顶，并减少数据
        this.datas[1] = this.datas[size--];
        // 2.堆化让其继续成为一个合格的堆，此时需要自上而下堆化
        sink(1);

        return res;
    }

    // 建堆
    public void buildHeap(){
        // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (this.datas.length)/2; i > 0; i--) {
            sink(i);
        }
    }

    // 上浮操作
    private void swim(int end){
        int i = end;
        while( i/2 >0 && this.datas[i/2] > this.datas[i]){
            // 有父节点，且父节点的值大于该节点，则交换
            swap(i, i/2);
            i /= 2;
        }
    }

    // 下沉操作
    private void sink(int start){
        // 通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，
        // 如果当前结点大，则需要交换位置
        while (2*start <= size){

            int min;
            if(2*start+1 <= size){
                // 有右节点的情况
                if(this.datas[2*start] < this.datas[2*start+1]){
                    // 左节点更小
                    min = 2*start;
                }else{
                    // 右节点更小
                    min = 2*start+1;
                }
            }else{
                // 无右节点的情况
                min = 2*start;
            }

            // 与当前节点比较判断是否需要交换
            if(this.datas[start] < this.datas[min]){
                break;
            }
            // 需要交换
            swap(start, min);
            start = min;
        }
    }

    private void swap(int i, int j){
        int tmp = this.datas[i];
        this.datas[i] = this.datas[j];
        this.datas[j] = tmp;
    }

    public static void main(String[] args) {

        int arr[] = new int[]{2,7,4,1,8,1};
        Heap heap = new Heap(arr);
        heap.buildHeap();
        System.out.println(heap.peek());
        heap.push(5);
        heap.push(10);
        heap.push(3);
        while (heap.size > 0) {
            int num = heap.pop();
            System.out.printf(num + "");
        }
    }
}
```

#### 大顶堆

- **大顶堆**：父节点的值始终不小于子节点的值

```java
import java.util.Arrays;

public class Heap{

    // 堆
    private int[] datas;
    // 堆中已存储的元素个数
    private int size = 0;

    public Heap(int initialCapacity){
        if (initialCapacity < 1)
            throw new IllegalArgumentException();

        this.datas = new int[initialCapacity + 1];
    }

    public Heap(int[] array){
        this.size = array.length;
        this.datas = new int[array.length + 1];

        int i=1;
        for(int val: array){
            this.datas[i++] = val;
        }
    }

    // 向堆中插入元素
    public void push(int val){
        if(size == this.datas.length-1){
            this.datas = Arrays.copyOf(this.datas, size*2 + 1);
        }
        this.datas[++size] = val;
        swim(size);
    }

    // 堆中取出元素
    public int peek(){
        return this.datas[1];
    }

    // 弹出堆中元素
    public int pop(){
        // 弹出堆顶元素
        int res = this.datas[1];
        // 移除完成后要保证堆的完整性，需要寻找第二大的元素放到堆顶
        // 1.将最后一个元素直接放在堆顶，并减少数据
        this.datas[1] = this.datas[size--];
        // 2.堆化让其继续成为一个合格的堆，此时需要自上而下堆化
        sink(1);

        return res;
    }

    // 建堆
    public void buildHeap(){
        // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (this.datas.length)/2; i > 0; i--) {
            sink(i);
        }
    }

    // 上浮操作
    private void swim(int end){
        int i = end;
        while( i/2 >0 && this.datas[i/2] < this.datas[i]){
            // 有父节点，且父节点的值小于该节点，则交换
            swap(i, i/2);
            i /= 2;
        }
    }

    // 下沉操作
    private void sink(int start){

        // 通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，
        // 如果当前结点小，则需要交换位置
        while (2*start <= size){

            int max;
            if(2*start+1 <= size){
                // 有右节点的情况
                if(this.datas[2*start] > this.datas[2*start+1]){
                    // 左节点更大
                    max = 2*start;
                }else{
                    // 右节点更大
                    max = 2*start+1;
                }
            }else{
                // 无右节点的情况
                max = 2*start;
            }

            // 与当前节点比较判断是否需要交换
            if(this.datas[start] > this.datas[max]){
                break;
            }
            // 需要交换
            swap(start, max);
            start = max;
        }
    }

    private void swap(int i, int j){
        int tmp = this.datas[i];
        this.datas[i] = this.datas[j];
        this.datas[j] = tmp;
    }

    public static void main(String[] args) {

        int arr[] = new int[]{2,7,4,1,8,1};
        Heap heap = new Heap(arr);
        heap.buildHeap();
        System.out.println(heap.peek());
        heap.push(5);
        heap.push(10);
        heap.push(3);
        while (heap.size > 0) {
            int num = heap.pop();
            System.out.printf(num + "");
        }
    }
}
```

### 堆排序实现

借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定， **是O(nlogn)** ， 并且它还是原地排序**in-place**算法。我们可以把堆排序的过程大致分解成两个大的步骤，**建堆和排序**。

算法描述如下：

1. 将初始待排序关键字序列 [R1, R2, ...., Rn] 构建成大顶堆，此堆为初始的无序区；
2. 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 [R1, R2, ......, R{n-1}] 和新的有序区 [Rn]，且满足R[1, 2, ..., n-1]<= R[n]；
3. 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 [R1，R2，....R{n-1}] 调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区 [R1，R2...R{n-2}] 和新的有序区 [R{n-1}，Rn]。
4. 不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。

#### 建堆

- **方案1：自下而上的堆化操作**，可以假设，起初堆中只包含一个数据，就是下标为1的数据。然后，我们调用前面讲的插入操作，将下标从2到n的数据依次插入到堆中。这样我们就将包含n个数据的数组，组织成了堆，这里面的堆化操作是属于自下而上的堆化操作。

- **方案2：自上而下的堆化操作**，是从后往前处理数组，并且每个数据都是从上往下堆化。下面以图示的形式解释一下第二种实现思路。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了，那第一个非叶子节点如何找呢？别忘记堆是一个完全二叉树，**堆中最后一个元素下标除以2取整就是第一个非叶子节点的下标位置**。

  ![初始堆有序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252146153.PNG)

  代码实现如下：

  ```java
  // 建堆：大顶堆，堆化是自上而下堆化
  public void buildHeap(){
      // 对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
      for (int i = (this.datas.length)/2; i > 0; i--) {
          sink(i);
      }
  }
  ```

- **建堆操作的时间复杂度**

  首先每个节点堆化的复杂度是：O(logn) ， 而建堆的过程中大约堆化了 n/2+1 个节点， 所以这么看时间复杂度是 O(nlogn)，当然了这么推导出来的也没有错误，只是不够精确，**实际上建堆操作的时间复杂度是O(n)**，由于推导的过程涉及很多数学知识在此先不做过多推导。

#### 排序

- 建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的；

- 数组中的第一个元素就是堆顶，也就是最大的元素；

- 把它跟最后一个元素交换，那最大元素就放到了下标为n的位置，将剩下的n-1个元素重新构建成堆；

- 堆化完成之后，我们再取堆顶的元素，放到下标是n-1的位置；

- 一直重复这个过程，直到最后堆中只剩下标为的一个元素，排序工作就完成了，这个过程有点类似上面讲的“删除堆顶元素"的操作。

- **代码**：

  ```java
  while (heap.size > 0) {
      int num = heap.pop();
      System.out.printf(num + ", ");
  }
  ```

### 总结

1. **堆排序的时间复杂度是多少？**

   堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 `O(n)`，排序过程的时间复杂度是 `O(nlogn)`， 所以， 堆排序整体的时间复杂度是`O(nlogn)` 。

2. **堆排序的空间复杂度是多少？**

   整个堆排序的过程，都只需要极个别临时存储空间，其空间复杂度为**O(1)**，所以堆排序是原地排序 in-place 算法。

3. **堆排序是稳定的排序算法吗？**

   堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

4. **堆排序和快排等相同复杂度的同类排序算法的比较：**

   1. 堆排序**数据访问的方式**没有快速排序友好。对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。 
   2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。
   3. 从实际应用来说我们一般使用快排使用的多。

## 排序算法总结

这里再对加入堆排序后的所有已概括的排序算法做一个总结

| 排序算法 | avg      | best     | worst    | space  | 稳定性   |
| -------- | -------- | -------- | -------- | ------ | -------- |
| 冒泡排序 | O(n^2)   | O(n)     | O(n^2)   | O(1)   | 稳定     |
| 插入排序 | O(n^2)   | O(n)     | O(n^2)   | O(1)   | 稳定     |
| 选择排序 | O(n^2)   | O(n^2)   | O(n^2)   | O(1)   | 不稳定   |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n)   | 稳定     |
| 快排排序 | O(nlogn) | O(nlogn) | O(n^2)   | O(1)   | 不稳定   |
| 桶排序   | O(n)     | O(n)     | O(nlogn) | O(n+k) | 可以稳定 |
| 计数排序 | O(n+k)   | O(n+k)   | O(n+k)   | O(n+k) | 可以稳定 |
| 堆排序   | O(nlogn) | O(nlogn) | O(nlogn) | O(1)   | 不稳定   |

1. 桶排序的复杂度和稳定性取决于用何种排序算法为每个桶进行排序，例如采用快排时，为不稳定的排序；其中k为桶的个数。
2. 计数排序中n为数据的规模，k为计数排序中需要的桶的个数，取决于待排序数组中数据的范围；当倒序遍历原数组时，为稳定排序。