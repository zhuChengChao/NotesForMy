# 数据结构：学习笔记-1

> 前些天看了《大话数据结构》，大致对数据结构有了些许了解，现又找了些视频巩固巩固，课程连接：[黑马:数据结构与算法](https://www.bilibili.com/video/BV1iJ411E7xW)，依据上述课程做了下学习笔记，总共分为3篇，此为1/3。
>

数据结构和算法这门课程无论在哪个学校的计算机专业，都是一门必修课，因为这门课程非常重要的，是编程必备的基础，但是这门课程是一门不太好学习的课程，因为它学习起来是非常的枯燥乏味的。但是如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的API，而是追求更完美的实现，那么这门课程就是你的必修课，因为：**程序设计=数据结构+算法**。

通过对基础数据结构和算法的学习，能更深层次的理解程序，提升编写代码的能力，让程序的代码更优雅，性能更高。

## 1. 数据结构和算法概述

### 1.1 什么是数据结构 

**官方解释：**

数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

**大白话：** 

数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据。

### 1.2 数据结构分类 

传统上，我们可以把数据结构分为**逻辑结构**和**物理结构**两大类。 

**逻辑结构分类：** 

逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。 

**a.集合结构：**集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。 

![集合结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108141.PNG)

**b.线性结构：**线性结构中的数据元素之间存在一对一的关系 

![线性结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109971.PNG)

**c.树形结构：**树形结构中的数据元素之间存在一对多的层次关系 

![树形结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109513.PNG)

**物理结构分类：** 

逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。 

1. **顺序存储结构：** 

把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。 

![顺序存储结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109621.PNG)

顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。 

2. **链式存储结构：** 

是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。

![链式存储结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109140.PNG)

### 1.3 什么是算法

**官方解释：**

算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。 

**大白话：** 

根据一定的条件，对一些数据进行计算，得到需要的结果。 

### 1.4 算法初体验 

​	在生活中，我们如果遇到某个问题，常常解决方案不是唯一的。

​	例如从西安到北京，如何去？会有不同的解决方案，我们可以坐飞机，可以坐火车，可以坐汽车，甚至可以步行，不同的解决方案带来的时间成本和金钱成本是不一样的，比如坐飞机用的时间最少，但是费用最高，步行费用最低，但时间最长。

​	再例如在北京二环内买一套四合院，如何付款？也会有不同的解决方案，可以一次性现金付清，也可以通过银行做按揭。这两种解决方案带来的成本也不一样，一次性付清，虽然当时出的钱多，压力大，但是没有利息，按揭虽然当时出的钱少，压力比较小，但是会有利息，而且30年的总利息几乎是贷款额度的一倍，需要多付钱。

​	在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算法追求以下两个目标：

1. 花最少的时间完成需求；
2. 占用最少的内存空间完成需求；

下面我们用一些实际案例体验一些算法。 

**需求1：**计算1到100的和。

第一种解法： 

```java
public static void main(String[] args){
    int sum = 0;
    int n = 100;
    for(int i = 1; i<=n; i++){
        sum += i;
    }
    System.out.println("sum=" + sum);
}
```

第二种解法： 

```java
public static void main(String[] args) {
    int sum = 0;
    int n=100;
    sum = (n+1)*n/2;
    System.out.println("sum="+sum);
}
```

第一种解法要完成需求，要完成以下几个动作：

1. 定义两个整型变量；
2. 执行100次加法运算；
3. 打印结果到控制台； 

第二种解法要完成需求，要完成以下几个动作：

1. 定义两个整型变量；
2. 执行1次加法运算，1次乘法运算，一次除法运算，总共3次运算；
3. 打印结果到控制台；

很明显，第二种算法完成需求，花费的时间更少一些。 

**需求2：**

计算10的阶乘

第一种解法：

```java
public class Test {
    public static void main(String[] args) {
        // 测试，计算10的阶乘
        long result = fun1(10);
        System.out.println(result);
    } 
    // 计算n的阶乘
    public static long fun1(long n){
        if (n==1){
        	return 1;
        } 
        return n*fun1(n-1);
    }
}
```

第二种解法： 

```java
public class Test {
    public static void main(String[] args) {
        //测试，计算10的阶乘
        long result = fun2(10);
        System.out.println(result);
    } 
    //计算n的阶乘
    public static long fun2(long n){
        int result=1;
        for (long i = 1; i <= n; i++) {
        	result*=i;
        } 
        return result;
    }
}
```

​	第一种解法，使用递归完成需求，fun1方法会执行10次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行...最终，最多的时候，需要在栈内存同时开辟10块内存分别执行10个fun1方法。

​	第二种解法，使用for循环完成需求，fun2方法只会执行一次，最终，只需要在栈内存开辟一块内存执行fun2方法即可。

很明显，第二种算法完成需求，占用的内存空间更小。 

## 2. 算法分析 

​	前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。 

### 1.1 算法的时间复杂度分析 

​	我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？

**事后分析估算方法：**

​	比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。 

```java
public static void main(String[] args) {
    long start = System.currentTimeMillis();
    int sum = 0;
    int n=100;
    for (int i = 1; i <= n; i++) {
    	sum += i;
    } 
    System.out.println("sum=" + sum);
    
    long end = System.currentTimeMillis();
    System.out.println(end-start);
}
```

**事前分析估算方法：**

​	在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机上运行所消耗的时间取决于下列因素：

1. 算法采用的策略和方案；
2. 编译产生的代码质量；
3. 问题的输入规模(所谓的问题输入规模就是输入量的多少)；
4. 机器执行指令的速度； 

​	由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

​	我么再次以之前的求和案例为例，进行分析。 

**需求：**计算1到100的和。

第一种解法： 

```java
// 如果输入量为n为1，则需要计算1次；
// 如果输入量n为1亿，则需要计算1亿次；
public static void main(String[] args) {
    int sum = 0;  //执行1次
    int n=100;    //执行1次
    for (int i = 1; i <= n; i++) {//执行了n+1次
    	sum += i;//执行了n次
    } 
    System.out.println("sum=" + sum);
}
```

第二种解法： 

```java
// 如果输入量为n为1，则需要计算1次；
// 如果输入量n为1亿，则需要计算1次；
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n=100;//执行1次
    sum = (n+1)*n/2;//执行1次
    System.out.println("sum="+sum);
}
```

​	因此，当输入规模为n时，第一种算法执行了`1+1+(n+1)+n=2n+3`次；第二种算法执行了`1+1+1=3`次。如果我们把第一种算法的循环体看做是一个整体，忽略结束条件的判断，那么其实这两个算法运行时间的差距就是n和1的差距。 

​	为什么循环判断在算法1里执行了n+1次，看起来是个不小的数量，但是却可以忽略呢？我们来看下一个例子： 

**需求：**计算100个1+100个2+100个3+...+100个100的结果

代码： 

```java
public static void main(String[] args) {
    int sum=0;
    int n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
        	sum+=i;
        }
    } 
    System.out.println("sum="+sum);
}
```

​	上面这个例子中，如果我们要精确的研究循环的条件执行了多少次，是一件很麻烦的事情，并且，由于真正计算和的代码是内循环的循环体，所以，在研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。

​	我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。

​	我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把**核心操作的次数和输入规模关联起来**。 

#### 1.1.1 函数渐近增长 

**概念：** 

​	给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n>N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。 

​	概念似乎有点艰涩难懂，那接下来我们做几个测试。 

**测试一：**

假设四个算法的输入规模都是n：

1. 算法A1要做2n+3次操作，可以这么理解：先执行n次循环，执行完毕后，再有一个n次循环，最后有3次运算；
2. 算法A2要做2n次操作；
3. 算法B1要做3n+1次操作，可以这个理解：先执行n次循环，再执行一个n次循环，再执行一个n次循环，最后有1次运算。
4. 算法B2要做3n次操作；

那么，上述算法，哪一个更快一些呢？ 

| 输入规模 | 算法A1执行效率 | 算法A2执行效率 | 算法B1执行效率 | 算法B2执行效率 |
| -------- | -------------- | -------------- | -------------- | -------------- |
| n=1      | 5              | 2              | 4              | 3              |
| n=2      | 7              | 4              | 7              | 6              |
| n=3      | 9              | 6              | 10             | 9              |
| n=10     | 23             | 20             | 31             | 30             |
| n=100    | 203            | 200            | 301            | 300            |

![渐进增长1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109553.PNG)

通过数据表格，比较算法A1和算法B1：

当输入规模n=1时，A1需要执行5次，B1需要执行4次，所以A1的效率比B1的效率低；

当输入规模n=2时，A1需要执行7次，B1需要执行7次，所以A1的效率和B1的效率一样；

当输入规模n>2时，A1需要的执行次数一直比B1需要执行的次数少，所以A1的效率比B1的效率高；

所以我们可以得出结论： **当输入规模n>2时，算法A1的渐近增长小于算法B1 的渐近增长**

| 输入规模 | 算法C1执行效率 | 算法C2执行效率 | 算法D1执行效率 | 算法D2执行效率 |
| -------- | -------------- | -------------- | -------------- | -------------- |
| n=1      | 12             | 1              | 3              | 1              |
| n=2      | 16             | 2              | 9              | 4              |
| n=3      | 20             | 3              | 19             | 9              |
| n=10     | 48             | 10             | 201            | 100            |
| n=100    | 408            | 100            | 20001          | 10000          |
| n=1000   | 2008           | 1000           | 2000001        | 1000000        |

![渐进增长2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109794.PNG)

通过数据表格，对比算法C1和算法D1：

当输入规模n<=3时，算法C1执行次数多于算法D1，因此算法C1效率低一些；

当输入规模n>3时，算法C1执行次数少于算法D1，因此，算法D2效率低一些；

所以，总体上，算法C1要优于算法D1。

通过折线图，对比对比算法C1和C2：

随着输入规模的增大，算法C1和算法C2几乎重叠；

通过折线图，对比算法C系列和算法D系列：随着输入规模的增大，即使去除n^2前面的常数因子，D系列的次数要远远高于C系列。 

因此，可以得出结论：**随着输入规模的增大，与最高次项相乘的常数可以忽略**

**测试三：**

假设四个算法的输入规模都是n：

算法E1：2n^2+3n+1;

算法E2：n^2

算法F1：2n^3+3n+1

算法F2：n^3

那么上述算法，哪个更快一些？ 

| 输入规模 | 算法E1执行效率 | 算法E2执行效率 | 算法F1执行效率 | 算法F2执行效率 |
| -------- | -------------- | -------------- | -------------- | -------------- |
| n=1      | 6              | 1              | 6              | 1              |
| n=2      | 15             | 4              | 23             | 8              |
| n=3      | 28             | 9              | 64             | 27             |
| n=10     | 231            | 100            | 2031           | 1000           |
| n=100    | 20301          | 10000          | 2000301        | 1000000        |

![渐进增长3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109823.PNG)

通过数据表格，对比算法E1和算法F1：

当n=1时，算法E1和算法F1的执行次数一样；

当n>1时，算法E1的执行次数远远小于算法F1的执行次数；

所以算法E1总体上是由于算法F1的。

通过折线图我们会看到，算法F系列随着n的增长会变得特块，算法E系列随着n的增长相比较算法F来说，变得比较慢，所以可以得出结论：**最高次项的指数大的，随着n的增长，结果也会变得增长特别快** 

**测试四：**

假设五个算法的输入规模都是n：

算法G：n^3;

算法H：n^2;

算法I：n:

算法J：logn

算法K：1

那么上述算法，哪个效率更高呢？ 

| 输入规模 | 算法G执行效率 | 算法H执行效率 | 算法I执行效率 | 算法J执行效率 | 算法K执行效率 |
| -------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| n=2      | 8             | 4             | 2             | 1             | 1             |
| n=4      | 64            | 16            | 4             | 2             | 1             |

![渐进增长4](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109936.PNG)

通过观察数据表格和折线图，很容易可以得出结论：**算法函数中n最高次幂越小，算法效率越高**

总上所述，在我们比较算法随着输入规模的增长量时，可以有以下规则：

1. **算法函数中的常数可以忽略；**
2. **算法函数中最高次幂的常数因子可以忽略；**
3. **算法函数中最高次幂越小，算法效率越高。** 

#### 1.1.2 算法时间复杂度 

##### 1.1.2.1 大O记法

**定义：**

​	在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。

​	在这里，我们需要明确一个事情：**执行次数=执行时间**

​	用大写O来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

下面我们使用大O表示法来表示一些求和算法的时间复杂度：

算法一： 

```java
public static void main(String[] args) {
    int sum = 0;      // 执行1次
    int n=100;        // 执行1次
    sum = (n+1)*n/2;  // 执行1次
    System.out.println("sum="+sum);
}
```

算法二： 

```java
public static void main(String[] args) {
    int sum = 0;	// 执行1次
    int n=100;		// 执行1次
    for (int i = 1; i <= n; i++) {
    	sum += i;	// 执行了n次
    } 
    System.out.println("sum=" + sum);
}
```

算法三： 

```java
public static void main(String[] args) {
    int sum=0;			// 执行1次
    int n=100;			// 执行1次
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
        	sum+=i;		// 执行n^2次
        }
    } 
    System.out.println("sum="+sum);
}
```

如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为n时，以上算法执行的次数分别为： 

算法一：3次

算法二：n+3次

算法三：n^2+2次 

​	如果用大O记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大O阶的表示法有以下几个规则可以使用： 

1. **用常数1取代运行时间中的所有加法常数；**
2. **在修改后的运行次数中，只保留高阶项；**
3. **如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；**

所以，上述算法的大O记法分别为：

算法一：O(1)

算法二：O(n) 

算法三：O(n^2) 

##### 1.1.2.2 常见的大O阶

**1.线性阶**

一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如： 

```java
public static void main(String[] args) {
    int sum = 0;
    int n=100;
    for (int i = 1; i <= n; i++) {
    	sum += i;
    } 
    System.out.println("sum=" + sum);
}
```

上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次 

**2.平方阶** 

一般嵌套循环属于这种时间复杂度 

```java
public static void main(String[] args) {
    int sum=0,n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
        	sum+=i;
        }
    }
    System.out.println(sum);
}
```

​	上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环中出来，就需要执行100*100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2). 

**3.立方阶** 

一般三层嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int x=0,n=100;
    for (int i = 1; i <=n ; i++) {
        for (int j = 1; j <=n ; j++) {
            for (int k = 1; k <=n ; j++) {
            	x++;
            }
        }
    } 
    System.out.println(x);
}
```

​	上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100×100×100次，也就是n的立方，所以这段代码的时间复杂度是O(n^3) 

**4.对数阶** 

```java
int i=1,n=100;
while(i<n){
	i = i*2;
}
```

​	由于每次i×2之后，就距离n更近一步，假设有X个2相乘后大于n，则会退出循环。由于是2^X=n,得到x=log2(n),所以这个循环的时间复杂度为O(logn); 

​	对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。 

**5.常数阶** 

一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：

```java
public static void main(String[] args) {
    int n=100;
    int i=n+2;
    System.out.println(i);
}
```

​	上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度为O(1)

下面是对常见时间复杂度的一个总结： 

| 描述         | 增长的数量级 | 说明     | 举例           |
| ------------ | ------------ | -------- | -------------- |
| 常数级别     | 1            | 普通语句 | 两个数相加     |
| 对数级别     | logn         | 二分策略 | 二分查找       |
| 线性级别     | n            | 循环     | 找出最大元素   |
| 线性对数级别 | nlogn        | 分治思想 | 归并排序       |
| 平方级别     | n^2          | 双层循环 | 检查所有元素对 |
| 立方级别     | n^3          | 三层循环 | 检查所有三元组 |
| 指数级别     | 2^n          | 穷举查找 | 检查所有子集   |

他们的复杂程度从低到高依次为：

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3) 

​	根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的算法，尽可能的追求的是O(1)，O(logn)，O(n)，O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、立方阶或者更复杂的，那我们可以认为这种算法是不可取的，需要优化。 

##### 1.1.2.3 函数调用的时间复杂度分析 

​	之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。 

**案例一：** 

```java
public static void main(String[] args) {
    int n=100;
    for (int i = 0; i < n; i++) {
    	show(i);
   	}
} 

private static void show(int i) {
    System.out.println(i);
}
```

​	在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法的时间复杂度为O(1),那main方法的时间复杂度就是O(n) 

**案例二：** 

```java
public static void main(String[] args) {
    int n=100;
    for (int i = 0; i < n; i++) {
    	show(i);
    }
} 

private static void show(int i) {
    for (int j = 0; j < i; i++) {
    	System.out.println(i);
    }
}
```

​	在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法的时间复杂度为O(n)，那main方法的时间复杂度为O(n^2) 

**案例三：** 

```java
public static void main(String[] args) {
    int n=100;
    show(n);
    for (int i = 0; i < n; i++) {
    	show(i);
    } 
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
        	System.out.println(j);
        }
    }
} 

private static void show(int i) {
    for (int j = 0; j < i; i++) {
    	System.out.println(i);
    }
}
```

​	在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码，所以其执行次数为n^2,那么main方法总执行次数为`n+n^2+n^2=2n^2+n`。

​	根据大O推导规则，去掉n保留最高阶项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2) 

##### 1.1.2.4 最坏情况

​	从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快乐。

​	算法分析也是类似，假如有一个需求：有一个存储了n个随机数字的数组，请从中查找出指定的数字。 

```java
public int search(int num){
    int[] arr={11,10,8,9,7,22,23,0};
    for (int i = 0; i < arr.length; i++) {
        if (num==arr[i]){
        	return i;
        }
    } 
    return -1;
}
```

**最好情况：**

查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)

**最坏情况：**

查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)

**平均情况：**

任何数字查找的平均成本是O(n/2)

​	最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。 

### 1.2 算法的空间复杂度分析 

​	计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经历了1M，2M，4M...等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是一个经常需要考虑的问题。我么可以用算法的空间复杂度来描述算法对内存的占用 。

#### 1.2.1 java中常见内存占用 

1. 基本数据类型内存占用情况： 

   | 数据类型 | 内存占用字节数 |
   | -------- | -------------- |
   | byte     | 1              |
   | short    | 2              |
   | int      | 4              |
   | long     | 8              |
   | float    | 4              |
   | double   | 8              |
   | boolean  | 1              |
   | char     | 2              |

2. 计算机访问内存的方式都是一次一个字节 

![访问内存方式](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109170.PNG)

3. 一个引用（机器地址）需要8个字节表示：

   例如： Date date = new Date()，则date这个变量需要占用8个字节来表示

4. 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 

5. 一般内存的使用，如果不够8个字节，都会被自动填充为8字节： 

   ```java
   public class A{
   	public int a = 1;
   }
   
   // 通过new A() 创建一个对象的内存占用如下：
   // 	1. 整形成员变量a占用4个字节
   // 	2. 对象本身占用16个字节
   // 那么创建该对象总共需要20个字节，但由于不是以8为单位，会自动填充为24字节
   ```

   6. java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。 

#### 1.2.2 算法的空间复杂度 

了解了java的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。

算法的空间复杂度计算公式记作：S(n)=O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。

**案例：**对指定的数组元素进行反转，并返回反转的内容。

解法一： 

```java
public static int[] reverse1(int[] arr){
	int n=arr.length;//申请4个字节
	int temp;//申请4个字节
    for(int start=0, end=n-1;start<=end; start++,end--){
        temp=arr[start];
        arr[start]=arr[end];
        arr[end]=temp;
    } 
    return arr;
}
```

解法二： 

```java
public static int[] reverse2(int[] arr){
    int n=arr.length;//申请4个字节
    int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节
    for (int i = n-1; i >=0; i--) {
    	temp[n-1-i]=arr[i];
    } 
    return temp;
}
```

忽略判断条件占用的内存，我们得出的内存占用情况如下：

算法一：

​	不管传入的数组大小为多少，始终额外申请4+4=8个字节；
算法二：

​	4+4n+24=4n+28;

​	根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要优于算法二。

​	由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。

​	由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。

​	但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样的问题。 

## 3. 排序

### 3.1 简单排序

​	在我们的程序中，排序是非常常见的一种需求，提供一些数据元素，把这些数据元素按照一定的规则进行排序。比如查询一些订单，按照订单的日期进行排序；再比如查询一些商品，按照商品的价格进行排序等等。所以，接下来我们要学习一些常见的排序算法。

​	在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中，那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。

​	就比如我们先设计一套API如下： 

| 类名     | ArrayList                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | ArrayList()：创建ArrayList对象                               |
| 成员方法 | 1.boolean add(E e)：向集合中添加元素 <br />2.E remove(int index):从集合中删除指定的元素 |

​	然后再使用java代码去实现它。以后我们讲任何数据结构与算法都是以这种方式讲解 

#### 3.1.1 Comparable接口介绍 

​	由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。 

**需求：**

1. 定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；
2. 定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试 

```java
//1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；
public class Student implements Comparable<Student>{

    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }

    // 定义比较规则
    @Override
    public int compareTo(Student o) {
        return this.getAge() - o.getAge();
    }
}

// 测试类
public class Test {

    public static void main(String[] args) {

        Student stu1 = new Student();
        stu1.setUsername("zhangsan");
        stu1.setAge(17);

        Student stu2 = new Student();
        stu2.setUsername("lisi");
        stu2.setAge(19);

        Comparable max = getMax(stu1, stu2);
        System.out.println(max);

    }

    //测试方法，获取两个元素中的较大值
    public static Comparable getMax(Comparable c1, Comparable c2){
        int cmp = c1.compareTo(c2);

        return cmp >= 0 ? c1 : c2;
    }
}
```

#### 3.1.2 冒泡排序 

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 

**需求：**

排序前：{4,5,6,3,2,1} 

排序后：{1,2,3,4,5,6} 

**排序原理：** 

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。 

![冒泡排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109396.PNG)

**冒泡排序API设计：** 

| 类名     | Bubble                                                       |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Bubble()：创建Bubble对象                                     |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**冒泡排序的代码实现：** 

```java
// 排序代码
public class Bubble {

    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        for (int i = a.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                //比较索引j和索引j+1处的值
                if(greater(a[j], a[j+1])){
                    exch(a, j, j+1);
                }
            }
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w) > 0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Integer[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {4, 5, 6, 3, 2, 1};
    Bubble.sort(a);
    System.out.println(Arrays.toString(a));
}
```

冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。

在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么：

元素比较的次数为：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)×(N-1)/2=N^2/2-N/2;

元素交换的次数为：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)×(N-1)/2=N^2/2-N/2;

总执行次数为：(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;

按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2). 

#### 3.1.3 选择排序 

选择排序是一种更加简单直观的排序方法。 

**需求：**

排序前：{4,6,8,7,9,2,10,1}

排序后：{1,2,4,5,7,8,9,10} 

**排序原理：** 

1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值 

![选择排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109539.PNG)

**选择排序API设计：** 

| 类名     | Selection                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Selection()：创建Selection对象                               |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**选择排序的代码实现：** 

```java
public class Selection {

    /*
   对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        for (int i = 0; i < a.length-1; i++) {
            //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置
            int minIndex = i;
            for (int j = i+1; j < a.length; j++) {
                //需要比较最小索引minIndex处的值和j索引处的值；
                if(greater(a[minIndex], a[j])){
                    minIndex = j;
                }
            }
            //交换最小元素所在索引minIndex处的值和索引i处的值
            exch(a, i, minIndex);
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w) > 0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {4, 5, 6, 3, 2, 1};
    Selection.sort(a);
    System.out.println(Arrays.toString(a));
}
```

**选择排序的时间复杂度分析：**

选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数和数据比较次数：

数据比较次数：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; 

数据交换次数：N-1

时间复杂度：N^2/2-N/2+（N-1）=N^2/2+N/2-1;

根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2); 

#### 3.1.4 插入排序 

插入排序（Insertion sort）是一种简单直观且稳定的排序算法。

插入排序的工作方式非常像人们排序一手扑克牌一样。开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如下图所示： 

![插入排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109202.PNG)

**需求：**

排序前：{4,3,2,10,12,1,5,6}

排序后：{1,2,3,4,5,6,10,12} 

**排序原理：**

1. 把所有的元素分为两组，已经排序的和未排序的；
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；
3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位； 

![插入排序2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109831.PNG)

**插入排序API设计：** 

| 类名     | Insertion                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Insertion()：创建Insertion对象                               |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**插入排序代码实现：** 

```java
public class Insertion {

    /*
        对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        for (int i = 1; i < a.length; i++) {
            for (int j = i; j > 0 ; j--) {
                if(greater(a[j-1], a[j])){
                    exch(a, j-1, j);
                }
                else{
                    break;
                }
            }
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w) > 0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {4, 5, 6, 3, 2, 1};
    Insertion.sort(a);
    System.out.println(Arrays.toString(a));
}
```

**插入排序的时间复杂度分析**

插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。

最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么：

比较的次数为：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)×(N-1)/2=N^2/2-N/2;

交换的次数为：(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)×(N-1)/2=N^2/2-N/2;

总执行次数为：(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;

按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2). 

### 3.2 高级排序 

之前我们学习过基础排序，包括冒泡排序，选择排序还有插入排序，并且对他们在最坏情况下的时间复杂度做了分析，发现都是O(n^2)，而平方阶通过我们之前学习算法分析我们知道，随着输入规模的增大，时间成本将急剧上升，所以这些基本排序方法不能处理更大规模的问题，接下来我们学习一些高级的排序算法，争取降低算法的时间复杂度最高阶次幂。 

#### 3.2.1 希尔排序 

希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。 

前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数，这样的需求如何实现呢？接下来我们来看看希尔排序的原理。 

**需求：**

排序前：{9,1,2,5,7,4,8,6,3,5}

排序后：{1,2,3,4,5,5,6,7,8,9} 

**排序原理：**

1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；
2. 对分好组的每一组数据完成插入排序；
3. 减小增长量，最小减为1，重复第二步操作。 

![希尔排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109725.PNG)

增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则： 

```java
int h=1
while(h < 数组长度/2){
    h = 2h+1;
}

// 循环结束后我们可以确定h的最大值
// h的减小规则为：
h=h/2
```

**希尔排序的API设计：** 

| 类名     | Shell                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Shell()：创建Shell对象                                       |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**希尔排序的代码实现：** 

```java
public class Shell {

    /*
        对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        // 1.根据数组a的长度，确定增长量h的初始值；
        int h=1;
        while (h < a.length/2){
            h = 2*h+1;
        }
        // 2.希尔排序
        while (h>=1){
            //排序
            //2.1.找到待插入的元素
            for (int i = h; i < a.length; i++) {
                for (int j = i; j >= h; j -= h) {
                    //待插入的元素是a[j],比较a[j]和a[j-h]
                    if(greater(a[j-h], a[j])){
                        //交换元素
                        exch(a, j-h, j);
                    }else {
                        //待插入元素已经找到了合适的位置，结束循环；
                        break;
                    }
                }
            }
            //减小h的值
            h = h/2;
        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w) > 0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {9,1,2,5,7,4,8,6,3,5};
    Shell.sort(a);
    System.out.println(Arrays.toString(a));
}
```

**希尔排序的时间复杂度分析**

​	在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。

​	我们可以使用事后分析法对希尔排序和插入排序做性能比较。

​	在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从100000到1的逆向数据，我们可以根据这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时间差就是排序的耗时。 

**希尔排序和插入排序性能比较测试代码：** 

```java
public class SortCompare {

    //调用不同的测试方法，完成测试
    public static void main(String[] args) throws Exception {
        //1.创建一个ArrayList集合，保存读取出来的整数
        ArrayList<Integer> list = new ArrayList<>();

        //2.创建缓存读取流BufferedReader，读取数据，并存储到ArrayList中；
        BufferedReader reader = new BufferedReader(new InputStreamReader(SortCompare.class.getClassLoader().getResourceAsStream("reverse_arr.txt")));
        String line=null;
        while ((line = reader.readLine()) != null){
            //line是字符串，把line转换成Integer，存储到集合中
            int i = Integer.parseInt(line);
            list.add(i);
        }
        reader.close();
        // System.out.println(list.toString());

        //3.把ArrayList集合转换成数组
        Integer a[] = new Integer[list.size()];
        list.toArray(a);

        //4.调用测试代码完成测试
        // testInsertion(a);  //插入排序执行的时间为：21161毫秒
        testShell(a);  //希尔排序执行的时间为：40毫秒
    }

    //测试插入排序
    public static void testInsertion(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Insertion.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("插入排序执行的时间为："+(end-start)+"毫秒");
    }

    //测试希尔排序
    public static void testShell(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Shell.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("希尔排序执行的时间为："+(end-start)+"毫秒");
    }
}
```

通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。 

#### 3.2.2 归并排序 

##### 3.2.2.1 递归 

正式学习归并排序之前，我们得先学习一下递归算法。 

**定义：**

定义方法时，在方法内部调用方法本身，称之为递归。

```java
public void show(){
    System.out.println("aaa");
    show();
}
```

**作用：**

​	它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 

**注意事项：** 

​	在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。 

![递归](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109343.PNG)

**需求：**

请定义一个方法，使用递归完成求N的阶乘； 

```java
分析：
1!:	1
2!:	2*1=2*1!
3!:	3*2*1=3*2!
4!:	4*3*2*1=4*3!
...
n!:	n*(n-1)*(n-2)...*2*1=n*(n-1)!

所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-1)
```

**代码实现：** 

```java
public class Test{
    public static void main(String[] args) throws Exception{
        int result = factorial(5);
        System.out.println(result);
    }
    
    public static int factorial(int n){
        if(n==1){
            return 1;
        }
        return n*factorial(n-1);
    }
}
```

##### 3.2.2.2 归并排序 

​	归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 

**需求：**

排序前：{8,4,5,7,1,3,6,2}

排序后：{1,2,3,4,5,6,7,8} 

**排序原理：**

1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止；
2. 将相邻的两个子组进行合并成一个有序的大组；
3. 不断的重复步骤2，直到最终只有一个组为止。 

![归并排序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109121.PNG)

**归并排序API设计：** 

| 类 名       | Merge                                                        |
| ----------- | ------------------------------------------------------------ |
| 构 造 方 法 | Merge()：创建Merge对象                                       |
| 成 员 方 法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br />2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序 <br />3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到以mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组(从索引lo到索引hi) <br />4.private static boolean less(Comparable v,Comparable w):判断v是否小于w <br />5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |
| 成 员 变 量 | private static Comparable[] assist：完成归并操作需要的辅助数组 |

**归并原理：** 

```java
// 前提：
int lo = 0;
int hi = 5;
int mid = lo + (hi - lo)/2;  // 2
sort(a, lo, mid);
sort(a, mid+1, hi);
// 调用
merge(a, lo, mid, hi);
```

![归并原理1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109243.PNG)

![归并原理2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109316.PNG)

![归并原理3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109043.PNG)

![归并原理4](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109763.PNG)

![归并原理5](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109770.PNG)

![归并原理6](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252109785.PNG)

![归并原理7](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110674.PNG)

![归并原理8](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110172.PNG)

**归并排序代码实现：** 

```java
public class Merge {

    //归并所需要的辅助数组
    private static Comparable[] assist;

    /*
       比较v元素是否小于w元素
    */
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        //1.初始化辅助数组assist；
        assist = new Comparable[a.length];
        //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引；
        int lo = 0;
        int hi = a.length - 1;
        //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序
        sort(a,lo,hi);
    }


    /*
        对数组a中从lo到hi的元素进行排序
     */
    private static void sort(Comparable[] a, int lo, int hi){
        //做安全性校验；
        if (hi<=lo){
            return;
        }

        //对lo到hi之间的数据进行分为两个组
        int mid = lo+(hi-lo)/2;//   5,9  mid=7

        //分别对每一组数据进行排序
        sort(a, lo, mid);
        sort(a, mid+1, hi);

        //再把两个组中的数据进行归并
        merge(a, lo, mid, hi);
    }

    private static void merge(Comparable[] a, int lo, int mid, int hi){
        //定义三个指针
        int i = lo;
        int p1 = lo;
        int p2 = mid+1;

        //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处
        while (p1 <= mid && p2 <= hi){
            //比较对应索引处的值
            if(less(a[p1], a[p2])){
                assist[i++] = a[p1++];
            }else{
                assist[i++] = a[p2++];
            }
        }

        //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处
        while (p1<=mid){
            assist[i++] = a[p1++];
        }

        //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处
        while (p2<=hi){
            assist[i++] = a[p2++];
        }

        //把辅助数组中的元素拷贝到原数组中
        for (int index = lo; index <= hi; index++) {
            a[index] = assist[index];
        }
    }
}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {8,4,5,7,1,3,6,2};
    Merge.sort(a);
    System.out.println(Arrays.toString(a));
}
```

**归并排序时间复杂度分析：** 

​	归并排序是分治思想的最典型的例子，上面的算法中，对a[lo...hi]进行排序，先将它分为a[lo...mid]和a[mid+1...hi]两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。 

![归并复杂度](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110472.PNG)

​	用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以树共有**3层**,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。因此每层的比较次数为2^k×2^(3-k)=2^3,那么3层总共为 3×2^3。
​	假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3×2^3中的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)× 2^(log2(n))=log2(n)×n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn); 

**归并排序的缺点：**

需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。

**归并排序与希尔排序性能测试：**

​	之前我们通过测试可以知道希尔排序的性能是强于插入排序的，那现在学习了归并排序后，归并排序的效率与希尔排序的效率哪个高呢？我们使用同样的测试方式来完成一样这两个排序算法之间的性能比较。

​	在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从1000000到1的逆向数据，我们可以根据这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时间差就是排序的耗时。

**希尔排序和插入排序性能比较测试代码：** 

```java
// ... 同上方代码
//4.调用测试代码完成测试
// testInsertion(a);  //插入排序执行的时间为：21161毫秒
// testShell(a);  // 希尔排序执行的时间为：40毫秒
testMerge(a);  // 归并排序执行的时间为：58毫秒

//测试归并排序
public static void testMerge(Integer[] a){
    //1.获取执行之前的时间
    long start = System.currentTimeMillis();
    //2.执行算法代码
    Merge.sort(a);
    //3.获取执行之后的时间
    long end = System.currentTimeMillis();
    //4.算出程序执行的时间并输出
    System.out.println("归并排序执行的时间为："+(end-start)+"毫秒");
}
```

通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。 

#### 3.2.3 快速排序 

​	快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 

**需求：**

排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}

排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9} 

**排序原理：** 

1. 首先设定一个分界值，通过该分界值将数组分成左右两部分；
2. 将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值； 

3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。 

![快速排序原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110253.PNG)

**快速排序API设计:** 

| 类名     | Quick                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Quick()：创建Quick对象                                       |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br />3.public static int partition(Comparable[] a,int lo,int hi)：对数组a中，从索引lo到索引hi之间的元素进行分组，并返回分组界限对应的索引<br/>4.private static boolean less(Comparable v, Comparable w):判断v是否小于w<br />5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**切分原理：**

把一个数组切分成两个子数组的基本思想：

1. 找一个基准值，用两个指针分别指向数组的头部和尾部；
2. 先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；
3. 再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；
4. 交换当前左边指针位置和右边指针位置的元素；
5. 重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。 

![切分原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110456.PNG)

**快速排序代码实现：** 

```java
public class Quick {

    /*
        比较v元素是否小于w元素
    */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    /*
        数组元素i和j交换位置
    */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    //对数组内的元素进行排序
    public static void sort(Comparable[] a){
        int lo = 0;
        int hi = a.length - 1;

        sort(a, lo, hi);
    }

    //对数组a中从索引lo到索引hi之间的元素进行排序
    public static void sort(Comparable[] a, int lo, int hi){
        //安全性校验
        if (hi<=lo){
            return;
        }

        //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）；
        int partition = partition(a, lo, hi); //返回的是分组的分界值所在的索引，分界值位置变换后的索引

        //让左子组有序
        sort(a, lo, partition-1);

        //让右子组有序
        sort(a, partition+1, hi);
    }


    //对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引
    public static int partition(Comparable[] a, int lo, int hi){

        //确定分界值
        Comparable key = a[lo];

        //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置
        int left = lo;
        int right = hi+1;

        //切分
        while (true){
            //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止
            while (less(key, a[--right])){
                if(right == lo){
                    break;
                }
            }

            //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止
            while (less(a[++left], key)){
                if(left == hi){
                    break;
                }
            }

            //判断 left>=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可
            if(left >= right){
                break;
            }else{
                exch(a, left, right);
            }
        }

        //交换分界值
        exch(a, lo, right);

        return right;
    }

}

// 测试代码
public static void main(String[] args) {
    Integer[] a = {6, 1, 2, 7, 9, 3, 4, 5, 8};
    Quick.sort(a);
    System.out.println(Arrays.toString(a));
}
```

**快速排序和归并排序的区别：** 

​	快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前；在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。 

**快速排序时间复杂度分析：** 

​	快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个快速排序的时间复杂度和切分的次数相关。 

最优情况：每一次切分选择的基准数字刚好将当前序列等分。 

![快排最优情况](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110090.PNG)

​	如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，最优情况下快速排序的时间复杂度为O(nlogn);

​	最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2); 

![快排最差情况](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110720.PNG)

​	平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对平均情况的时间复杂度做证明了。 

#### 3.2.4 排序的稳定性 

**稳定性的定义：**

​	数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。 

![快排稳定性](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110334.PNG)

**稳定性的意义：**

​	如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。 

第一次按照价格从低到高排序： 

| 商品名称   | 价格 | 销量 |
| ---------- | ---- | ---- |
| 三星Note9  | 3999 | 21   |
| 华为mate30 | 4999 | 65   |
| 华为p30    | 5999 | 65   |
| Iphone 11  | 6899 | 32   |

第二次按照销量进行从高到低排序： 

| 商品名称   | 价格 | 销量 |
| ---------- | ---- | ---- |
| 华为mate30 | 4999 | 65   |
| 华为p30    | 5999 | 65   |
| Iphone 11  | 6899 | 32   |
| 三星Note9  | 3999 | 21   |

**常见排序算法的稳定性：** 

1. 冒泡排序：

​	只有当arr[i]>arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种**稳定**排序算法。

2. 选择排序:

​	选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2，所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种**不稳定**的排序算法。

3. 插入排序：

​	比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定**的。

4. 希尔排序：

​	希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是**不稳定**的。

5. 归并排序：

​	归并排序在归并的过程中，只有arr[i]<arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是**稳定**的。

6. 快速排序：

​	快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种**不稳定**的算法。 

## 4. 线性表

​	线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。 

前驱元素：若A元素在B元素的前面，则称A为B的前驱元素

后继元素：若B元素在A元素的后面，则称B为A的后继元素 

**线性表的特征：**数据元素之间具有一种“一对一”的逻辑关系。 

1. 第一个数据元素没有前驱，这个数据元素被称为头结点；
2. 最后一个数据元素没有后继，这个数据元素被称为尾结点；
3. 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。 

如果把线性表用数学语言来定义，则可以表示为(a1,...ai-1,ai,ai+1,...an)，ai-1领先于ai，ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素 

![线性表特征](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110613.PNG)

**线性表的分类：**

​	线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。 

### 4.1 顺序表 

​	顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。 

![数组](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110560.PNG)

#### 4.1.1 顺序表的实现 

**顺序表API设计：** 

| 类名      | SequenceList                                                 |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | SequenceList(int capacity)：创建容量为capacity的SequenceList对象 |
| 成员方 法 | 1.public void clear()：置空线性表 <br />2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数 <br />4.public T get(int i):读取并返回线性表中的第i个元素的值 <br />5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 <br />6.public void insert(T t):向线性表中添加一个元素t <br />7.public T remove(int i):删除并返回线性表中第i个数据元素。 <br />8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。 |
| 成员变 量 | 1.private T[] eles：存储元素的数组 <br />2.private int N:当前线性表的长度 |

**顺序表的代码实现：** 

```java
public class SequenceList<T> {

    // 存储元素的数组
    private T[] eles;
    // 记录当前顺序表中的元素个数
    private int N;

    // 构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles = (T[]) new Object[capacity];
        // 初始化长度
        this.N = 0;
    }

    //将一个线性表置为空表
    public void clear(){
        this.N = 0;
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线型表中添加元素t
    public void insert(T t){
        if(N==eles.length){
            resize(2*eles.length);
        }

        eles[N++] = t;
    }

    //在i元素处插入元素t
    public void insert(int i, T t){
        if(N==eles.length){
            resize(2*eles.length);
        }

        //先把i索引处的元素及其后面的元素依次向后移动一位
        for (int index = N; index > i; index--) {
            eles[index] = eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i] = t;

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];

        //索引i后面元素依次向前移动一位即可
        for (int index = i; index < N-1; index++) {
            eles[index] = eles[index+1];
        }

        //元素个数-1
        N--;

        // 判断是否需要缩容
        if(N < eles.length/4){
            resize(eles.length/2);
        }

        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for (int i = 0; i < N; i++) {
            if(eles[i] == t){
                return i;
            }
        }
        return -1;
    }

    //根据参数newSize，重置eles的大小
    public void resize(int newSize){
        //定义一个临时数组，指向原数组
        T[] temp = eles;
        //创建新数组
        eles = (T[]) new Object[newSize];
        //把原数组的数据拷贝到新数组即可
        for (int i = 0; i < N; i++) {
            eles[i] = temp[i];
        }
    }
}

// 测试代码
public class SequenceListTest {

    public static void main(String[] args) {

        //创建顺序表对象
        SequenceList<String> sl = new SequenceList<>(10);
        //测试插入
        sl.insert("姚明");
        sl.insert("科比");
        sl.insert("麦迪");
        sl.insert(1,"詹姆斯");

        //测试获取
        String getResult = sl.get(1);
        System.out.println("获取索引1处的结果为："+getResult);
        //测试删除
        String removeResult = sl.remove(0);
        System.out.println("删除的元素是："+removeResult);
        //测试清空
        sl.clear();
        System.out.println("清空后的线性表中的元素个数为:"+sl.length());
    }
}
```

#### 4.1.2 顺序表的遍历 

一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。 

在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：

1. 让SequenceList实现Iterable接口，重写iterator方法；
2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；

**代码：**

```java
public class SequenceList<T> implements Iterable<T> {

    // ... 该部分内容同上
    
    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{

        private int cursor;

        public SIterator() {
            this.cursor = 0;
        }

        @Override
        public boolean hasNext() {
            return cursor<N;
        }

        @Override
        public Object next() {
            return eles[cursor++];
        }
    }
}

// 测试代码 foreach循环
for(String s: sl){
    System.out.println(s);
}
```

#### 4.1.3 顺序表的容量可变 

​	在之前的实现中，当我们使用SequenceList时，先new SequenceList(5)创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的伸缩性。

考虑容器的容量伸缩性，其实就是改变存储数据元素的数组的大小，那我们需要考虑什么时候需要改变数组的大小？

1. 添加元素时：

   添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。 

   ![数组添加元素](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110615.PNG)

2. 移除元素时： 

   移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。 

   ![数组移除元素](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110054.PNG)

**顺序表的容量可变代码：** 

```java
// 在上述顺序表的实现代码中已经加了
// 根据参数newSize，重置eles的大小
public void resize(int newSize){
    // 定义一个临时数组，指向原数组
    T[] temp = eles;
    // 创建新数组
    eles = (T[]) new Object[newSize];
    // 把原数组的数据拷贝到新数组即可
    for (int i = 0; i < N; i++) {
        eles[i] = temp[i];
    }
}

// 测试代码
public static void main(String[] args) {
    // 创建顺序表对象
    SequenceList<String> sl = new SequenceList<>(3);
    sl.insert("张三");
    sl.insert("李四");
    sl.insert("王五");
    sl.insert("赵六");
    for(String s: sl){
        System.out.println(s);
    }
}
```

#### 4.1.4 顺序表的时间复杂度

get(i)：不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);

insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);

remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);

由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显 

#### 4.1.5 java中ArrayList实现 

java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。

1. 是否用数组实现；
2. 有没有扩容操作；
3. 有没有提供遍历方式； 

### 4.2 链表 

之前我们已经使用顺序存储结构实现了线性表，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢？有，我们可以使用另外一种存储结构实现线性表，链式存储结构。

链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能直观的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。 

![链表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110715.PNG)

​	那我们如何使用链表呢？按照面向对象的思想，我们可以设计一个类，来描述结点这个事物，用一个属性描述这个结点存储的元素，用来另外一个属性描述这个结点的下一个结点。 

**结点API设计：** 

| 类名     | Node                                            |
| -------- | ----------------------------------------------- |
| 构造方法 | Node(T t,Node next)：创建Node对象               |
| 成员变量 | T item:存储数据 Node <br />next：指向下一个结点 |

**结点类实现：** 

```java
public class Node<T>{
    // 存储元素
    public T item;
    // 指向下一个元素
    public Node next;
    
    public Node(T item, Node next){
        this.item = item;
        this.next = next;
    }
}
```

**生成链表：** 

```java
public static void main(String[] args) throws Exception{
    // 构建结点
    Node<Integer> first = new Node<Integer>(11, null);
    Node<Integer> second = new Node<Integer>(11, null);
    Node<Integer> third = new Node<Integer>(11, null);
    Node<Integer> fourth = new Node<Integer>(11, null);
    Node<Integer> fifth = new Node<Integer>(11, null);
	
    //生成链表
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
}
```

#### 4.2.1 单向链表 

​	单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。**链表的头结点的数据域不存储数据**，指针域指向第一个真正存储数据的结点。 

![单向链表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110829.PNG)

##### 4.2.1.1 单向链表API设计 

| 类名        | LinkList                                                     |
| ----------- | ------------------------------------------------------------ |
| 构造方法    | LinkList()：创建LinkList对象                                 |
| 成员方法    | 1.public void clear()：置空线性表 <br />2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数 <br />4.public T get(int i):读取并返回线性表中的第i个元素的值 <br />5.public void insert(T t)：往线性表中添加一个元素； <br />6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素<br />7.public T remove(int i):删除并返回线性表中第i个数据元素。 <br />8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则 返回-1。 |
| 成员内部 类 | private class Node:结点类                                    |
| 成员变量    | 1.private Node head:记录首结点 <br />2.private int N:记录链表的长度 |

##### 4.2.1.2 单向链表代码实现 

```java
public class LinkList<T> implements Iterable<T>{

    // 记录头结点
    private Node head;
    // 记录链表的长度
    private int N;

    // 结点类
    private class Node{
        // 存储数据
        T item;
        // 下一个结点
        Node next;

        public Node(T item, LinkList.Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public LinkList() {
        // 初始化头结点
        this.head = new Node(null, null);
        // 初始化元素个数
        this.N = 0;
    }

    // 清空链表
    public void clear(){
        head.next = null;
        this.N = 0;
    }

    // 获取链表的长度
    public Integer length(){
        return this.N;
    }

    // 判断链表是否为空
    public Boolean isEmpty(){
        return this.N == 0;
    }

    // 获取指定位置i出的元素
    public T get(int i){

        // 通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = this.head.next;
        for (int index = 0; index < i; index++) {
            n = n.next;
        }
        return n.item;
    }

    // 向链表中添加元素t
    public void insert(T t){

        // 找到当前最后一个结点
        Node n = head;
        while (n.next != null){
            n = n.next;
        }

        // 创建新结点，保存元素t
        Node newNode = new Node(t, null);
        // 让当前最后一个结点指向新结点
        n.next = newNode;
        // 元素的个数+1
        N++;
    }

    // 向指定位置i出，添加元素t
    public void insert(int i, T t){
        // 找到i位置前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre = pre.next;
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点需要指向原来i位置的结点
        Node newNode = new Node(t, curr);
        //原来i位置的前一个节点指向新结点即可
        pre.next = newNode;
        //元素的个数+1
        N++;
    }

    // 删除指定位置i处的元素，并返回被删除的元素
    public T remove(int i){

        // 找到i位置前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre = pre.next;
        }
        // 找到i位置的结点
        Node curr = pre.next;
        // 找到i位置的下一个结点
        Node nextNode = curr.next;
        // 前一个结点指向下一个结点
        pre.next = nextNode;
        // 元素个数-1
        N--;

        return curr.item;
    }

    // 查找元素t在链表中第一次出现的位置
    public int indexOf(T t){
        // 从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了
        Node n = head;
        for (int index = 0; n.next!=null; index++) {
            n = n.next;
            if(n.item == t){
                return index;
            }
        }

        return -1;
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
    }

    private class LIterator implements Iterator{

        private Node n;

        public LIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}

// 测试代码
public static void main(String[] args) {

    // 创建顺序表对象
    LinkList<String> ls = new LinkList<>();
    // 测试插入
    ls.insert("姚明");
    ls.insert("科比");
    ls.insert("麦迪");
    ls.insert(1,"詹姆斯");

    for(String s: ls){
        System.out.println(s);
    }

    // 测试获取
    String getResult = ls.get(1);
    System.out.println("获取索引1处的结果为："+getResult);
    // 测试查找
    System.out.println("麦迪的目前的位置是"+ls.indexOf("麦迪"));
    // 测试删除
    String removeResult = ls.remove(0);
    System.out.println("删除的元素是："+removeResult);
    // 测试清空
    ls.clear();
    System.out.println("清空后的线性表中的元素个数为:"+ls.length());
}
```

#### 4.2.2 双向链表 

双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。 

![双向链表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110959.PNG)

按照面向对象的思想，我们需要设计一个类，来描述结点这个事物。由于结点是属于链表的，所以我们把结点类作为链表类的一个内部类来实现。

##### 4.2.2.1 结点API设计 

| 类名     | Node                                                         |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(T t, Node pre, Node next)：创建Node对象                 |
| 成员变量 | T item：存储数据 <br />Node next：指向下一个结点 <br />Node pre:指向上一个结点 |

##### 4.2.2.2 双向链表API设计 

| 类名        | TwoWayLinkList                                               |
| ----------- | ------------------------------------------------------------ |
| 构造方法    | TwoWayLinkList()：创建TwoWayLinkList对象                     |
| 成员方法    | 1.public void clear()：空置线性表 <br />2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数 <br />4.public T get(int i):读取并返回线性表中的第i个元素的值 <br />5.public void insert(T t)：往线性表中添加一个元素； <br />6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 <br />7.public T remove(int i):删除并返回线性表中第i个数据元素。 <br />8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则 返回-1。 <br />9.public T getFirst():获取第一个元素 <br />10.public T getLast():获取最后一个元素 |
| 成员内部 类 | private class Node:结点类                                    |
| 成员变量    | 1.private Node first:记录首结点 <br />2.private Node last:记录尾结点 <br />3.private int N:记录链表的长度 |

##### 4.2.2.3 双向链表代码实现 

```java
public class TwoWayLinkList<T> implements Iterable<T> {

    //首结点
    private Node head;
    //最后一个结点
    private Node last;
    //链表的长度
    private int N;

    //结点类
    private class Node{
        //存储数据
        public T item;
        //指向上一个结点
        public Node pre;
        //指向下一个结点
        public Node next;

        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }

    public TwoWayLinkList() {
        //初始化头结点和尾结点
        this.head = new Node(null, null, null);
        this.last = null;
        //初始化元素个数
        this.N = 0;
    }

    //清空链表
    public void clear(){
        this.head.item = null;
        this.head.next = null;
        this.last = null;
        this.N = 0;
    }

    //获取链表长度
    public int length(){
        return this.N;
    }

    //判断链表是否为空
    public Boolean isEmpty(){
        return this.N == 0;
    }

    //获取第一个元素
    public T getFirst(){
        if(isEmpty()){
            return null;
        }
        return this.head.next.item;
    }

    //获取最后一个元素
    public T getLast(){
        if(isEmpty()){
            return null;
        }
        return this.last.item;
    }

    //插入元素t
    public void insert(T t){
        if(isEmpty()){
            //如果链表为空：
            //创建新的结点
            Node newNode = new Node(t, head, null);
            last = newNode;
            head.next = newNode;
        }else{
            //如果链表不为空
            Node oldLast = last;
            //创建新的结点
            Node newNode = new Node(t, oldLast, null);
            //让之前的尾结点指向新结点
            oldLast.next = newNode;
            //让新结点称为尾结点
            last = newNode;
        }

        //元素个数+1
        N++;
    }

    //向指定位置i处插入元素t
    public void insert(int i, T t){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre = pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点
        Node newNode = new Node(t, pre, curr);
        //让i位置的前一个结点的下一个结点变为新结点
        pre.next = newNode;
        //让i位置的前一个结点变为新结点
        curr.pre = newNode;
        //元素个数+1
        N++;
    }

    //获取指定位置i处的元素
    public T get(int i){
        //找到i位置的结点
        Node n = head.next;
        for (int index = 0; index < i; index++) {
            n = n.next;
        }
        return n.item;
    }

    //找到元素t在链表中第一次出现的位置
    public int indexOf(T t){

        Node n = head;
        for (int index = 0; n.next != null; index++) {
            n = n.next;
            if(n.item.equals(t)){
                return index;
            }
        }

        return -1;
    }

    //删除位置i处的元素，并返回该元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre = pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //让i位置的前一个结点的下一个结点变为i位置的下一个结点
        pre.next = nextNode;
        //让i位置的下一个结点的上一个结点变为i位置的前一个结点
        nextNode.pre = pre;
        //元素的个数-1
        N--;
        return curr.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new TIterator();
    }

    private class TIterator implements Iterator{

        private Node n;
        public TIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}

// 测试代码
public class TwoWayLinkLIstTest {

    public static void main(String[] args) {

        //创建顺序表对象
        TwoWayLinkList<String> ts = new TwoWayLinkList();
        //测试插入
        ts.insert("姚明");
        ts.insert("科比");
        ts.insert("麦迪");
        ts.insert(1,"詹姆斯");

        for(String s: ts){
            System.out.println(s);
        }

        //测试获取
        String getResult = ts.get(1);
        System.out.println("获取索引1处的结果为："+getResult);
        //测试查找
        System.out.println("麦迪的目前的位置是"+ts.indexOf("麦迪"));
        //测试删除
        String removeResult = ts.remove(0);
        System.out.println("删除的元素是："+removeResult);
        //测试清空
        ts.clear();
        System.out.println("清空后的线性表中的元素个数为:"+ts.length());


    }
}
```

##### 4.2.2.4 java中LinkedList实现

java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法

1. 底层是否用双向链表实现；
2. 结点类是否有三个域 

#### 4.2.3 链表的复杂度分析 

get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)

insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);

remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n)；

相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及的元素的交换。

相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。 

#### 4.2.4 链表反转 

单链表的反转，是面试中的一个高频题目。 

**需求：**

原链表中数据为：1->2->3>4 

反转后链表中数据为：4->3->2->1 

**反转API：** 

`public void reverse()`：对整个链表反转

`public Node reverse(Node curr)`：反转链表中的某个结点curr,并把反转后的curr结点返回 

使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结点反转完毕，整个链表就反转完毕。 

![链表反转](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110660.PNG)

**代码:** 

```java
public class LinkList<T> implements Iterable<T>{

    // ... 其他代码同上
    
	// 用来反转整个链表
    public void reverse(){
        // 判断当前链表是否为空链表，
        // 如果是空链表，则结束运行，
        // 如果不是，则调用重载的reverse方法完成反转
        if(isEmpty()){
            return;
        }
        reverse(head.next);
    }

    // 反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr){
        if(curr.next == null){
            head.next = curr;
            return curr;
        }

        // 递归的反转当前结点curr的下一个结点；
        // 返回值就是链表反转后，当前结点的上一个结点
        Node pre = reverse(curr.next);
        pre.next = curr;
        //把当前结点的下一个结点变为null
        curr.next = null;
        return curr;
    }
}

// 测试代码
public static void main(String[] args) {

    //创建顺序表对象
    LinkList<String> ls = new LinkList<>();
    //测试插入
    ls.insert("姚明");
    ls.insert("科比");
    ls.insert("麦迪");
    ls.insert(1,"詹姆斯");

    for(String s: ls){
        System.out.println(s);
    }

    // 反转
    ls.reverse();

    for(String s: ls){
        System.out.println(s);
    }
}
```

#### 4.2.5 快慢指针 

快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍 

##### 4.2.5.1 中间值问题 

我们先来看下面一段代码，然后完成需求。 

```java
//测试类
public class Test {
    public static void main(String[] args) throws Exception {
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);
        
        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        
        //查找中间值
        String mid = getMid(first);
        System.out.println("中间值为："+mid);
    }
    
    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
	public static String getMid(Node<String> first) {
		return null;
	}

    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。

利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。

如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。 

![快慢指针](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110262.PNG)

**代码：** 

```java
/**
  * @param first 链表的首结点
  * @return 链表的中间结点的值
  */
public static String getMid(Node<String> first) {
    // 定义两个指针
    Node<String> fast = first;
    Node<String> slow = first;
    // 使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值
    while (fast != null && fast.next != null){
        //变化fast的值和slow的值
        fast = fast.next.next;
        slow=slow.next;
    }

    return slow.item;
}
```

##### 4.2.5.2 单向链表是否有环问题 

![单向链表是否有环](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110174.PNG)

看下面代码，完成需求： 

```java
public class CircleListCheckTest {
    public static void main(String[] args) throws Exception {
        //创建结点
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;

        //判断链表是否有环
        boolean circle = isCircle(first);
        System.out.println("first链表中是否有环："+circle);
    }

    /**
     * 判断链表中是否有环
     * @param first 链表首结点
     * @return ture为有环，false为无环
     */
    public static boolean isCircle(Node<String> first) {
        return false;
    }

    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善测试类Test中的isCircle方法，返回链表中是否有环。

使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。 

![快慢指针判断是否有环](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252110732.PNG)

**代码：** 

```java
/**
  * 判断链表中是否有环
  * @param first 链表首结点
  * @return ture为有环，false为无环
  */
public static boolean isCircle(Node<String> first) {
    //定义快慢指针
    Node<String> fast = first;
    Node<String> slow = first;

    //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
    while (fast!=null && fast.next!=null){
        //变换fast和slow
        fast = fast.next.next;
        slow = slow.next;

        if(fast == slow){
            return true;
        }
    }
    return false;
}

```

##### 4.2.5.3 有环链表入口问题 

同样看下面这段代码，完成需求： 

```java
public class CircleListInTest {

    public static void main(String[] args) throws Exception {
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;

        //查找环的入口结点
        Node<String> entrance = getEntrance(first);
        System.out.println("first链表中环的入口结点元素为："+entrance.item);
    }

    /**
     * 查找有环链表中环的入口结点
     * @param first 链表首结点
     * @return 环的入口结点
     */
    public static Node getEntrance(Node<String> first) {
        return null;
    }
    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。

当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。 

![查找有环链表中环的入口结点](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111976.PNG)

**代码：** 

```java
/**
  * 查找有环链表中环的入口结点
  * @param first 链表首结点
  * @return 环的入口结点
  */
public static Node getEntrance(Node<String> first) {
    //定义快慢指针
    Node<String> fast = first;
    Node<String> slow = first;
    Node<String> temp = null;

    //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口
    while(fast!=null && fast.next!=null) {
        //变换快慢指针
        fast = fast.next.next;
        slow = slow.next;

        //判断快慢指针是否相遇
        if (fast == slow){
            temp = first;
            continue;
        }

        //让临时结点变换
        if (temp!=null){
            temp = temp.next;
            //判断临时指针是否和慢指针相遇
            if (temp == slow){
                break;
            }
        }
    }
    return temp;
}
```

#### 4.2.6 循环链表 

​	循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。 

![循环链表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111369.PNG)

**循环链表的构建：** 

```java
public class Test {
	public static void main(String[] args) throws Exception {
        //构建结点
        Node<Integer> first = new Node<Integer>(1, null);
        Node<Integer> second = new Node<Integer>(2, null);
        Node<Integer> third = new Node<Integer>(3, null);
        Node<Integer> fourth = new Node<Integer>(4, null);
        Node<Integer> fifth = new Node<Integer>(5, null);
        Node<Integer> six = new Node<Integer>(6, null);
        Node<Integer> seven = new Node<Integer>(7, null);
        
        //构建单链表
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        
        //构建循环链表,让最后一个结点指向第一个结点
		seven.next = first;
    }
}
```

#### 4.2.7 约瑟夫问题 

**问题描述：**

​	传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。

**问题转换：**

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。

1. 编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；
2. 自退出那个人开始的下一个人再次从1开始报数，以此类推；
3. 求出最后退出的那个人的编号。

**图示：**

![约瑟夫问题](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111283.PNG)

**解题思路：**

1. 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；
2. 使用计数器count，记录当前报数的值；
3. 遍历链表，每循环一次，count++；
4. 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0； 

**代码:** 

```java
public class JosehTest {

    public static void main(String[] args) {
        // 解决约瑟夫问题

        // 1.构建循环链表，包含41个结点，分别存储1~41之间的值
        // 记录首结点
        Node<Integer> first = null;
        // 用来记录前一个结点
        Node<Integer> pre = null;

        for (int i = 1; i <= 41 ; i++) {
            // 如果是第一个结点
            if(i==1){
                first = new Node<>(1, null);
                pre = first;
                continue;
            }
            // 如果不是第一个结点
            Node<Integer> newNode = new Node<>(i, null);
            pre.next=newNode;
            pre=newNode;
            //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first,变为循环链表了
            if(i==41){
                pre.next = first;
            }
        }

        //2.需要count计数器，模拟报数
        int count = 0;
        //3.遍历循环链表
        //记录每次遍历拿到的结点，默认从首结点开始
        Node<Integer> n = first;
        //记录当前结点的上一个结点
        Node<Integer> before = null;
        while (n != n.next){
            //模拟报数
            count++;
            //判断当前报数是不是为3
            if(count==3){
                //如果是3，则把当前结点删除调用，打印当前结点，重置count=0，让当前结点n后移
                before.next = n.next;
                System.out.print(n.item+",");
                count=0;
                n = n.next;
            }else{
                before = n;
                n = n.next;
            }
        }

        //打印最后一个元素
        System.out.println(n.item);
    }

    private static class Node<T>{
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

### 4.3 栈 

#### 4.3.1 栈概述

##### 4.3.1.1 生活中的栈

存储货物或供旅客住宿的地方,可引申为仓库、中转站 。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈。 

##### 4.3.1.2 计算机中的栈

我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出去。

栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

我们称数据进入到栈的动作为**压栈**，数据从栈中出去的动作为**弹栈**。 

![栈的概念](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111225.PNG)

#### 4.3.2 栈的实现

##### 4.3.2.1 栈API设计

| 类名     | Stack                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Stack()：创建Stack对象                                       |
| 成员方法 | 1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false <br />2.public int size():获取栈中元素的个数 <br />3.public T pop():弹出栈顶元素 <br />4.public void push(T t)：向栈中压入元素t |
| 成员变量 | 1.private Node head:记录首结点 <br />2.private int N:当前栈的元素个数 |

##### 4.3.2.2 栈代码实现 

```java
public class Stack<T> implements Iterable<T>{

    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Stack() {
        this.head = new Node(null, null);
        this.N = 0;
    }

    //判断当前栈中元素个数是否为0
    public Boolean isEmpty(){
        return this.N == 0;
    }

    //获取栈中元素的个数
    public int size(){
        return this.N;
    }

    //把t元素压入栈
    public void push(T t){
        //找到首结点指向的第一个结点
        Node oldFirst = this.head.next;
        //创建新结点
        Node newNode = new Node(t, null);
        //让首结点指向新结点
        this.head.next = newNode;
        //让新结点指向原来的第一个结点
        newNode.next = oldFirst;
        //元素个数+1；
        N++;
    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点
        Node oldFirst = this.head.next;
        if(oldFirst == null){
            return null;
        }
        //让首结点指向原来第一个结点的下一个结点
        this.head.next = oldFirst.next;
        //元素个数-1；
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{

        private Node n;

        public SIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}

// 测试代码
public class StackTest {

    public static void main(String[] args) {

        //创建栈对象
        Stack<String> stack = new Stack<>();
        //测试压栈
        stack.push("a");
        stack.push("b");
        stack.push("c");
        stack.push("d");
        for (String item : stack) {
            System.out.println(item);
        }

        System.out.println("弹出的元素是："+stack.pop());
        System.out.println("剩余的元素个数："+stack.size());
    }
}
```

#### 4.3.3 案例 

##### 4.3.3.1 括号匹配问题 

**问题描述:** 

​	给定一个字符串，里边可能包含"()"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。

例如：
	"(上海)(长安)"：正确匹配

​	"上海((长安))"：正确匹配

​	"上海(长安(北京)(深圳)南京)":正确匹配

​	"上海(长安))"：错误匹配

​	"((上海)长安"：错误匹配 

**分析：** 

1. 创建一个栈用来存储左括号
2. 从左往右遍历字符串，拿到每一个字符
3. 判断该字符是不是左括号，如果是，放入栈中存储
4. 判断该字符是不是右括号，如果不是，继续下一次循环
5. 如果该字符是右括号，则从栈中弹出一个元素t；
6. 判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号
7. 循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配 

![堆栈匹配括号](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111127.PNG)

**代码实现：** 

```java
public class BracketsMatchTest {

    public static void main(String[] args) {

        String str = "上海(长安)())";
        boolean match = isMatch(str);
        System.out.println(str+"中的括号是否匹配："+match);
    }

    /**
     * 判断str中的括号是否匹配
     * @param str 括号组成的字符串
     * @return 如果匹配，返回true，如果不匹配，返回false
     */
    public static Boolean isMatch(String str){
        //1.创建栈对象，用来存储左括号
        Stack<String> chars = new Stack<>();
        //2.从左往右遍历字符串
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i)+"";
            //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中
            if(currChar.equals("(")){
                chars.push(currChar);
            }else if(currChar.equals(")")){
                //4.继续判断当前字符是否是有括号，
                //  如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,
                //  如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号
                String pop = chars.pop();
                if(pop==null){
                    return false;
                }
            }
        }
        //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配
        if(chars.size()==0){
            return true;
        }else {
            return false;
        }
    }
}
```

##### 4.3.3.2 逆波兰表达式求值问题 

​	逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。

**中缀表达式：**

中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。

中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。

**逆波兰表达式(后缀表达式)：**

逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。 

| 中缀表达式 | 逆波兰表达式 |
| ---------- | ------------ |
| a+b        | ab+          |
| a+(b-c)    | abc-+        |
| a+(b-c)*d  | abc-d*+      |
| a*(b-c)+d  | abc-*d+      |

**需求：** 

给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。 

**分析：** 

1. 创建一个栈对象oprands存储操作数
2. 从左往右遍历逆波兰表达式，得到每一个字符串
3. 判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中
4. 如果是运算符，则从oprands栈中弹出两个操作数o1,o2
5. 使用该运算符计算o1和o2，得到结果result
6. 把该结果压入oprands栈中
7. 遍历结束后，拿出栈中最终的结果返回 

![逆波兰表达式](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111032.PNG)

**代码实现：** 

```java
public class ReversePolishNotationTest {

    public static void main(String[] args) {

        //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9
        String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "+"};
        int result = caculate(notation);
        System.out.println("逆波兰表达式的结果为：" + result);

    }

    /**
     * @param notation 逆波兰表达式的数组表示方式
     * @return 逆波兰表达式的计算结果
     */
    public static int caculate(String[] notation){
        //1.定义一个栈，用来存储操作数
        Stack<Integer> oprands = new Stack<>();
        //2.从左往右遍历逆波兰表达式，得到每一个元素
        for (int i = 0; i < notation.length; i++) {
            String curr = notation[i];
            //3.判断当前元素是运算符还是操作数
            Integer o1;
            Integer o2;
            Integer result;
            switch (curr){
                case "+":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 + o1;
                    oprands.push(result);
                    break;
                case "-":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 - o1;
                    oprands.push(result);
                    break;
                case "*":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 * o1;
                    oprands.push(result);
                    break;
                case "/":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 / o1;
                    oprands.push(result);
                    break;
                default:
                    //5.操作数，把该操作数放入到栈中；
                    oprands.push(Integer.parseInt(curr));
                    break;
            }
        }
        //6.得到栈中最后一个元素，就是逆波兰表达式的结果
        int result = oprands.pop();
        return result;
    }

}
```

### 4.4 队列 

​	队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。 

![队列](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111307.PNG)

#### 4.4.1 队列的API设计 

| 类名     | Queue                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Queue()：创建Queue对象                                       |
| 成员方法 | 1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false <br />2.public int size():获取队列中元素的个数 <br />3.public T dequeue():从队列中拿出一个元素 <br />4.public void enqueue(T t)：往队列中插入一个元素 |
| 成员变量 | 1.private Node head:记录首结点 <br />2.private int N:当前栈的元素个数 <br />3.private Node last:记录最后一个结点 |

#### 4.4.2 队列的实现 

```java
public class Queue<T> implements Iterable<T>{

    //记录首结点
    private Node head;
    //记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;

    //节点类
    private class Node{

        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Queue() {
        this.head = new Node(null, null);
        this.last = null;
        this.N = 0;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return this.N == 0;
    }

    //返回队列中元素的个数
    public int size(){
        return this.N;
    }

    //向队列中插入元素t
    public void enqueue(T t){
        if(last == null){
            //当前尾结点last为null
            last = new Node(t, null);
            head.next = last;
        }else{
            //当前尾结点last不为null
            Node oldLast = last;
            last = new Node(t, null);
            oldLast.next = last;
        }
        //元素个数+1
        N++;
    }

    //从队列中拿出一个元素
    public T dequeue(){
        if(isEmpty()){
            return null;
        }
        Node oldFirst = head.next;
        head.next = oldFirst.next;
        N--;

        //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null;
        if(isEmpty()){
            last = null;
        }

        return oldFirst.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator{

        private Node n;

        public QIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}

// 测试代码
public class QueueTest {

    public static void main(String[] args) {

        //创建队列对象
        Queue<String> q = new Queue<>();

        //测试队列的enqueue方法
        q.enqueue("a");
        q.enqueue("b");
        q.enqueue("c");
        q.enqueue("d");

        for (String str : q) {
            System.out.println(str);
        }

        System.out.println("-------------------------------");
        //测试队列的dequeue方法
        String result = q.dequeue();
        System.out.println("出队列的元素是："+result);
        System.out.println("剩余的元素个数："+q.size());
    }
}
```

## 5. 符号表

符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。 

![符号表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111819.PNG)

符号表中，键具有唯一性。

符号表在实际生活中的使用场景是非常广泛的，见下表： 

| 应用     | 查找目的                 | 键     | 值       |
| -------- | ------------------------ | ------ | -------- |
| 字典     | 找出单词的释义           | 单词   | 释义     |
| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |
| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |

### 5.1 符号表API设计 

**结点类：** 

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node next)：创建Node对象          |
| 成员变量 | 1.public Key key:存储键 <br />2.public Value value:存储值 <br />3.public Node next:存储下一个结点 |

**符号表：** 

| 类名     | SymbolTable<Key,Value>                                       |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SymbolTable()：创建SymbolTable对象                           |
| 成员方法 | 1.public Value get(Key key)：根据键key，找对应的值 <br />2.public void put(Key key,Value val):向符号表中插入一个键值对 <br />3.public void delete(Key key):删除键为key的键值对 <br />4.public int size()：获取符号表的大小 |
| 成员变量 | 1.private Node head:记录首结点 <br />2.private int N:记录符号表中键值对的个数 |

### 5.2 符号表实现 

```java
public class SymbolTable<Key, Value> {

    // 记录首结点
    private Node head;
    // 记录符号表中元素的个数
    private int N;

    private class Node{
        // 键
        public Key key;
        // 值
        public Value value;
        // 下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public SymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    // 获取符号表中键值对的个数
    public int size(){
        return this.N;
    }

    // 往符号表中插入键值对
    public void put(Key key, Value value){
        // 符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可
        Node n = head;
        while (n.next!=null){
            // 变换n
            n = n.next;
            // 判断n结点存储的键是否为key，如果是，则替换n结点的值
            if(n.key.equals(key)){
                n.value = value;
                return;
            }
        }

        // 如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部head.next=新结点即可
        Node newNode = new Node(key, value, null);
        Node oldFirst = head.next;
        head.next = newNode;
        newNode.next = oldFirst;

        // 元素个数+1；
        N++;
    }

    // 删除符号表中键为key的键值对
    public void delete(Key key){
        // 找到键为key的结点，把该结点从链表中删除
        Node n = head;
        Node pre = null;
        while (n.next!=null){
            //变换n
            pre = n;
            n = n.next;
            if(n.key.equals(key)){
                pre.next = n.next;
                N--;
                return;
            }
        }
    }

    // 从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //变换n
            n = n.next;
            if(n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}

// 测试代码
public class SymbolTableTest {

    public static void main(String[] args) {

        //创建符号表对象
        SymbolTable<Integer, String> symbolTable = new SymbolTable<>();

        //测试put方法（插入,替换）
        symbolTable.put(1, "乔峰");
        symbolTable.put(2, "虚竹");
        symbolTable.put(3, "段誉");

        System.out.println("插入完毕后，元素的个数为:"+symbolTable.size());
        symbolTable.put(2, "慕容复");
        System.out.println("替换完毕后的元素的个数为:"+symbolTable.size());

        //测试get方法
        System.out.println("替换完毕后，键2对应的值为:"+symbolTable.get(2));

        //测试删除方法
        symbolTable.delete(2);
        System.out.println("删除完毕后，元素的个数:"+symbolTable.size());
    }
}
```

### 5.3 有序符号表 

刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表。 

```java
public class OrderSymbolTable<Key extends Comparable<Key>, Value> {

    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return this.N;
    }

    //往符号表中插入键值对
    public void put(Key key, Value value){

        // 定义两个Node变量，分别记录当前结点和当前结点的上一个结点
        Node curr = head.next;
        Node pre = head;

        // 没有遍历结束，且插入的key值大于现在的curr的key值
        while (curr!=null && key.compareTo(curr.key)>0){
            //变换当前结点和前一个结点，向后指
            pre = curr;
            curr = curr.next;
        }

        //如果当前结点curr的键和要插入的key一样，则替换
        if(curr!=null && key.compareTo(curr.key)==0){
            curr.value = value;
            return;
        }

        //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前
        Node newNode = new Node(key, value, curr);
        pre.next = newNode;

        //元素的个数+1；
        N++;
    }

    //删除符号表中键为key的键值对
    public void delete(Key key){
        //找到键为key的结点，把该结点从链表中删除
        Node n = head;
        while (n.next!=null){
            //变换n
            n = n.next;
            if(n.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //变换n
            n = n.next;
            if(n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}

// 测试代码 用Debug模式查看
public class OrderSymbolTableTest {

    public static void main(String[] args) {

        //创建有序符号表对象
        OrderSymbolTable<Integer, String> table = new OrderSymbolTable<>();

        table.put(1,"张三");
        table.put(2,"李四");
        table.put(4,"赵六");
        table.put(7,"田七");

        table.put(3,"王五");
    }
}
```

