# 数据结构：学习笔记-e

> 虽然之前已经是学了一波数据结构了，过程中突然又发现了一个视频教程，就顺带给看了，算是相互参考吧，并也做了一波笔记，总共分了 5 篇笔记，此为 4/5 篇。

## 1. 课程目标

1. 理解堆的定义及存储结构
2. 掌握堆的实现
3. 掌握堆排序算法
4. 理解图的定义及概念
5. 理解图的存储方法
6. 掌握并实现BFS和DFS搜索算法
7. 掌握并实现单模式字符串查找算法BF，RK算法

## 2. 堆

我们今天讲另外一种特殊的树：“堆”(Heap) 。堆这种数据结构的应用场景非常多，你可能听过经典的堆排序，当然了我们在本章内容中也会讲到堆排序是一种原地的(in-place)、时间复杂度为O(nlogn) 的排序算法。接下来我们先来学习堆这种树结构。

### 2.1 堆的定义

堆其实是一棵树，并且是一种特殊的树。我们现在就来看看，什么样的树才是堆。

其实只要满足以下两个要求它就是一个堆。

1. 堆是一个完全二叉树；
2. 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值

对于这两点要求，我们依次解释如下：

第一点要求堆是一个完全二叉树，对于完全二叉树除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列，当然想到完全二叉树我们立马能能够想到我们之前所讲到的，**完全二叉树可以用数组来进行存储**，之前的树每个节点不仅要存储数据还要存储左右节点的指针，虽然比较符合我们的认知，但毕竟消耗一些空间的，但是完全二叉树就不一样了，比较适合用数组来存储，是非常节省存储空间的，单纯的通过数组的下标我们就可以找到一个节点的左子节点和右子节点。

第二点要求堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值，或者我们可以换一种表述方式：堆中每个节点的值都大于等于(或者小于等于)其左右子节点的值。对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。

下面我们通过一副图来描述一下堆这种数据结构，请你分析一下图中各自是否是堆？如果是都是什么堆？

![堆](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107400.PNG)

其中第1个和第2个是大顶堆，第3个是小顶堆，第4个不是堆。

### 2.2 堆的存储结构

我们知道堆是一个完全二叉树，我们可以用数组来存储，用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

具体如何存储我们接下来用一副图的形式来解释清楚堆的存储结构：

![堆用数组存储](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107077.PNG)

数组中下标为 k 的节点的左子节点，就是下标为 2k 的节点，右子节点就是下标为2k+1的节点，父节点就是下标为k/2的节点，其中k>=1。另外我们也发现，数组下标为0的位置并未存储数据，这是因为为了方便于在程序中计算，所以会浪费掉数组的一个存储空间。

### 2.3 堆的实现

掌握了堆的存储结构之后我们可以来手动实现一个

#### 2.3.1 创建堆

堆的类结构定义如下：

```java
public class Heap {

    // 存储堆中元素数据的数组
    private int[] data;
    // 堆中的最大元素个数
    private int SIZE;
    // 堆中已存储元素个数
    private int count;

    // 指定容量的构造函数
    public Heap(int capacity) {
        // 堆中存储数据从下标为1的地方开始存储
        this.data = new int[capacity + 1];
        this.SIZE = capacity;
        this.count = 0;
    }

    @Override
    public String toString() {
        return "Heap{" +
                "data=" + Arrays.toString(data) +
                ", SIZE=" + SIZE +
                ", count=" + count +
                '}';
    }
}
```

接下来我们分析如何向堆中添加一个元素

#### 2.3.2 向堆中插入元素

我们往堆中插入元素就是向数组的数据末位添加值，也就是将新来的值放在堆的最后，前面我们已经知道了堆的特性，所以添加完成后要继续满足堆的两个特性，就需要继续进行调整，这个调整的过程我们叫做**堆化**。

堆化实际上有两种，从下往上和从上往下。这里我先讲从下往上的堆化方法。

![堆化](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107200.PNG)

其实自下而上的堆化特别简单，就是顺着节点所在的路径，向上对比，然后交换。又由于堆是一棵完全二叉树，数组存储的时候下标是从1开始存储的，所以要找某个节点的父节点非常的容易，假设节点的下标为k，那么k/2就是其父节点的下标。

所以我们实现堆的插入方法如下：

```java
// 将数据存入堆中：
public void insert(int data){
    if(count >= SIZE){
        return; // 堆满了
    }
    // 将数据存入
    this.data[++count] = data;

    // 堆化：自下而上
    heapifyFromButtom2Top(this.data, count);
}

// 将数据堆化
private void heapifyFromButtom2Top(int[] data, int end){
    int i = end;
    while (i/2>0 && this.data[i/2]<this.data[i]){
        swap(this.data, i/2, i);
        i = i/2;
    }
}

// 交换数据
private void swap(int array[], int i, int j){
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}
```

#### 2.3.3.删除堆顶元素

从堆的定义中我们知道：任何节点的值都大于等于(或小于等于)子树节点的值，那也就是说堆顶元素存储的就是堆中数据的最大值或者最小值。

假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。如下图：

![删除堆顶元素](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107181.PNG)

我们可以换一个思路来考虑这个问题：我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。

因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性：

![删除堆顶元素2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107971.PNG)

我们将刚刚所讲的代码实现如下：

```java
// 删除堆顶元素
public int removeMax(){
    // 最大堆顶，数组下标为1的为最大值
    int max = data[1];
    // 移除完成后要保证堆的完整性，需要寻找第二大的元素放到堆顶
    // 1.将最后一个元素直接放在堆顶，并减少数据
    data[1] = data[count--];
    // 2.堆化让其继续成为一个合格的堆，此时需要自上而下堆化
    heapifyFromTop2Buttom(data, 1, count);
    return max;
}

// 将数据堆化：自上而下
private void heapifyFromTop2Buttom(int[] data, int begin, int end){

    while (2*begin <= end){

        // 与左子节点比较
        if(data[begin] < data[2*begin]){
            // 小于左子节点
            swap(data, begin, 2*begin);
            begin = 2*begin;
        }else if(2*begin+1 <= end && data[begin]< data[2*begin+1]){
            // 若有右子节点，且小于小于右子节点
            swap(data, begin, 2*begin+1);
            begin = 2*begin+1;
        }else{
            break;
        }
    }
}
```

#### 3.3.4 时间复杂度分析

通过之前的学习我们知道，一个包含n个节点的完全二叉树，树的高度不会超过[log_2(n)]+1。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是O(logn) 。插入数据和删除堆顶元素的主要逻辑就是堆化， 所以， 往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)

### 3.4 堆的应用

借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定， 是O(nlogn) ， 并且它还是原地排序算法。我们可以把堆排序的过程大致分解成两个大的步骤，建堆和排序。

算法描述如下：

1. 将初始待排序关键字序列(R1, R2, ...., Rn)构建成大顶堆，此堆为初始的无序区；
2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1, R2, ......, R_{n-1}]和新的有序区(Rn)，且满足R[1, 2, ..., n-1]<=R[n]；
3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1，R2，....Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1，R2...R{n-2})和新的有序区(R{n-1}，Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

#### 3.4.1 先建堆

如果给定一个数组，我们要把这个数组中的数据变成符合堆的数据存储，意味着将原始数据变成堆，并且我们是在原地将原始数据变成堆，所谓的原地操作也就是空间复杂度为0(1)的操作，无需额外的内存空间即可完成。那如何建堆呢?

第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含n个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为1的数据。然后，我们调用前面讲的插入操作，将下标从2到n的数据依次插入到堆中。这样我们就将包含n个数据的数组，组织成了堆，这里面的堆化操作是属于自下而上的堆化操作。

第二种实现思路，跟第一种截然相反，第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。

下面以图示的形式解释一下第二种实现思路。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了，那第一个非叶子节点如何找呢？别忘记堆是一个完全二叉树，**堆中最后一个元素下标除以2取整就是第一个非叶子节点的下标位置**。

![初始堆有序](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107433.PNG)

代码实现如下：

```java
// 建堆：建大顶堆，堆化是自上而下堆化
public void buildHeap(int[] array, int n){
    // 从后往前处理数组数据，堆化的时候是自上而下堆化
    for(int i=n/2; i>0 ; i--){
        heapifyFromTop2Buttom(array, i, n);
    }
}
```

从代码的实现逻辑上我们发现，我们对下标从k/2开始到1的数据进行堆化，下标是k/2+1到k的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从k/2+1到k的节点都是叶子节点。那我们建堆操作的时间复杂度是多少呢?

我们可以大致分析一下：

首先每个节点堆化的复杂度是：O(logn) ， 跟我们堆化了多少个节点呢?大约是n/2+1个节点， 所以这么看时间复杂度是O(nlogn) ，当然了这么推导出来的也没有错误，只是不够精确，实际上建堆操作的时间复杂度是O(n)，由于推导的过程涉及很多数学知识在此我们就不做过多推导，你暂时理解就行。

#### 3.4.2 后排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为n的位置，将剩下的n-1个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为的一个元素，排序工作就完成了，这个过程有点类似上面讲的“删除堆顶元素"的操作

排序代码如下：

```java
// 堆排序：分两步
public void heapSort(int[] array){
    // 1.建堆
    buildHeap(array, array.length-1);
    // 2.排序
    sort(array, array.length-1);
}

/**
 * 排序：
 * 我们把堆顶元素跟最后一个元素交换，然后对1~n-1区间的元素在堆化
 * 然后再将堆顶元素跟最后一个元素互换继续操作
 * @param array
 * @param n
*/
private void sort(int[] array, int n){
    while (n>1){
        swap(array, 1, n);
        heapifyFromTop2Buttom(array, 1, --n);
    }
}
```

加上之前建堆的代码整个堆排序的代码就完成了，接下来编写测试代码进行测试：

```java
public static void main(String[] args) {
    // 准备一个int数组
    int[] arrrays = new int[7];
    arrrays[1] = 2;
    arrrays[2] = 6;
    arrrays[3] = 9;
    arrrays[4] = 0;
    arrrays[5] = 3;
    arrrays[6] = 5;
    // 进行排序
    System.out.println(Arrays.toString(arrrays));
    // 堆排序
    Heap heap = new Heap(7);
    heap.heapSort(arrrays);
    System.out.println("原始数组: "+Arrays.toString(arrrays));
    System.out.println("堆排序: "+Arrays.toString(arrrays));

    heap.insert(2);
    heap.insert(6);
    heap.insert(9);
    heap.insert(0);
    heap.insert(3);
    heap.insert(5);
    System.out.println(heap);
    for (int i = 0; i < heap.SIZE-1; i++) {
        System.out.print(heap.removeMax()+", ");
    }
}
```

#### 3.4.3 复杂度分析

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。

堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn) ， 所以， 堆排序整体的时间复杂度是O(nlogn) 。堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

**堆排序和快排等相同复杂度的同类排序算法的比较：**

1. 堆排序数据访问的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。 
2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。
3. 从实际应用来说我们一般使用快排使用的多。

## 3. 图

### 3.1 图的定义及相关概念

在前面的章节中我们学习了树这种非线性表数据结构，那么在本章节中我们要讲另一种非线性表数据结构， 图(Graph) 。图和树比起来， 这是一种更加复杂的非线性表结构，那到底什么是图呢？直接说定义可能不是很好理解，那我们直接看下方图示：

![图的定义](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107314.PNG)

以前学习树的时候， 树中的元素我们称之为节点Node， 现在在图中的每一个元素我们称之为**顶点(Vertex)** ， 并且图中的一个顶点可以与其他任意顶点建立连接关系， 我们把这种建立的关系叫做**边(Edge)** ，我们阐述了图的概念，也对图有了一个直观的认识，那我们想一想生活中有没有跟图相同或者类似的结构呢?

实际上，生活中的社交网络就是一个非常典型的图的结构，比如微博，微信，每个人都有好友，可以互相关注，等等。

我们就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的**度(degree)** ， 就是跟顶点相连接的边的条数。

实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户A关注了用户B，但用户B可以不关注用户A。那我们如何用图来表示这种单向的社交关系呢?

我们可以把刚刚讲的图结构稍微改造一下，引入边的“方向”的概念。如果用户A关注了用户B，我们就在图中画一条从A到B的带箭头的边，来表示边的方向。如果用户A和用户B互相关注了，那我们就画一条从A指向B的边，再画一条从B指向A的边。我们把这种边有方向的图叫作“有向图”。以此类推，我们把边没有方向的图就叫作“无向图”。

![有向图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107709.PNG)

我们刚刚讲过，无向图中有“度"这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为**入度(In-degree)** 和**出度(Out-degree)** 。

顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。前面讲到了微信、微博、无向图、有向图，现在我们再来看另一种社交软件：QQ。QQ中的社交关系要更复杂的一点。不知道你有没有留意过QQ亲密度这样一个功能。QQ不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。如何在图中记录这种好友关系的亲密度呢?

这里就要用到另一种图， 带权图(weighted graph) 。在带权图中， 每条边都有一个权重(weight) ， 我们可以通过这个权重来表示QQ好友间的亲密度。

![带权图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107207.PNG)

### 3.2 图的存储方式

理解了图的概念之后，那我们想如何在内存中存储一个图呢？其实图有很多中存储形式包括：邻接矩阵，邻接表，十字链表，邻接多重表，边集数组等等，在今天的课程中我们主要讲解其中的两种存储：邻接矩阵和邻接表

#### 3.2.1 邻接矩阵存储图

邻接矩阵存储图底层依赖一个二维数组，对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将`A[i][j]`和`A[j][i]`标记为1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点i指向顶点 j 的边，那我们就将`A[i][j]`标记为1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将`A[j][i]`标记为1。对于带权图，数组中就存储相应的权重。

![邻接矩阵2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107602.PNG)

于使用邻接矩阵来存储图的特点是：简单，直观。但是也有一定的缺点就是浪费存储空间，比如对于上面图示的情况来看第一种无向图的存储，`A[i][j]`等于1那么`A[j][i]`也等于1，在那个二维数组中我们沿着对角线划分为上下两部分，两部分其实是对称的，其实我们只需要一半的存储空间就够了，另一半算是浪费了，比如微信用户好几亿，但是每个用户的好友并不会很多，基本在三五百左右，这种情况下如果邻接矩阵来存储，很大一部分存储空间都浪费，所以我们可以总结出来邻接矩阵存储的适用场景。

适用场景：使用于稠密的图，可以快速定位到指定的边，但是如果是稀疏的图，会比较浪费空间。

#### 3.2.2 邻接表存储图

针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，邻接表(Adjacency List) 。下面用一幅图示来描述一下邻接表存储图：

![邻接表2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107186.PNG)

初步一看邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。

当然了上面使用邻接矩阵存储图的好处是直观简单方便，但是缺点是浪费存储空间，相反的邻接表存储图的好处就是比较节省存储空间，但是缺点就是时间成本教高。

就像图中的例子，如果我们要确定，是否存在一条从顶点2到顶点4的边，那我们就要遍历顶点2对应的那条链表，看链表中是否存在顶点4。在散列表那几节里，我讲到，在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。我们刚刚也讲到，邻接表长得很像散列。所以，我们也可以将邻接表同散列表一样进行“改进升级”。

我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。

#### 3.2.3 图存储的案例

前面我们讲到社交关系我们可以用图来进行存储，像微博社交关系我们可以使用有向图进行存储，微信社交关系可以使用无向图进行存储；我们课程第一天就讲到数据结构是为算法服务的，我们如何存储取决于我们要做什么操作，现假设有如下一个案例：

在微博社交中需要满足如下操作：

1. 需要能够判断A用户是否关注了B用户
2.  需要能够判断C用户是否是Ｄ用户的粉丝
3. 需要能够满足用户E去关注用户F
4. 需要能够根据用户名称排序获取该用户的粉丝列表
5.  需要能够根据用户名称排序获取该用户所关注的用户列表

要想满足以上要求，首先从节省存储空间的角度来考虑我们选用邻接表来进行存储，但是只用邻接表的话我们能够满足的是判断A用户是否关注了B用户，我们只需要在A用户所在的链表上去查找是否存在Ｂ用户即可，存在则表明关注了不存在则表明没有关注；用户E去关注用户F需要进行的操作就是在用户E的链表中添加用户F。

不过，用一个邻接表来存储这种有向图是不够的。我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。基于此，我们需要一个**逆邻接表**。邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找。

![逆邻接表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107019.PNG)

### 3.3 图的应用-搜索算法

我们知道，算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的，因为图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图"。当然了这两种搜索算法不仅可以用在图上，也可以用在树上。

图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最“暴力”的深度优先、广度优先搜索， 还有`A*`、`IDA*`等启发式搜索算法。

接下来我们就来讲解一下基于图的两种搜索算法：广度优先搜索和深度优先搜索，关注这两种算法的实现我们使用的是邻接表来存储图，而且图采用的是无向图。所以我们先定义出来图的结构

```java
public class UndirGraph {

    // 图中顶点个数
    private int points;

    // 邻接表:有点类似散列表
    private LinkedList<Integer>[] adjcencyList;

    public UndirGraph(int points) {
        this.points = points;
        // 初始化数组
        adjcencyList = new LinkedList[points];
        for (int i = 0; i < points; i++) {
            adjcencyList[i] = new LinkedList<>();
        }
    }

    // 向图中添加顶点/边
    public void addEdge(int s, int t){
        // 无向图一条边两个顶点中都存储
        adjcencyList[s].add(t);
        adjcencyList[t].add(s);
    }
}
```

#### 3.3.1 广度优先搜索BFS

广度优先搜索算法(Breadth-First-Search) ， 是一种图形搜索算法， 直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。

![广度优先](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252107337.PNG)

简单的说， BFS是从根节点开始， 沿着树(图) 的宽度遍历树(图) 的节点。如果所有节点均被访问， 则算法中止， 一般用队列数据结构来辅助实现BFS算法。我们假设要从图中源顶点S找到目标顶点T，我们搜索出一条从S到T的路径，则步骤如下：

算法步骤：

1. 首先将源顶点放入队列中。
2. 从队列中取出第一个顶点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子顶点加入队列中。
3. 若队列为空，表示整张图都检查过了――亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。
4. 重复步骤2.

实际上我们这样求解出来的路径就是从S到T的最短路径。算法实现如下：

```java
// 从源顶点到目标顶点的广度优先搜索BFS
public void bfs(int source, int target){
    if(source == target){
        return;
    }

    // 定义一个boolean数组记录顶点是否被访问过
    boolean[] visited = new boolean[this.points];
    visited[source] = true;
    // 定义一个队列，用来放将要遍历的节点
    Queue<Integer> queue = new LinkedList<>();
    // 将源头顶点加入队列中
    queue.add(source);
    // 定义一个数组，记录从源顶点到目标顶点之间的路线
    int[] path = new int[this.points];
    for (int i = 0; i < this.points; i++) {
        path[i] = -1;
    }
    while (!queue.isEmpty()){
        // 从队列中取出元素
        Integer p = queue.poll();
        // 标识p已经被访问了
        visited[p] = true;
        // 从邻接表中取出跟该顶点相连的顶点链表
        for (int j = 0; j < adjcencyList[p].size(); j++) {
            // 取出与顶点p相连的顶点
            Integer pp = adjcencyList[p].get(j);
            // 该顶点还没有被访问过
            if(!visited[pp]){
                // 记录pp之前的顶点是p
                path[pp] = p;
                // 判断顶点p相连的顶点pp是否为目标顶点
                if(pp == target){
                    // 若是，则找到了，打印顶点
                    print(path, source, target);
                    return;
                }
                queue.add(pp);
            }
        }
    }
}

// 递归打印从s到t之间的线路
private void print(int[] path, int source, int target){
    if(path[target]!=-1 && path[source]!=-1){
        print(path, source, path[target]);
    }

    System.out.print(target + "->");
}
```

掌握了广优先搜索算法的原理，我们来看下，广度优先搜索的时间、空间复杂度是多少呢？

最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，**广度优先搜索的时间复杂度也可以简写为O(E)**。

广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、path数组上。这三个存储空间的大小都不会超过顶点的个数，所以**空间复杂度是O(V)**。

#### 3.3.2 深度优先搜索DFS

深度优先搜索(Depth-First-Search) ， 简称DFS。最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。

走迷宫的例子很容易能看懂，我们现在再来看下，如何在图中应用深度优先搜索，来找某个顶点到另一个顶点的路径。你可以看我画的这幅图：

![深度优先搜索](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108194.PNG)

搜索的起始顶点是s，终止顶点是t，我们希望在图中寻找一条从顶点s到顶点t的路径。如果映射到迷宫那个例子，s就是你起始所在的位置，t就是出口。我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点s到顶点t的最短路径。实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程， 非常适合用递归来实现。回溯思想我们后面会学习到， 我们现将DFS实现如下：

```java
// 从源顶点到目标顶点的深度优先搜索DFS
public void dfs(int source, int target){
    if(source == target){
        return;
    }
    // 定义一个boolean数组记录顶点是否被访问过
    boolean[] visited = new boolean[this.points];
    visited[source] = true;

    // 定义一个数组，记录从源顶点到目标顶点之间的路线
    int[] path = new int[this.points];
    for (int i = 0; i < this.points; i++) {
        path[i] = -1;
    }
    // 递归调用
    recurDFS(source, target, visited, path);
    // 打印路线
    print(path, source, target);
}

private void recurDFS(int point, int target, boolean[] visited, int[] path){
    // 标识point已经被访问了
    visited[point] = true;

    // 找到目标节点了 返回
    if(point == target){
        return;
    }
    // 获取当前节点相连的所有顶点
    for (int j = 0; j < adjcencyList[point].size(); j++) {
        // 获取与point相连的顶点p
        Integer p = adjcencyList[point].get(j);
        if(!visited[p]){
            // 还没有被调用过则递归遍历
            path[p] = point;
            recurDFS(p, target, visited, path);
        }
    }
}
```

从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的**时间复杂度是O(E)，E表示边的个数**。深度优先搜索算法的消耗内存主要是visited、path数组和递归调用栈。

visited、path数组的大小跟顶点的个数Ⅴ成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的**空间复杂度就是O(V)**。

#### 3.3.3 测试代码

```java
public static void main(String[] args) {
    // 定义一个图
    UndirGraph graph = new UndirGraph(6);
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(0, 3);
    graph.addEdge(0, 4);
    graph.addEdge(1, 2);
    graph.addEdge(1, 4);
    graph.addEdge(2, 4);
    graph.addEdge(2, 5);
    graph.addEdge(3, 5);
    graph.addEdge(4, 5);

    graph.bfs(0, 5);  // 0->1->2->5->
    graph.dfs(0, 5);  // 0->1->2->4->5->
}
```

## 4. 字符串匹配/查找算法

在本章中我们要来学习字符串匹配算法，对于字符串匹配，每个工程师在实际的企业开发中都经常会用到， 比如在java中提供的indexOf()， starWith()， endWith()，这些方法的底层就依赖了字符串匹配算法。

当然了字符串匹配算法有很多，总体来说我们选择其中比较经典的几种算法来讲解：BF算法， RK算法， BM算法， KMP算法； 以上这些算法都是单模式的字符串匹配算法，即一个串跟一个串进行匹配，除了单模式匹配算法我们还会讲解两种多模式字符串匹配， 也就是在一个串中同时查找多个串， 即Trie树和AC自动机。

### 4.1 BF算法

**原理**

BF算法， 即**暴风(Brute Force)** 算法， 也叫朴素匹配算法， 是普通的模式匹配算法，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高，所以BF算法也是一种蛮力算法。

在正式讲解之前我们要先来明确几个概念，方便后续课程的讲解：模式匹配，主串和模式串

所谓模式匹配：即子串P(模式串)在主串T(目标串)中的定位运算，也称串匹配。假设我们有两个字符串：T(Target， 目标串， 主串) 和 P(Pattern， 模式串， 子串) ；在主串T中查找模式串P的定位过程，称为模式匹配。

比方说，我们在字符串A中查找字符串B，那字符串A就是主串(目标串T)，字符串B就是模式串(字串P)。我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n>m。

模式匹配有两种结果：

* 主串中找到模式为P的子串，返回P在T中的起始位置下标值；
* 未成功匹配，返回-1

**BF算法的思路：**

我们在主串中，检查起始位置分别是0、1、2、...、n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的，思路图如下：

![BF字符串匹配](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108727.PNG)

**实现：**

```java
public class BF {

    // 使用BF算法在主串T中匹配模式串P
    public static int bf(String target, String pattern){
        if(target==null || target.length()==0 || pattern==null || pattern.length()>target.length()){
            return -1;
        }

        // 将单一字符串转换成数组
        char[] target_array = target.toCharArray();
        char[] pattern_array = pattern.toCharArray();

        return match(target_array, pattern_array);
    }

    private static int match(char[] target, char[] pattern){
        int i = 0; // 主串下标
        int j = 0; // 模式串下标
        int position = 0; // 匹配到的位置

        while (i < target.length && j < pattern.length){
            if(target[i] == pattern[j]){
                // 匹配成功目标串和模式串进行下一个字符的匹配
                i++;
                j++;
            }else{
                // 匹配失败，则目标字符串的下一个位置开始新匹配
                i = i-j+1;
                j = 0;
            }
        }

        if(j != 0){{
            position = i-j;
        }else {
            position = -1;
        }

        return position;
    }

    public static void main(String[] args) {
        String a = "abccbadef";
        String b = "cba";
        System.out.println("匹配下标为：" + bf(a, b));
    }

}
```

从上面的实现情况可以看出：

比如主串是“aaaaa...aaaaaa”(省略号表示有很多重复的字符a) ， 模式串是“aaaaab”。我们每次都比对m个字符， 要比对n-m+1次，所以，这种算法的最坏情况时间复杂度是O(n×m)。

尽管理论上，**BF算法的时间复杂度很高，是O(n×m)，n是主串的长度，m是模式串的长度**，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢?原因有两点。

第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n×m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。

第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错， 如果有bug也容易暴露和修复。在工程中， 在满足性能要求的前提下， 简单是首选。这也是我们常说的**KISS(Keep it Simple and Stupid) 设计原则**。

所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。

### 4.2 RK算法

**原理**

RK算法的全称叫Rabin-Karp算法， 是由它的两位发明者Rabin和Karp的名字来命名的。它是BF算法的升级版，主要在这个算法中引入了哈希算法。

BF算法中如果模式串长度为m，主串长度为n，那在主串中，就会有n-m+1个长度为m的子串，我们只需要暴力地对比这n-m+1个子串与模式串，就可以找出主串与模式串匹配的子串。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以BF算法的时间复杂度就比较高，是O(n×m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低；那如何引入哈希算法呢?

我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串不相等，那这个字串和模式串必定不等，如果某个字串的哈希值与模式串的哈希值相等，则该字串与模式串不一定相等，因为有哈希冲突的存在，如果出现了哈希冲突后我们可以采用BF算法思想对该子串和模式串进行暴力匹配；因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢?

这就需要我们设计良好的哈希函数，我们假设要匹配的字符串的字符集中只包含R个字符，我们可以用一个R进制数来表示一个子串，这个R进制数转化成十进制数，作为子串的哈希值。举个例子：

比如要处理的字符串只包含a~z这26个小写字母，那我们就用二十六进制来表示一个字符串。我们把a~z这26个字符映射到0~25这26个数字，a就表示0，b就表示1，以此类推，z表示25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含a到z这26个字符的字符串，计算哈希的时候，我们只需要把进位从10改成26就可以。

![二十六进制](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108357.PNG)

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系，如下图：

![RK算法](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108223.PNG)

相邻两个子串s[i-1]和s[i]（i表示子串在主串中的起始位置，子串的长度都为m）对应的哈希值计算公式有交集，也就是说，我们可以使用s[i-1]的哈希值很快的计算出s[i]的哈希值。如果用公式表示的话，就是下面这个样子

![RK算法2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252108111.PNG)

不过，这里有一个小细节需要注意，那就是26^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26^0、26^1、26^2、...、26^(m-1)，并且存储在一个长度为m的数组中，公式中的“次方”就对应数组的下标。当我们需要计算26的x次方的时候，就可以从数组的下标为x的位置取值，直接使用，省去了计算的时间。

**那如何来计算一个串的哈希值呢?**

通过上面的分析我们可以将一个字符串看成R=26进制的数，这样在比较的时候比较其换算成十进制后的数字，但是可能一个26进制的数换算成10进制后太大，甚至有可能超过了java中int类型的范围， 那这时该如何处理呢？

我们还可以借助另一个哈希函数，取模运算。

取模运算：“%”， hash=key%M， 其中M一般是素数， 否则可能无法利用key中包含的所有信息。如key是十进制数而Ｍ是10的k次方， 那么只能利用key的后K位，不均匀，增加碰撞概率。

%运算也适用于字符串，将字符串看成一个若干位Ｒ进制的整数，不同的是R并不一定非得大于其字符集的个数，可以适当进行调整，常常选取质数；通过我们刚刚分析的哈希值的求解过程可写出hash算法的大致实现如下：

```java
public int hash(String s, int M){
    int hash = 0;
    int R = 101;  // 进制
    for (int i = 0; i < s.length(); i++) {
        hash = R*hash + s.charAt(i);
    }
    return hash % M;
}
```

这种计算方式当charAt方法返回的值过大或R太大时可能造成溢出， 所以我们可以调整如下：

```java
public int hash(String s, int M){
    int hash = 0;
    int R = 101;  // 进制
    for (int i = 0; i < s.length(); i++) {
        hash = (R*hash + s.charAt(i)) % M;
    }
    return hash % M;
}
```

和利用了%运算的基本性质，对于两个正整数a、b，有：

```
(a+b)%n = (a%n+b%n)%n
(a-b)%n = (a%n-b%n+n)%n
(a×b)%n = (a%n×b%n)%n
```

**实现：**

```java
public class RK {
    
    /**
     * 求一个字符串的hash值
     * @param str    字符串
     * @param R      对应的进制
     * @param K      将字符串映射到K的范围内
     * @param start  从str串的start位置开始
     * @param len    模式串的长度
     * @return       对应的hash值
     */
    private static int hash(String str, int R, int K, int start, int len){
        int hash = 0;
        for (int i = start; i < start+len; i++) {
            hash = (R*hash + str.charAt(i)) % K;
        }
        return hash % K;
    }

    private static boolean match(String target, String pattern, int i){
        for (int j = 0; j < pattern.length(); j++) {
            if(pattern.charAt(j) != target.charAt(j+i)){
                return false;
            }
        }
        return true;
    }

    // 使用RK算法在主串target中匹配模式串pattern
    public static int rk(String target, String pattern){
        if(target==null || target.length()==0 || pattern==null || pattern.length()>target.length()){
            return -1;
        }

        int pattern_hash = hash(pattern, 26, 31, 0, pattern.length());
        for (int i = 0; i < target.length() - pattern.length() + 1; i++) {
            if(hash(target, 26, 31, i, pattern.length()) == pattern_hash){
                if(match(target, pattern, i)){
                    return i;
                }
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        String a = "abcedfg";
        String b = "fg";
        System.out.println("匹配下标为：" + RK.rk(a, b));
    }
}
```

整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是O(n)。模式串哈希值与每个子串哈希值之间的比较的时间复杂度是O(1)，总共需要比较n-m+1个子串的哈希值，所以，这部分的时间复杂度也是O(n)。所以，RK算法整体的时间复杂度就是O(n)。跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为O(n×m)。

## 5. 总结

### 5.1 堆

堆：堆其实是一个满足特殊条件的树，其条件有：

1. 堆是一个完全二叉树；
2. 堆中每一个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值

堆的存储使用数组来存储，由于堆的特点使得用数组来存储堆访问起来更快。

堆排序：分为两步

1. 先建堆
2. 排序

### 5.2 图

图的存储有两种形式：邻接矩阵和邻接表

图的两种应用：BFS搜索算法和DFS搜索

### 5.3 字符串匹配

单模式的字符串匹配算法：BF，RK

