# 数据结构：学习笔记-3

> 前些天看了《大话数据结构》，大致对数据结构有了些许了解，现又找了些视频巩固巩固，课程连接：[黑马:数据结构与算法](https://www.bilibili.com/video/BV1iJ411E7xW)，依据上述课程做了下学习笔记，总共分为3篇，此为3/3。

## 11. 图的入门

### 11.1 图的实际应用

​	在现实生活中，有许多应用场景会包含很多点以及点与点之间的连接，而这些应用场景我们都可以用即将要学习的图这种数据结构去解决。 

**地图：** 

​	我们生活中经常使用的地图，基本上是由城市以及连接城市的道路组成，如果我们把城市看做是一个一个的点，把道路看做是一条一条的连接，那么地图就是我们将要学习的图这种数据结构。 

![图的实际应用1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114496.PNG)

**电路图：** 

​	下面是一个我们生活中经常见到的集成电路板，它其实就是由一个一个触点组成，并把触点与触点之间通过线进行连接，这也是我们即将要学习的图这种数据结构的应用场景。 

![图的实际应用2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114723.PNG)

### 11.2 图的定义及分类 

**定义：**图是由一组顶点和一组能够将两个顶点相连的边组成的 

![图的定义](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114753.PNG)

**特殊的图：** 

1. 自环：即一条连接一个顶点和其自身的边；
2. 平行边：连接同一对顶点的两条边； 

![特殊的图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114602.PNG)

**图的分类：**

按照连接两个顶点的边的不同，可以把图分为以下两种：

无向图：边仅仅连接两个顶点，没有其他含义；

有向图：边不仅连接两个顶点，并且具有方向； 

### 11.3 无向图 

#### 11.3.1 图的相关术语 

**相邻顶点：**当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。

**度：**某个顶点的度就是依附于该顶点的边的个数

**子图：**是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；

**路径：**是由边顺序连接的一系列的顶点组成

**环：**是一条至少含有一条边且终点和起点相同的路径 

![图的环](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114425.PNG)

**连通图：**如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图 

**连通子图：**一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图 

![连通子图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114336.PNG)

#### 11.3.2 图的存储结构 

要表示一幅图，只需要表示清楚以下两部分内容即可：
1. 图中所有的顶点；
2. 所有连接顶点的边；

常见的图的存储结构有两种：邻接矩阵和邻接表 

##### 11.3.2.1 邻接矩阵 

1. 使用一个V*V的二维数组`int [V][V] adj`,把索引的值看做是顶点；
2. 如果顶点v和顶点w相连，我们只需要将`adj[v][w]`和`adj[w][v]`的值设置为1,否则设置为0即可。 

![邻接矩阵](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114172.PNG)

​	很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。 

##### 11.3.2.2 邻接表

1. 使用一个大小为V的数组 `Queue[V] adj`，把索引看做是顶点；
2. 每个索引处`adj[v]`存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点 

![邻接表](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114625.PNG)

很明显，邻接表的空间并不是是线性级别的，所以后面我们一直采用邻接表这种存储形式来表示图。 

#### 11.3.3 图的实现 

##### 11.3.3.1 图的API设计 

| 类名     | Graph                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Graph(int V)：创建一个包含V个顶点但不包含边的图              |
| 成员方法 | 1.public int V():获取图中顶点的数量 <br />2.public int E():获取图中边的数量 <br />3.public void addEdge(int v,int w):向图中添加一条边 v-w <br />4.public Queue adj(int v)：获取和顶点v相邻的所有顶点 |
| 成员变量 | 1.private final int V: 记录顶点数量 <br />2.private int E: 记录边数量 <br />3.private Queue[] adj: 邻接表 |

##### 11.3.3.2 代码实现 

```java
public class Graph {

    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    public Graph(int v) {
        //初始化顶点数量
        this.V = v;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[this.V];

        for (int i=0; i<V; i++){
            adj[i] = new Queue<Integer>();
        }
    }

    //获取顶点数目
    public int V(){
        return this.V;
    }

    //获取边的数目
    public int E(){
        return this.E;
    }

    //向图中添加一条边 v-w
    public void addEdge(int v, int w){
        //在无向图中，边是没有方向的，所以该边既可以说是从v到w的边，又可以说是从w到v的边，
        // 因此，需要让w出现在v的邻接表中，并且还要让v出现在w的邻接表中
        adj[v].enqueue(w);
        adj[w].enqueue(v);
        //边的数量+1
        this.E++;
    }

    //获取和顶点v相邻的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];
    }

    public static void main(String[] args) {
        Graph graph = new Graph(7);
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(0, 5);
        graph.addEdge(0, 6);
        graph.addEdge(3, 4);
        graph.addEdge(3, 5);
        graph.addEdge(4, 5);
        graph.addEdge(6, 4);

        System.out.println("图中的边数目" + graph.E());

        System.out.println("节点0相邻的节点有:");
        for(Integer v: graph.adj(0)){
            System.out.print(v + " ");
        }
    }
}
```

#### 11.3.4 图的搜索 

​	在很多情况下，我们需要遍历图，得到图的一些性质，例如，找出图中与指定的顶点相连的所有顶点，或者判定某个顶点与指定顶点是否相通，是非常常见的需求。

有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，接下来我们分别讲解这两种搜索算法。 

##### 11.3.4.1 深度优先搜索 

​	所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。 

![图的搜索](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114252.PNG)

​	很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，如果没有搜索，标记为false； 

**API设计：** 

| 类名      | DepthFirstSearch                                             |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点 |
| 成员方 法 | 1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 <br />2.public boolean marked(int w):判断w顶点与s顶点是否相通 <br />3.public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变 量 | 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 <br />2.private int count：记录有多少个顶点与s顶点相通 |

**代码：** 

```java
public class DepthFirstSearch {

    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;

    //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public DepthFirstSearch(Graph graph, int s) {
        //初始化marked数组
        this.marked = new boolean[graph.V()];
        //初始化跟顶点s相通的顶点的数量
        this.count = 0;

        dfs(graph, s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void dfs(Graph graph, int v){

        //把v顶点标识为已搜索
        marked[v] = true;

        for(Integer w: graph.adj(v)){
            //判断当前w顶点有没有被搜索过，如果没有被搜索过，则递归调用dfs方法进行深度搜索
            if(!marked[w]){
                dfs(graph, w);
        		this.count++;
            }
        }
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return this.count;
    }

    public static void main(String[] args) {

        //准备Graph对象
        Graph graph = new Graph(13);
        graph.addEdge(0,5);
        graph.addEdge(0,1);
        graph.addEdge(0,2);
        graph.addEdge(0,6);
        graph.addEdge(3,4);
        graph.addEdge(4,6);
        graph.addEdge(5,3);
        graph.addEdge(5,4);
        graph.addEdge(7,8);
        graph.addEdge(9,10);
        graph.addEdge(9,11);
        graph.addEdge(9,12);
        graph.addEdge(11,12);

        //准备深度优先搜索对象
        DepthFirstSearch dfSearch = new DepthFirstSearch(graph, 0);
        //测试与某个顶点相通的顶点数量
        int count = dfSearch.count();
        System.out.println("与起点0相通的顶点的数量为:"+count);

        //测试某个顶点与起点是否相同

        System.out.println("顶点5和顶点0是否相通："+dfSearch.marked(5));

        dfSearch.marked(5);
        System.out.println("顶点7和顶点0是否相通："+dfSearch.marked(7));
    }
}
```

##### 11.3.4.2 广度优先搜索 

​	所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。 

![广度优先](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114110.PNG)

**API设计：** 

| 类名      | BreadthFirstSearch                                           |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 |
| 成员方 法 | 1.private void bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点 <br />2.public boolean marked(int w):判断w顶点与s顶点是否相通 <br />3.public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变 量 | 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 <br />2.private int count：记录有多少个顶点与s顶点相通 <br />3.private Queue waitSearch: 用来存储待搜索邻接表的点 |

**代码：** 

```java
public class BreadthFirstSearch {

    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;
    //用来存储待搜索邻接表的点
    private Queue<Integer> waitSearch;

    //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点
    public BreadthFirstSearch(Graph graph, int s) {
        this.marked = new boolean[graph.V()];
        this.count=0;
        this.waitSearch = new Queue<Integer>();

        bfs(graph, s);
    }

    //使用广度优先搜索找出G图中v顶点的所有相邻顶点
    private void bfs(Graph graph, int v){
        //把当前顶点v标识为已搜索
        marked[v] = true;
        //让顶点v进入队列，待搜索
        waitSearch.enqueue(v);
        System.out.print("节点"+v+"广度遍历顺序为："+v);
        //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索
        while (!waitSearch.isEmpty()){
            //弹出一个待搜索的顶点
            Integer wait = waitSearch.dequeue();

            //遍历wait顶点的邻接表
            for(Integer w: graph.adj(wait)){
                // 该顶点还没被搜索过 对其进行搜索
                if(!marked(w)){
                    marked[w] = true;
                    // 将节点放入堆栈中，用于后续的获取该节点的子节点
                    waitSearch.enqueue(w);
                    //让相通的顶点+1；
                    count++;
                    System.out.print(" "+w);
                }
            }
        }
        System.out.println();
    }

    //判断w顶点与s顶点是否相通
    private boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return this.count;
    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 3);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);

        // 广度优先遍历:节点0广度遍历顺序为：0 1 3 4 2
        BreadthFirstSearch bfSearch = new BreadthFirstSearch(graph, 0);

        // 深度优先遍历：0 1 2 3 4
        DepthFirstSearch dfSearch = new DepthFirstSearch(graph, 0);

        //测试与某个顶点相通的顶点数量
        int count = bfSearch.count();
        System.out.println("与起点0相通的顶点的数量为:"+count);
    }
}
```

#### 11.3.5 案例-畅通工程续1 

​	某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。目前的道路状况，9号城市和10号城市是否相通？9号城市和8号城市是否相通？

在我们的测试数据文件夹中有一个traffic_project.txt文件，它就是诚征道路统计表，下面是对数据的解释： 

![畅通工程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114309.PNG)

​	总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？

**解题思路：** 

1. 创建一个图Graph对象，表示城市；
2. 分别调用`addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)`，表示已经修建好的道路把对应的城市连接起来；
3. 通过Graph对象和顶点9，构建`DepthFirstSearch`对象或`BreadthFirstSearch`对象；
4. 调用搜索对象的`marked(10)`方法和`marked(8)`方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相通。 

**代码：**

```java
public class TrafficProjectTest{

    public static void main(String[] args) throws Exception{
        //构建一个缓冲读取流BufferedReader
        BufferedReader br = new BufferedReader(
                new InputStreamReader(TrafficProjectTest.class.getClassLoader().getResourceAsStream("traffic_project.txt")));

        //读取第一行数据20
        int totalNumber = Integer.parseInt(br.readLine());

        //构建一个Graph对象
        Graph graph = new Graph(totalNumber);

        //读取第二行数据7
        int roadNumber = Integer.parseInt(br.readLine());

        //循环读取有限次(7)，读取已经修建好的道路
        for (int i = 0; i < roadNumber; i++) {
            String road = br.readLine();  //"0 1"
            String[] str = road.split(" ");
            int v = Integer.parseInt(str[0]);
            int w = Integer.parseInt(str[1]);

            //调用图的addEdge方法，把边添加到图中，表示已经修建好的道路
            graph.addEdge(v, w);
        }

        //构建一个深度优先搜索对象，起点设置为顶点9
        DepthFirstSearch dfSearch = new DepthFirstSearch(graph, 9);
        //构建一个广度优先搜索对象，起点设置为顶点9
        BreadthFirstSearch bfSearch = new BreadthFirstSearch(graph, 9);


        //调用marked方法，判断8顶点和10顶点是否与起点9相通
        System.out.println("广度优先：");
        System.out.println("    顶点8和顶点9是否相通：" + dfSearch.marked(8));
        System.out.println("    顶点10和顶点9是否相通：" + dfSearch.marked(10));
        System.out.println("深度优先：");
        System.out.println("    顶点8和顶点9是否相通：" + bfSearch.marked(8));
        System.out.println("    顶点10和顶点9是否相通：" + bfSearch.marked(10));

    }
}
```

#### 11.3.6 路径查找

​	在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是：从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。 

![路径查找](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114368.PNG)

例如在上图中查找顶点0到顶点4的路径用红色标识出来,那么我们可以把该路径表示为 0-2-3-4。 

##### 11.3.6.1 路径查找API设计 

| 类名      | DepthFirstPaths                                              |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | DepthFirstPaths(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为 s 的所有路径 |
| 成员方 法 | 1.private void dfs(Graph G, int v):使用深度优先搜索找出G图中v顶点的所有相邻顶点 <br />2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径 <br />3.public Stack<Integer> pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点) |
| 成员变 量 | 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 <br />2.private int s:起点 <br />3.private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 |

##### 11.3.6.2 路径查找实现 

​	我们实现路径查找，最基本的操作还是得遍历并搜索图，所以，我们的实现暂且基于深度优先搜索来完成。其搜索的过程是比较简单的。我们添加了edgeTo[]整型数组，这个整型数组会记录从每个顶点回到起点s的路径。

​	如果我们把顶点设定为0，那么它的搜索可以表示为下图： 

![路径查找实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114801.PNG)

根据最终edgeTo的结果，我们很容易能够找到从起点0到任意顶点的路径； 

**代码：** 

```java
public class DepthFirstPaths {

    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //起点
    private int s;
    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
    private int[] edgeTo;

    //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径
    public DepthFirstPaths(Graph graph, int s) {
        //初始化marked数组
        this.marked = new boolean[graph.V()];
        //初始化起点
        this.s = s;
        //初始化edgeTo数组
        this.edgeTo = new int[graph.V()];

        dfs(graph, s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相邻顶点
    private void dfs(Graph graph, int v){
        //把v表示为已搜索
        marked[v] = true;

        for(Integer w: graph.adj(v)){
            //如果顶点w没有被搜索，则继续递归搜索
            if(!marked[w]){
                edgeTo[w] = v;
                dfs(graph, w);
            }
        }
    }

    //判断w顶点与s顶点是否存在路径
    public boolean hasPathTo(int v){
        return marked[v];
    }

    //找出从起点s到顶点v的路径(就是该路径经过的顶点)
    public Stack<Integer> pathTo(int v){
        //该点不在路径中，直接返回空栈
        if(!hasPathTo(v)){
            return null;
        }

        //创建栈对象，保存路径中的所有顶点
        Stack<Integer> stack = new Stack<>();

        //通过循环，从顶点v开始，一直往前找，到找到起点为止
        for (int x=v; x!=this.s; x=edgeTo[x]){
            stack.push(x);
        }

        //放入起点
        stack.push(this.s);
        return stack;
    }

    public static void main(String[] args) throws Exception {

        //构建缓冲读取流BufferedReader
        BufferedReader br = new BufferedReader(
                new InputStreamReader(DepthFirstSearch.class.getClassLoader().getResourceAsStream("road_find.txt")));

        //读取第一行数据6
        int total = Integer.parseInt(br.readLine());
        //根据第一行数据构建一副图Graph
        Graph graph = new Graph(total);
        //读取第二行数据8
        int edgeNumbers = Integer.parseInt(br.readLine());
        //继续通过循环读取每一条边关联的两个顶点，调用addEdge方法，添加边
        for (int i = 0; i < edgeNumbers; i++) {
            String edge = br.readLine();//0 1
            String[] roads = edge.split(" ");
            int v = Integer.parseInt(roads[0]);
            int w = Integer.parseInt(roads[1]);
            graph.addEdge(v, w);
        }

        //构建路径查找对象，并设置起点为0
        DepthFirstPaths dfp = new DepthFirstPaths(graph, 0);
        //调用 pathTo(4)，找到从起点0到终点4的路径，返回Stack
        Stack<Integer> paths = dfp.pathTo(4);
        StringBuffer sb = new StringBuffer();
        for(Integer path: paths){
            sb.append(path+"->");
        }

        System.out.println(sb.substring(0, sb.length()-2).toString());
    }
}
```

## 12. 图的进阶

### 12.1 有向图

​	在实际生活中，很多应用相关的图都是有方向性的，最直观的就是网络，可以从A页面通过链接跳转到B页面，那么a和b连接的方向是a->b，但不能说是b->a，此时我们就需要使用有向图来解决这一类问题，它和我们之前学习的无向图，最大的区别就在于连接是具有方向的，在代码的处理上也会有很大的不同。 

![有向图举例](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114128.PNG)

#### 12.1.1 有向图的定义及相关术语 

**定义：**有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。

**出度：**由某个顶点指出的边的个数称为该顶点的出度。

**入度：**指向某个顶点的边的个数称为该顶点的入度。

**有向路径：**由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。

**有向环：**一条至少含有一条边，且起点和终点相同的有向路径。 

![有向环](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114327.PNG)

**一副有向图中两个顶点v和w可能存在以下四种关系：** 

1. 没有边相连； 
2. 存在从v到w的边v—>w;
3. 存在从w到v的边w—>v;
4. 既存在w到v的边，也存在v到w的边，即双向连接； 

理解有向图是一件比较简单的，但如果要通过眼睛看出复杂有向图中的路径就不是那么容易了。 

![有向图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114821.PNG)

#### 12.1.2 有向图API设计 

| 类名     | Digraph                                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Digraph(int V)：创建一个包含V个顶点但不包含边的有向图        |
| 成员方法 | 1.public int V():获取图中顶点的数量 <br />2.public int E():获取图中边的数量 <br />3.public void addEdge(int v,int w):向有向图中添加一条边 v->w <br />4.public Queue<Integer> adj(int v)：获取由v指出的边所连接的所有顶点 <br />5.private Digraph reverse():该图的反向图 |
| 成员变量 | 1.private final int V: 记录顶点数量 <br />2.private int E: 记录边数量 <br />3.private Queue<Integer>[] adj: 邻接表 |

​	在api中设计了一个反向图，其因为有向图的实现中，用adj方法获取出来的是由当前顶点v指向的其他顶点，如果能得到其反向图，就可以很容易得到指向v的其他顶点。 

#### 12.1.3 有向图实现 

```java
public class Digraph {

    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    public Digraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i < V; i++) {
            this.adj[i] = new Queue<Integer>();
        }
    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向有向图中添加一条边 v->w
    public void addEdge(int v, int w){
        //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，
        // 最终，顶点v的邻接表中存储的相邻顶点的含义是：  v->其他顶点
        this.adj[v].enqueue(w);
        this.E++;
    }

    //获取由v指出的边所连接的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];
    }

    //该图的反向图
    public Digraph reverse(){
        //创建有向图对象
        Digraph digraph = new Digraph(V);
        for (int v=0; v < V; v++) {
            //获取由该顶点v指出的所有边
            Queue<Integer> vs = adj[v];
            for(Integer w: vs){
                //原图中表示的是由顶点v->w的边 转为 w->v
                digraph.addEdge(w, v);
            }
        }
        return digraph;
    }
}
```

### 12.2 拓扑排序

​	在现实生活中，我们经常会同一时间接到很多任务去完成，但是这些任务的完成是有先后次序的。以我们学习java学科为例，我们需要学习很多知识，但是这些知识在学习的过程中是需要按照先后次序来完成的。从java基础，到jsp/servlet，到ssm，到springboot等是个循序渐进且有依赖的过程。在学习jsp前要首先掌握java基础和html基础，学习ssm框架前要掌握jsp/servlet之类才行。 

![拓扑排序1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114681.PNG)

为了简化问题，我们使用整数为顶点编号的标准模型来表示这个案例： 

![拓扑排序2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114114.PNG)

​	此时如果某个同学要学习这些课程，就需要指定出一个学习的方案，我们只需要对图中的顶点进行排序，让它转换为一个线性序列，就可以解决问题，这时就需要用到一种叫**拓扑排序**的算法。

**拓扑排序：**

​	给定一副有向图，将所有的顶点排序，**使得所有的有向边均从排在前面的元素指向排在后面的元素**，此时就可以明确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图。

![拓扑排序3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114566.PNG)

#### 12.2.1 检测有向图中的环 

​	如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个环： 

![有向环2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114878.PNG)

因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。 

##### 12.2.1.1 检测有向环的API设计 

| 类名      | DirectedCycle                                                |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | DirectedCycle(Digraph G)：创建一个检测环对象，检测图G中是否有环 |
| 成员方 法 | 1.private void dfs(Digraph G,int v)：基于深度优先搜索，检测图G中是否有环 <br />2.public boolean hasCycle():判断图中是否有环 |
| 成员变 量 | 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 <br />2.private boolean hasCycle: 记录图中是否有环 <br />3.private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 |

##### 12.2.1.2 检测有向环实现 

在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：
1. 在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；
2. 如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；
3. 如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环； 

![检测有向环实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114413.PNG)

**代码：** 

```java
public class DirectedCycle {

    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上
    private boolean[] onStack;

    //创建一个检测环对象，检测图G中是否有环
    public DirectedCycle(Digraph digraph) {
        //初始化marked数组
        this.marked = new boolean[digraph.V()];
        //初始化hasCycle
        this.hasCycle = false;
        //初始化onStack数组
        this.onStack = new boolean[digraph.V()];

        //找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索
        for (int v = 0; v < digraph.V(); v++) {
            //判断如果当前顶点还没有搜索过，则调用dfs进行搜索
            if(!marked[v]){
                dfs(digraph, v);
            }
        }
    }

    //基于深度优先搜索，检测图G中是否有环
    private void  dfs(Digraph digraph, int v){
        //把顶点v表示为已搜索
        this.marked[v] = true;
        //把当前顶点进栈
        this.onStack[v] = true;

        //进行深度搜索
        for (Integer w: digraph.adj(v)){
            //判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索
            if(!marked[w]){
                dfs(digraph, w);
            }

            //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了
            if(onStack[w]){
                this.hasCycle = true;
                return;
            }
        }
        //把当前顶点出栈
        this.onStack[v] = false;
    }

    //判断当前有向图G中是否有环
    public boolean hasCycle(){
        return hasCycle;
    }
}
```

#### 12.2.2 基于深度优先的顶点排序 

​	如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜索的基础上，添加一行代码，**只需要将搜索的顶点放入到线性序列的数据结构中**，我们就能完成这件事。 

##### 12.2.2.1 顶点排序API设计 

| 类名     | DepthFirstOrder                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstOrder(Digraph G)：创建一个顶点排序对象，生成顶点线性序列； |
| 成员方法 | 1.private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列 <br />2.public Stack reversePost():获取顶点线性序列 |
| 成员变量 | 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 <br />2.private Stack<Integer> reversePost: 使用栈，存储顶点序列 |

##### 12.2.2.2 顶点排序实现 

​	在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该顶点放入到reversePost中，这样就可以实现顶点排序。 

![顶点排序实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114708.PNG)

**代码：** 

```java
public class DepthFirstOrder {

    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //使用栈，存储顶点序列
    private Stack<Integer> reversePost;

    //创建一个顶点排序对象，生成顶点线性序列
    public DepthFirstOrder(Digraph digraph) {

        //初始化marked数组
        this.marked = new boolean[digraph.V()];
        //初始化reversePost栈
        this.reversePost = new Stack<Integer>();

        //遍历图中的每一个顶点，让每个顶点作为入口，完成一次深度优先搜索
        for (int v = 0; v < digraph.V(); v++) {
            if(!marked[v]){
                dfs(digraph, v);
            }
        }

    }

    //基于深度优先搜索，把顶点排序
    private void dfs(Digraph digraph, int v){
        //标记当前v已经被搜索
        this.marked[v] = true;
        for(Integer w: digraph.adj(v)){
            //如果当前顶点w没有搜索，则递归调用dfs进行搜索
            if(!marked[w]){
                dfs(digraph, w);
            }
        }

        //让顶点v进栈
        this.reversePost.push(v);
    }

    //获取顶点线性序列
    public Stack<Integer>  reversePost(){
        return reversePost;
    }
}
```

#### 12.2.3 拓扑排序实现 

​	前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环，则调用顶点排序即可。

**API设计：** 

| 类名     | TopoLogical                                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | TopoLogical(Digraph G)：构造拓扑排序对象                     |
| 成员方法 | 1.public boolean isCycle()：判断图G是否有环 <br />2.public Stack order():获取拓扑排序的所有顶点 |
| 成员变量 | 1.private Stack<Integer> order: 顶点的拓扑排序               |

**代码：**

```java
public class TopoLogical {

    private Stack<Integer> order;

    //构造拓扑排序对象
    public TopoLogical(Digraph digraph) {
        //创建一个检测有向环的对象
        DirectedCycle directedCycle = new DirectedCycle(digraph);
        //判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象
        if(!directedCycle.hasCycle()){
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(digraph);
            order = depthFirstOrder.reversePost();
        }

    }

    //判断图G是否有环
    public boolean isCycle(){
        return order == null;
    }

    //获取拓扑排序的所有顶点
    public Stack<Integer> order(){
        return order;
    }

    public static void main(String[] args) {
        //准备有向图
        Digraph digraph = new Digraph(6);
        digraph.addEdge(0,2);
        digraph.addEdge(0,3);
        digraph.addEdge(2,4);
        digraph.addEdge(3,4);
        digraph.addEdge(4,5);
        digraph.addEdge(1,3);

        //通过TopoLogical对象堆有向图中的顶点进行排序
        TopoLogical topoLogical = new TopoLogical(digraph);

        //获取顶点的线性序列进行打印
        Stack<Integer> order = topoLogical.order();
        StringBuilder sb = new StringBuilder();
        for(Integer v: order){
            sb.append(v+"->");
        }
        String str = sb.toString();
        int index = str.lastIndexOf("->");
        System.out.println(str.substring(0, index));
    }
}
```

### 12.3 加权无向图

​	加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞才能使时间成本最低或者是金钱成本最低？

在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过那条路径到达4顶点最好呢？此时就要考虑，那条路径的成本最低。 

![加权无向图](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115746.PNG)

#### 12.3.1 加权无向图边的表示 

​	加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。 

**API设计：** 

| 类名      | Edge implements Comparable<Edge>                             |
| --------- | ------------------------------------------------------------ |
| 构造 方法 | Edge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员 方法 | 1.public double weight():获取边的权重值 <br />2.public int either():获取边上的一个点 <br />3.public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点 <br />4.public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回 1，如果一样大，返回0，如果当前权重小，返回-1 |
| 成员 变量 | 1.private final int v：顶点一 <br />2.private final int w：顶点二 <br />3.private final double weight：当前边的权重 |

**代码：**

```java
public class Edge implements Comparable<Edge> {

    private final int v;//顶点一
    private final int w;//顶点二
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取边上的一个点
    public int either(){
        return v;
    }

    //获取边上除了顶点vertex外的另外一个顶点
    public int other(int vertex){
        if(vertex == v){
            return w;
        }else{
            return v;
        }
    }


    @Override
    public int compareTo(Edge that) {
        //使用一个遍历记录比较的结果
        int cmp;

        if(this.weight > that.weight()){
            //如果当前边的权重值大，则让cmp=1；
            cmp = 1;
        }else if(that.weight < that.weight()){
            //如果当前边的权重值小，则让cmp=-1；
            cmp = -1;
        }else {
            //如果当前边的权重值和that边的权重值一样大，则让cmp=0
            cmp = 0;
        }

        return cmp;
    }
}
```

#### 12.3.2 加权无向图的实现 

之前我们已经完成了无向图，在无向图的基础上，我们只需要把边的表示切换成Edge对象即可。

**API设计：** 

| 类名     | EdgeWeightedGraph                                            |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedGraph(int V)：创建一个含有V个顶点的空加权无向图  |
| 成员方法 | 1.public int V():获取图中顶点的数量 <br />2.public int E():获取图中边的数量 <br />3.public void addEdge(Edge e):向加权无向图中添加一条边e <br />4.public Queue<Edge> adj(int v)：获取和顶点v关联的所有边 <br />5.public Queue<Edge> edges()：获取加权无向图的所有边 |
| 成员变量 | 1.private final int V: 记录顶点数量 <br />2.private int E: 记录边数量 <br />3.private Queue<Edge>[] adj: 邻接表 |

**代码：** 

```java
public class EdgeWeightedGraph {

    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<Edge>[] adj;

    //创建一个含有V个顶点的空加权无向图
    public EdgeWeightedGraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int v = 0; v < V; v++) {
            this.adj[v] = new Queue<Edge>();
        }
    }

    //获取图中顶点的数量
    public int V(){
        return V;
    }

    //获取图中边的数量
    public int E(){
        return E;
    }

    //向加权无向图中添加一条边e
    public void addEdge(Edge e){
        //需要让边e同时出现在e这个边的两个顶点的邻接表中
        int v = e.either();
        int w = e.other(v);
        //添加边到点的邻接表中
        adj[v].enqueue(e);
        adj[w].enqueue(e);
        //边的数量+1
        this.E++;
    }

    //获取和顶点v关联的所有边
    public Queue<Edge> adj(int v){
        return adj[v];
    }

    //获取加权无向图的所有边
    public Queue<Edge> edges(){
        //创建一个队列对象，存储所有的边
        Queue<Edge> allEdges = new Queue<>();

        //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边
        //因为这是无向图，所以同一条边同时出现在了它关联的两个顶点的邻接表中，需要让一条边只记录一次；
        for (int v = 0; v < this.V; v++) {
            //遍历v顶点的邻接表，找到每一条和v关联的边
            for(Edge e: adj(v)){
                if(v < e.other(v)){
                    allEdges.enqueue(e);
                }
            }
        }
        return allEdges;
    }
}
```

### 12.4 最小生成树 

​	之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。 

![最小生成树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115939.PNG)

#### 12.4.1 最小生成树定义及相关约定 

**定义：**

​	图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树。

![最小生成树定义](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115011.PNG)

**约定：**

​	只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图的最小生成树，合并到一起称为最小生成森林。 

![最小生成树2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115267.PNG)

​	所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。 

#### 12.4.2 最小生成树原理 

##### 12.4.2.1 树的性质 

1. 用一条边连接树中的任意两个顶点都会产生一个新的环； 

   ![最小生成树性质1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115040.PNG)

2. 从树中删除任意一条边，将会得到两棵独立的树； 

   ![最小生成树性质2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115210.PNG)

##### 12.4.2.2 切分定理 

要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。 

**切分：**

将图的所有顶点按照某些规则分为两个非空且没有交集的集合。

**横切边：**

连接两个属于不同集合的顶点的边称之为横切边。

例如我们将图中的顶点切分为两个集合，灰色顶点属于一个集合，白色顶点属于另外一个集合，那么效果如下： 

![切分定理1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115840.PNG)

**切分定理：** 

在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。 

![切分定理2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115212.PNG)

**注意:**一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。 

![切分定理3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115580.PNG)

#### 12.4.3 贪心算法 

​	贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，**使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边**。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。 

![贪心算法](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115151.PNG)

​	计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在于保存切分和判定权重最小的横切边的方式。 

#### 12.4.4 Prim算法 

​	我们学习第一种计算最小生成树的方法叫Prim算法，它的每一步都会为一棵生成中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入到树中。 

**Prim算法的切分规则：**

把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。 

![Prim算法](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115632.PNG)

##### 12.4.4.1 Prim算法API设计 

| 类名      | PrimMST                                                      |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | PrimMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成员方 法 | 1.private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数据 <br />2.public Queue edges():获取最小生成树的所有边 |
| 成员变 量 | 1.private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边 <br />2.private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 <br />3.private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为 false <br />4.private IndexMinPriorityQueue<Double> pq:存放树中顶点与非树中顶点之间的有效横切边 |

##### 12.4.4.2 Prim算法的实现原理 

​	Prim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作，可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。

​	我们在设计API的时候，使用最小索引优先队列存放树中顶点与非树中顶点的有效横切边，那么它是如何表示的呢？我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重。 

![Prim算法实现原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115785.PNG)

​	初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表示了。 

​	现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也成为了横切边，这时需要做两个操作：

1. 0-7这条边已经不是横切边了，需要让它失效：只需要调用最小索引优先队列的delMin()方法即可完成；

2. 2和4顶点各有两条连接指向最小生成树，需要只保留一条：

   4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，

   0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。 

![Prim算法实现原理2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115695.PNG)

我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中 

##### 12.4.4.3 代码 

```java
public class PrimMST {

    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边
    private Edge[] edgeTo;
    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重
    private double[] distTo;
    //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false
    private boolean[] marked;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权无向图，创建最小生成树计算对象
    public PrimMST(EdgeWeightedGraph graph){
        //初始化edgeTo
        this.edgeTo = new Edge[graph.V()];
        //初始化distTo
        this.distTo = new double[graph.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化marked
        this.marked = new boolean[graph.V()];
        //初始化pq
        this.pq = new IndexMinPriorityQueue<Double>(graph.V());

        //默认让顶点0进入到树中，但是树中只有一个顶点0，因此，0顶点默认没有和其他的顶点相连，所以让distTo对应位置处的值存储0.0
        distTo[0] = 0.0;
        pq.insert(0, 0.0);

        //遍历索引最小优先队列，拿到最小和N切边对应的顶点，把该顶点加入到最小生成树中
        while (!pq.isEmpty()){
            visit(graph, pq.delMin());
        }
    }

    //将顶点v添加到最小生成树中，并且更新数据
    private void visit(EdgeWeightedGraph graph, int v){
        //把顶点v添加到最小生成树中
        marked[v] = true;

        //更新数据
        for(Edge e: graph.adj(v)){
            //获取e边的另外一个顶点(当前顶点是v)
            int w = e.other(v);
            //判断另外一个顶点是不是已经在树中，如果在树中，则不做任何处理，如果不再树中，更新数据
            if(marked[w]){
                continue;
            }

            //判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重；
            if(e.weight()<distTo[w]){
                //更新数据
                distTo[w] = e.weight();
                edgeTo[w] = e;

                if(pq.contains(w)){
                    pq.changeItem(w, e.weight());
                }else{
                    pq.insert(w, e.weight());
                }
            }
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges(){
        //创建队列对象
        Queue<Edge> allEdges = new Queue<>();
        //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中
        for (int i = 0; i < edgeTo.length; i++) {
            if(edgeTo[i] != null){
                allEdges.enqueue(edgeTo[i]);
            }
        }

        return allEdges;
    }

    public static void main(String[] args) throws Exception {
        //准备一副加权无向图
        BufferedReader br = new BufferedReader(
                new InputStreamReader(PrimMST.class.getClassLoader().getResourceAsStream("min_create_tree_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedGraph G = new EdgeWeightedGraph(total);

        int edgeNumbers = Integer.parseInt(br.readLine());
        for (int i = 0; i < edgeNumbers; i++) {
            String line = br.readLine();//4 5 0.35
            String[] strs = line.split(" ");

            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);
            double weight = Double.parseDouble(strs[2]);

            //构建加权无向边
            Edge edge = new Edge(v, w, weight);
            G.addEdge(edge);
        }

        //创建一个PrimMST对象，计算加权无向图中的最小生成树
        PrimMST primMST = new PrimMST(G);

        //获取最小生成树中的所有边
        Queue<Edge> edges = primMST.edges();

        //遍历打印所有的边
        for(Edge edge: edges){
            int v = edge.either();
            int w = edge.other(v);
            double weight = edge.weight();
            System.out.println(v+"-"+w+" :: "+weight);
        }

    }
}
```

#### 12.4.5 kruskal算法 

​	kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。

**kruska算法和prim算法的区别：**

​	Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。 

![Kruskal算法](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115624.PNG)

##### 12.4.5.1 kruskal算法API设计 

| 类 名       | KruskalMST                                                   |
| ----------- | ------------------------------------------------------------ |
| 构 造 方 法 | KruskalMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成 员 方 法 | 1.public Queue<Edge> edges():获取最小生成树的所有边          |
| 成 员 变 量 | 1.private Queue mst：保存最小生成树的所有边 <br />2.private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 <br />3.private MinPriorityQueue<Edge> pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序 |

##### 12.4.5.2 kruskal算法的实现原理 

​	在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。 

![Kruskal算法实现原理](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115539.PNG)

##### 12.4.5.3 代码

```java
public class KruskalMST {

    //保存最小生成树的所有边
    private Queue<Edge> mst;
    //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并
    UFTreeWeight ufw;
    //存储图中所有的边，使用最小优先队列，对边按照权重进行排序
    private MinPriorityQueue<Edge> pq;

    //根据一副加权无向图，创建最小生成树计算对象
    public KruskalMST(EdgeWeightedGraph graph){
        //初始化mst
        this.mst = new Queue<Edge>();
        //初始化uf
        this.ufw = new UFTreeWeight(graph.V());
        //初始化pq
        this.pq = new MinPriorityQueue<>(graph.E());
        //把图中所有的边存储到pq中
        for(Edge edge: graph.edges()){
            this.pq.insert(edge);
        }

        //遍历pq队列，拿到最小权重的边，进行处理
        while (!pq.isEmpty() && mst.size()<graph.V()-1){
            //找到权重最小的边
            Edge minEdge = pq.delMin();
            //找到该边的两个顶点
            int v = minEdge.either();
            int w = minEdge.other(v);

            //判断这两个顶点是否已经在同一颗树中，
            if(ufw.connected(v, w)){
                // 如果在同一颗树中，则不对该边做处理，
                continue;
            }
            // 如果不在一棵树中，则让这两个顶点属于的两棵树合并成一棵树
            ufw.union(v, w);
            //让边e进入到mst队列中
            this.mst.enqueue(minEdge);
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges(){
        return this.mst;
    }

    public static void main(String[] args) throws Exception {
        //准备一副加权无向图
        BufferedReader br = new BufferedReader(
                new InputStreamReader(PrimMST.class.getClassLoader().getResourceAsStream("min_create_tree_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedGraph G = new EdgeWeightedGraph(total);

        int edgeNumbers = Integer.parseInt(br.readLine());
        for (int i = 0; i < edgeNumbers; i++) {
            String line = br.readLine();//4 5 0.35
            String[] strs = line.split(" ");

            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);
            double weight = Double.parseDouble(strs[2]);

            //构建加权无向边
            Edge edge = new Edge(v, w, weight);
            G.addEdge(edge);
        }

        //创建一个PrimMST对象，计算加权无向图中的最小生成树
        KruskalMST primMST = new KruskalMST(G);

        //获取最小生成树中的所有边
        Queue<Edge> edges = primMST.edges();

        //遍历打印所有的边
        for(Edge edge: edges){
            int v = edge.either();
            int w = edge.other(v);
            double weight = edge.weight();
            System.out.println(v+"-"+w+" :: "+weight);
        }

    }
}
```

### 12.5 加权有向图 

​	之前学习的加权无向图中，边是没有方向的，并且同一条边会同时出现在该边的两个顶点的邻接表中，为了能够处理含有方向性的图的问题，我们需要实现以下加权有向图。

#### 12.5.1加权有向图边的表示

**API设计：** 

| 类名      | DirectedEdge                                                 |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员方 法 | 1.public double weight():获取边的权重值 <br />2.public int from():获取有向边的起点 <br />3.public int to():获取有向边的终点 |
| 成员变 量 | 1.private final int v：起点 <br />2.private final int w：终点 <br />3.private final double weight：当前边的权重 |

**代码：** 

```java
public class DirectedEdge {

    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重

    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取有向边的起点
    public int from(){
        return v;
    }

    //获取有向边的终点
    public int to(){
        return w;
    }
}
```

#### 12.5.2 加权有向图的实现

之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。

**API设计：** 

| 类名     | EdgeWeightedDigraph                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedDigraph(int V)：创建一个含有V个顶点的空加权有向图 |
| 成员方法 | 1.public int V():获取图中顶点的数量 <br />2.public int E():获取图中边的数量 <br />3.public void addEdge(DirectedEdge e):向加权有向图中添加一条边e <br />4.public Queue<DirectedEdge> adj(int v)：获取由顶点v指出的所有的边 <br />5.public Queue<DirectedEdge> edges()：获取加权有向图的所有边 |
| 成员变量 | 1.private final int V: 记录顶点数量 <br />2.private int E: 记录边数量 <br />3.private Queue<DirectedEdge>[] adj: 邻接表 |

**代码：** 

```java
public class EdgeWeightDigraph {

    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<DirectedEdge>[] adj;

    //创建一个含有V个顶点的空加权有向图
    public EdgeWeightDigraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < V; i++) {
            this.adj[i] = new Queue<>();
        }
    }

    //获取图中顶点的数量
    public int V(){
        return this.V;
    }

    //获取图中边的数量
    public int E() {
        return this.E;
    }

    //向加权有向图中添加一条边e
    public void addEdge(DirectedEdge e){
        //边e是有方向的，所以只需要让e出现在起点的邻接表中即可
        int v = e.from();
        adj[v].enqueue(e);
        this.E++;
    }

    //获取由顶点v指出的所有的边
    public Queue<DirectedEdge> adj(int v){
        return adj[v];
    }

    //获取加权有向图的所有边
    public Queue<DirectedEdge> edges(){
        //遍历图中的每一个顶点，得到该顶点的邻接表，遍历得到每一条边，添加到队列中返回即可
        Queue<DirectedEdge> allEdges = new Queue<>();
        for (int v = 0; v < this.V; v++) {
            for(DirectedEdge edge: this.adj[v]){
                allEdges.enqueue(edge);
            }
        }
        return allEdges;
    }
}
```

### 12.6 最短路径 

​	有了加权有向图之后，我们立刻就能联想到实际生活中的使用场景，例如在一副地图中，找到顶点a与地点b之间的路径，这条路径可以是距离最短，也可以是时间最短，也可以是费用最小等，如果我们把距离/时间/费用看做是成本，那么就需要找到地点a和地点b之间成本最小的路径，也就是我们接下来要解决的最短路径问题。 

#### 12.6.1 最短路径定义及性质 

**定义：** 

在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。 

![最短路径](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115364.PNG)

**性质：**

1. 路径具有方向性；
2. 权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低
3. 只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径，为了简化问题，这里只考虑连通图。
4. 最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一条即可。

**最短路径树：**

​	给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 

#### 12.6.2 最短路径树API设计 

计算最短路径树的经典算法是dijstra算法，为了实现它，先设计如下API： 

| 类名      | DijkstraSP                                                   |
| --------- | ------------------------------------------------------------ |
| 构造 方法 | public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 |
| 成员 方法 | 1.private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v <br />2.public double distTo(int v):获取从顶点s到顶点v的最短路径的总权重 <br />3.public boolean hasPathTo(int v):判断从顶点s到顶点v是否可达 <br />4.public Queue<DirectedEdge> pathTo(int v):查询从起点s到顶点v的最短路径中所有的边 |
| 成员 变量 | 1.private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 <br />2.private double[] distTo: 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 <br />3.private IndexMinPriorityQueue<Double> pq:存放树中顶点与非树中顶点之间的有效横切边 |

#### 12.6.3 松弛技术 

​	松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还有存在更短的路径，那么把皮筋转移到更短的路径上，皮筋就可以放松了。 

![松弛技术](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115662.PNG)

松弛这种简单的原理刚好可以用来计算最短路径树。

​	在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]=0；顶点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条件更新edgeTo和distTo中的数据，最终就可以得到最短路径树。

**边的松弛：**

放松边v->w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？

​	如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]=表示v->w这条边的DirectedEdge对象，distTo[w]=distTo[v]+v->w这条边的权重；

​	如果不是，则忽略v->w这条边。 

![边的松弛](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115036.PNG)

**顶点的松弛：**

​	顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。

**例子：**

如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0->2->7>3->6的过程如下: 

![定点松弛](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252115968.PNG)

#### 12.6.4 Dijstra算法实现 

​	Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边是有效横切边pq队列中的权重最小的边。 

```java
public class DijkstraSP {

    //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重
    private double[] distTo;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象
    public DijkstraSP(EdgeWeightDigraph digraph, int s){
        //初始化edgeTo
        this.edgeTo = new DirectedEdge[digraph.V()];
        //初始化distTo
        this.distTo = new double[digraph.V()];
        for (int i = 0; i < this.distTo.length; i++) {
            this.distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化pq
        this.pq = new IndexMinPriorityQueue<>(digraph.V());

        //找到图G中以顶点s为起点的最短路径树
        //默认让顶点s进入到最短路径树中
        distTo[s] = 0.0;
        pq.insert(0, 0.0);
        //遍历pq
        while (!pq.isEmpty()){
            relax(digraph, pq.delMin());
        }
    }

    //松弛图G中的顶点v
    private void relax(EdgeWeightDigraph digraph, int v){

        for(DirectedEdge edge: digraph.adj(v)){
            //获取到该边的终点w
            int w = edge.to();
            //通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w
            if((distTo[v]+edge.weight())<distTo[w]){
                distTo[w] = distTo[v]+edge.weight();
                edgeTo[w] = edge;

                //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则直接添加
                if(pq.contains(w)){
                    pq.changeItem(w, distTo[w]);
                }else{
                    pq.insert(w, distTo[w]);
                }
            }
        }
    }

    //获取从顶点s到顶点v的最短路径的总权重
    public double distTo(int v){
        return distTo[v];
    }

    //判断从顶点s到顶点v是否可达
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }

    //查询从起点s到顶点v的最短路径中所有的边
    public Queue<DirectedEdge> pathTo(int v){
        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null
        if (!hasPathTo(v)){
            return null;
        }

        //创建队列对象
        Queue<DirectedEdge> allEdges = new Queue<>();

        while (true){
            DirectedEdge e = edgeTo[v];
            if(e==null){
                break;
            }

            allEdges.enqueue(e);
            v = e.from();
        }
        return allEdges;
    }

    public static void main(String[] args) throws Exception {
        //创建一副加权有向图
        BufferedReader br = new BufferedReader(new InputStreamReader(DijkstraSP.class.getClassLoader().getResourceAsStream("min_route_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightDigraph G = new EdgeWeightDigraph(total);
        int edgeNumbers = Integer.parseInt(br.readLine());

        for(int i=1; i<=edgeNumbers; i++){
            String line = br.readLine();//4 5 0.35
            String[] strs = line.split(" ");
            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);

            double weight = Double.parseDouble(strs[2]);

            DirectedEdge e = new DirectedEdge(v, w, weight);
            G.addEdge(e);
        }

        //创建DijkstraSP对象，查找最短路径树
        DijkstraSP dijkstraSP = new DijkstraSP(G, 0);

        //查找最短路径,0->6的最短路径
        Queue<DirectedEdge> edges = dijkstraSP.pathTo(6);

        //遍历打印
        for (DirectedEdge edge : edges) {
            System.out.println(edge.from()+"->"+edge.to()+" ：： "+edge.weight());
        }
    }
}
```

