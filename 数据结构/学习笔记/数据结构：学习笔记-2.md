# 数据结构：学习笔记-2

> 前些天看了《大话数据结构》，大致对数据结构有了些许了解，现又找了些视频巩固巩固，课程连接：[黑马:数据结构与算法](https://www.bilibili.com/video/BV1iJ411E7xW)，依据上述课程做了下学习笔记，总共分为3篇，此为2/3。

## 6. 二叉树入门

​	之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多，其耗时也是线性增多的，时间复杂度都是O(n),为了提高运算效率，接下来我们学习树这种数据结构。 

### 6.1 树的基本定义 

​	树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。 

​	树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 

![树的定义](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111466.PNG)

树具有以下特点：

1. 每个结点有零个或多个子结点；
2. 没有父结点的结点为根结点；
3. 每一个非根结点只有一个父结点；
4. 每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树； 

### 6.2 树的相关术语 

**结点的度：**

一个结点含有的子树的个数称为该结点的度；

**叶结点：**

度为0的结点称为叶结点，也可以叫做终端结点

**分支结点：**

度不为0的结点称为分支结点，也可以叫做非终端结点

**结点的层次：**

从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

**结点的层序编号：** 

将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。 

**树的度：**

树中所有结点的度的最大值

**树的高度(深度)：**

树中结点的最大层次 

**森林：**

m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树 

![森林](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111482.PNG)

**孩子结点：**

一个结点的直接后继结点称为该结点的孩子结点

**双亲结点(父结点)：**

一个结点的直接前驱称为该结点的双亲结点

**兄弟结点：**

同一双亲结点的孩子结点间互称兄弟结点 

### 6.3 二叉树的基本定义 

二叉树就是度不超过2的树(每个结点最多有两个子结点) 

![二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111214.PNG)

**满二叉树：**

一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。 

![满二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111580.PNG)

**完全二叉树：** 

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树 

![完全二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111915.PNG)

### 6.4 二叉查找树的创建

#### 6.4.1 二叉树的结点类

​	根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。 

**结点类API设计：** 

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right)：创建Node对象 |
| 成员变量 | 1.public Node left:记录左子结点 <br />2.public Node right:记录右子结点 <br />3.public Key key:存储键 <br />4.public Value value:存储值 |

**代码实现：** 

```java
private class Node{
    //存储键
    public Key key;
    //存储值
    public Value value;
    //记录左子结点
    public Node left;
    //记录右子结点
    public Node right;

    public Node(Key key, Value value, Node left, Node right) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
```

#### 6.4.2 二叉查找树API设计 

| 类名      | BinaryTree                                                   |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | BinaryTree()：创建BinaryTree对象                             |
| 成员变 量 | 1.private Node root:记录根结点 <br />2.private int N:记录树中元素的个数 |
| 成员方 法 | 1.public void put(Key key, Value value):向树中插入一个键值对 <br />2.private Node put(Node x, Key key, Value val):给指定树x上，添加键一个键值对，并返回添加后的新树 <br />3.public Value get(Key key):根据key，从树中找出对应的值 <br />4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 <br />5.public void delete(Key key):根据key，删除树中对应的键值对 <br />6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树 <br />7.public int size():获取树中元素的个数 |

#### 6.4.3 二叉查找树实现 

**插入方法put实现思想：**

1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
2. 如果当前树不为空，则从根结点开始：
   1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
   2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
   3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 

![二叉树的插入实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111839.PNG)

**查询方法get实现思想：**

从根节点开始：

1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

**删除方法delete实现思想：**

1. 找到被删除结点；
2. 找到被删除结点右子树中的最小结点minNode
3. 删除右子树中的最小结点
4. 让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
5. 让被删除结点的父节点指向最小结点minNode 

![二叉树的删除实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111108.PNG)

**代码：** 

```java
public class BinaryTree<Key extends Comparable<Key>, Value> {

    //记录根结点
    private Node root;
    //记录树中元素的个数
    private int N;

    private class Node{
        //存储键
        public Key key;
        //存储值
        public Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    public BinaryTree() {
        this.N = 0;
    }

    //获取树中元素的个数
    public int size(){
        return N;
    }

    //向树中添加元素key-value
    public void put(Key key, Value val){
        root = put(root, key, val);
    }

    //向指定的树x中添加key-value,并返回添加元素后新的树
    private Node put(Node x, Key key, Value value){
        //如果x子树为空
        if(x == null){
            N++;
            x = new Node(key, value, null, null);
            return x;
        }

        //如果x子树不为空
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right, key, value);
        }else if(cmp < 0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left, key, value);
        }else{
            //如果key等于x结点的键，则替换x结点的值为value即可
            x.value = value;
        }

        return x;
    }

    //查询树中指定key对应的value
    public Value get(Key key){
        return get(root, key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key){

        //如果x子树为空
        if(x == null){
            return null;
        }

        //如果x子树不为空
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right, key);
        }else if(cmp < 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.left, key);
        }else{
            //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可
            return x.value;
        }
    }

    //删除树中key对应的value
    public void delete(Key key){
        root = delete(root, key);
    }

    //删除指定树x中的key对应的value，并返回删除后的新树
    private Node delete(Node x, Key key){
        //x树为null
        if (x==null){
            return null;
        }

        //如果x子树不为空 先找到要删除的节点
        //比较x结点的键和key的大小：
        int cmp = key.compareTo(x.key);
        if (cmp > 0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = delete(x.right, key);
        }else if(cmp < 0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left, key);
        }else{
            //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；
            //让元素个数-1
            N--;
            //得找到右子树中最小的结点
            if(x.right == null){
                // 当结点没有右节点 直接返回它的左节点
                return x.left;
            }

            if(x.left == null){
                // 当结点没有左节点 直接返回它的右节点
                return x.right;
            }

            // 当左右节点都存在时，寻找右子树的最左节点
            Node minNode = x.right;
            // 删除右子树中最小的结点
            Node n = x.right;  // n为minNode节点的父节点
            while (minNode.left != null){
                minNode = minNode.left;
                if(n.left.left != null){
                    // 使n一直是minNode的父节点
                    n = n.left;
                }
            }
            //变换n结点即可 指向空
            n.left = null;

            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父结点指向minNode
            x = minNode;
        }
        return x;
    }
}

// 测试代码
public class BinaryTreeTest {

    public static void main(String[] args) {

        //创建二叉查找树对象
        BinaryTree<Integer, String> tree = new BinaryTree<>();

        //测试插入
        tree.put(1,"张三");
        tree.put(2,"李四");
        tree.put(3,"王五");

        //测试获取
        System.out.println("键2对应的元素是："+tree.get(2));

        //测试删除
        tree.delete(3);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键3对应的元素:"+tree.get(3));

        tree.delete(1);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键2对应的元素:"+tree.get(2));

        tree.delete(2);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键1对应的元素:"+tree.get(1));
    }
}
```

#### 6.4.4 二叉查找树其他便捷方法

##### 6.4.4.1 查找二叉树中最小的键

​	在某些情况下，我们需要查找出树中存储所有元素的键的最小值，比如我们的树中存储的是学生的排名和姓名数据，那么需要查找出排名最低是多少名？这里我们设计如下两个方法来完成： 

| public Key min()         | 找出树中最小的键                |
| ------------------------ | ------------------------------- |
| private Node min(Node x) | 找出指定树x中，最小键所在的结点 |

```java
//查找整个树中最小的键
public Key min(){
    return min(root).key;
}

//在指定树x中找出最小键所在的结点
public Node min(Node x){
    //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点
    if(x.left != null){
        return min(x.left);
    }else{
        return x;
    }
}
```

##### 6.4.4.2 查找二叉树中最大的键 

​	在某些情况下，我们需要查找出树中存储所有元素的键的最大值，比如比如我们的树中存储的是学生的成绩和学生的姓名，那么需要查找出最高的分数是多少？这里我们同样设计两个方法来完成： 

| public Key max()        | 找出树中最大的键                |
| ----------------------- | ------------------------------- |
| public Node max(Node x) | 找出指定树x中，最大键所在的结点 |

```java
//在整个树中找到最大的键
public Key max(){
    return max(root).key;
}

//在指定的树x中，找到最大的键所在的结点
public Node max(Node x){
    //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点
    if(x.right != null){
        return max(x.right);
    }else{
        return x;
    }
}
```

### 6.5 二叉树的基础遍历 

​	很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的**搜索路径**进行遍历的问题。 

![二叉树的基础遍历](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111740.PNG)

​	我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式：

1. **前序遍历：**先访问根结点，然后再访问左子树，最后访问右子树 

2. **中序遍历：**先访问左子树，中间访问根节点，最后访问右子树 

3. **后序遍历：**先访问左子树，再访问右子树，最后访问根节点 

如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下： 

![二叉树遍历](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111096.PNG)

#### 6.5.1 前序遍历

我们在 6.4 中创建的树上，添加前序遍历的API：

`public Queue<Key> preErgodic()`：使用前序遍历，获取整个树中的所有键

`private void preErgodic(Node x, Queue<Key> keys)`：使用前序遍历，把指定树x中的所有键放入到keys队列中实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。

实现步骤：

1. 把当前结点的key放入到队列中;
2. 找到当前结点的左子树，如果不为空，递归遍历左子树
3. 找到当前结点的右子树，如果不为空，递归遍历右子树 

**代码：** 

```java
//前序遍历获取整个树中所有的键
public Queue<Key> preErgodic(){
    Queue<Key> keys = new Queue<>();
    preErgodic(root, keys);
    return keys;
}

//获取指定树x的所有键，并放到keys队列中
private void preErgodic(Node x, Queue<Key> keys){
    if(x == null){
        return;
    }

    //把x结点的key放入到keys中
    keys.enqueue(x.key);

    //递归遍历x结点的左子树
    if (x.left != null){
        preErgodic(x.left, keys);
    }

    //递归遍历x结点的右子树
    if(x.right != null){
        preErgodic(x.right, keys);
    }
}

//测试前序遍历
public static void main(String[] args) {

    //创建树对象
    BinaryTree<String, String> tree = new BinaryTree<>();
    //往树中添加数据
    tree.put("E", "5");
    tree.put("B", "2");
    tree.put("G", "7");
    tree.put("A", "1");
    tree.put("D", "4");
    tree.put("F", "6");
    tree.put("H", "8");
    tree.put("C", "3");

    //遍历
    Queue<String> keys = tree.preErgodic();
    for (String key : keys) {
        String value = tree.get(key);
        System.out.println(key+"----"+value);
    }
}
```

#### 6.5.2 中序遍历 

我们在6.4中创建的树上，添加前序遍历的API： 

`public Queue<Key> midErgodic()`：使用中序遍历，获取整个树中的所有键

`private void midErgodic(Node x,Queue<Key> keys)`：使用中序遍历，把指定树x中的所有键放入到keys队列中 

**实现步骤：**

1. 找到当前结点的左子树，如果不为空，递归遍历左子树
2. 把当前结点的key放入到队列中;
3. 找到当前结点的右子树，如果不为空，递归遍历右子树 

**代码：** 

```java
//中序遍历获取整个树中所有的键
public Queue<Key> midErgodic(){
    Queue<Key> keys = new Queue<>();
    midErgodic(root, keys);
    return keys;
}

//获取指定树x的所有键，并放到keys队列中
private void midErgodic(Node x, Queue<Key> keys){
    if(x == null){
        return;
    }

    //先递归，把左子树中的键放到keys中
    if (x.left != null){
        midErgodic(x.left, keys);
    }

    //把当前结点x的键放到keys中
    keys.enqueue(x.key);

    //在递归，把右子树中的键放到keys中
    if(x.right != null){
        midErgodic(x.right, keys);
    }
}

//测试中序遍历
// ... 其他同上
Queue<String> keys = tree.midErgodic();
for (String key : keys) {
    String value = tree.get(key);
    System.out.println(key+"----"+value);
}
```

#### 6.5.3 后序遍历 

我们在6.4中创建的树上，添加前序遍历的API： 

`public Queue<Key> afterErgodic()`：使用后序遍历，获取整个树中的所有键 

`private void afterErgodic(Node x,Queue<Key> keys)`：使用后序遍历，把指定树x中的所有键放入到keys队列中 

**实现步骤：**

1. 找到当前结点的左子树，如果不为空，递归遍历左子树
2. 找到当前结点的右子树，如果不为空，递归遍历右子树
3. 把当前结点的key放入到队列中; 

**代码：** 

```java
//后序遍历获取整个树中所有的键
public Queue<Key> afterErgodic(){
    Queue<Key> keys = new Queue<>();
    afterErgodic(root, keys);
    return keys;
}

//获取指定树x的所有键，并放到keys队列中
private void afterErgodic(Node x, Queue<Key> keys){
    if(x == null){
        return;
    }

    //先递归，把左子树中的键放到keys中
    if (x.left != null){
        afterErgodic(x.left, keys);
    }

    //在递归，把右子树中的键放到keys中
    if(x.right != null){
        afterErgodic(x.right, keys);
    }

    //把当前结点x的键放到keys中
    keys.enqueue(x.key);
}

//测试后续遍历
// ... 其他同上
Queue<String> keys = tree.afterErgodic();
for (String key : keys) {
    String value = tree.get(key);
    System.out.println(key+"----"+value);
}
```

### 6.6 二叉树的层序遍历 

所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值，有二叉树如下： 

![二叉树的层序遍历](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111757.PNG)

那么层序遍历的结果是：EBGADFHC

我们在6.4中创建的树上，添加层序遍历的API：

`public Queue<Key> layerErgodic()`：使用层序遍历，获取整个树中的所有键 

**实现步骤：**

1. 创建队列，存储每一层的结点；
2. 使用循环从队列中弹出一个结点：
   1. 获取当前结点的key；
   2. 如果当前结点的左子结点不为空，则把左子结点放入到队列中
   3. 如果当前结点的右子结点不为空，则把右子结点放入到队列中 

![二叉树的层序遍历实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111079.PNG)

**代码：** 

```java
//使用层序遍历，获取整个树中所有的键
public Queue<Key> layerErgodic(){

    //定义两个队列，分别存储树中的键和树中的结点
    Queue<Key> keys = new Queue<>();
    Queue<Node> nodes = new Queue<>();

    //默认，往队列中放入根结点
    nodes.enqueue(root);
    while (!nodes.isEmpty()){
        //从队列中弹出一个结点，把key放入到keys中
        Node n = nodes.dequeue();
        keys.enqueue(n.key);
        //判断当前结点还有没有左子结点，如果有，则放入到nodes中
        if(n.left!=null){
            nodes.enqueue(n.left);
        }
        //判断当前结点还有没有右子结点，如果有，则放入到nodes中
        if(n.right!=null){
            nodes.enqueue(n.right);
        }
    }
    return keys;
}

// 测试代码
//层序遍历
Queue<String> keys = tree.layerErgodic();
for (String key : keys) {
    String value = tree.get(key);
    System.out.println(key+"----"+value);
}
```

### 6.7 二叉树的最大深度问题 

**需求：**

给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）; 

![二叉树的深度问题](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111783.PNG)

上面这棵树的最大深度为4。

**实现：**

我们在4.4中创建的树上，添加如下的API求最大深度：

`public int maxDepth()`：计算整个树的最大深度

`private int maxDepth(Node x)`：计算指定树x的最大深度 

**实现步骤：**

1. 如果根结点为空，则最大深度为0；
2. 计算左子树的最大深度；
3. 计算右子树的最大深度；
4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 

**代码：** 

```java
//获取整个树的最大深度
public int maxDepth(){
    return maxDepth(root);
}

//获取指定树x的最大深度
private int maxDepth(Node x){
    if (x==null){
        return 0;
    }

    //x的最大深度
    int max = 0;
    //左子树的最大深度
    int maxL=0;
    //右子树的最大深度
    int maxR=0;

    //计算x结点左子树的最大深度
    if(x.left != null){
        maxL = maxDepth(x.left);
    }

    //计算x结点右子树的最大深度
    if(x.right != null){
        maxR = maxDepth(x.right);
    }

    //比较左子树最大深度和右子树最大深度，取较大值+1即可
    max = maxL > maxR ? maxL+1:maxR+1;
    return max;
}
```

### 6.8 折纸问题 

**需求：**

​	请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

​	给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up 

![折纸问题](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111133.PNG)

**分析：**

我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。

这棵树有这样的特点：

1. 根结点为下折痕；
2. 每一个结点的左子结点为下折痕；
3. 每一个结点的右子结点为上折痕； 

![折纸问题-树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111747.PNG)

**实现步骤：**

1. 定义结点类
2. 构建深度为N的折痕树；
3. 使用中序遍历，打印出树中所有结点的内容； 

**构建深度为N的折痕树：**

1. 第一次对折，只有一条折痕，创建根结点；
2. 如果不是第一次对折，则使用队列保存根结点；
3. 循环遍历队列：
   1. 从队列中拿出一个结点；
   2. 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；
   3. 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；
   4. 判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。 

**代码：** 

```java
public class PagerFolding {

    public static void main(String[] args) {
        //模拟折纸过程，产生树
        Node<String> tree = createTree(3);

        //遍历树，打印每个结点
        printTree(tree);
    }

    //通过模拟对折N次纸，产生树
    public static Node<String> createTree(int N){
        //定义根结点
        Node<String> root=null;
        for (int i = 0; i < N; i++) {
            //1.当前是第一次对折
            if(i==0){
                root = new Node<>("down", null, null);
                continue;
            }
            //2.当前不是第一次对折
            Queue<Node> queue = new Queue<>();
            queue.enqueue(root);

            //循环遍历队列
            while (!queue.isEmpty()){
                //从队列中弹出一个结点
                Node<String> tmp = queue.dequeue();
                //如果有左子结点，则把左子结点放入到队列中
                if(tmp.left!=null){
                    queue.enqueue(tmp.left);
                }
                //如果有右子结点，则把右子结点放入到队列中
                if(tmp.right!=null){
                    queue.enqueue(tmp.right);
                }
                //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可
                if(tmp.left==null && tmp.right==null){
                    tmp.left = new Node<String>("down", null, null);
                    tmp.right = new Node<String>("up", null, null);
                }
            }
        }
        return root;
    }

    //打印树中每个结点到控制台
    public static void printTree(Node<String> root){
        //需要使用中序遍历完成
        if(root==null){
            return;
        }

        //打印左子树的每个结点
        if(root.left!=null){
            printTree(root.left);
        }
        //打印当前结点
        System.out.print(root.item+" ");
        //打印右子树的每个结点
        if(root.right!=null){
            printTree(root.right);
        }
    }

    //结点类
    private static class Node<T>{
        public T item; //存储元素
        public Node left;
        public Node right;

        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
```

## 7. 堆

### 7.1.1 堆的定义 

​	堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。 

**堆的特性：**

1. 它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。 

   ![完全不完全二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252111587.PNG)

2. 它通常用数组来实现

   具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。

   ![数组实现二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112101.PNG)

   

   如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于[k/2],向下一层就令k等于2k或2k+1。

3. 每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。 

### 7.2 堆的API设计

| 类名     | `Heap<T extends Comparable<T>>`                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Heap(int capacity)：创建容量为capacity的Heap对象             |
| 成员方法 | 1.private boolean less(int i, int j):判断堆中索引i处的元素是否小于索引j处的元素 <br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br />3.public T delMax():删除堆中最大的元素,并返回这个最大元素 <br />4.public void insert(T t)：往堆中插入一个元素 <br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |
| 成员变量 | 1.private T[] imtes : 用来存储元素的数组 <br />2.private int N：记录堆中元素的个数 |

### 7.3 堆的实现 

#### 7.3.1 insert插入方法的实现

​	堆是用数组完成数据元素的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些方法让刚才插入的这个数据放入到合适的位置。 

![堆的插入实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112498.PNG)

所以，如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。 

#### 7.3.2 delMax删除最大元素方法的实现 

​	由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置。 

![堆删除最大元素实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114481.PNG)

​	所以，当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。 

#### 7.3.3 堆的实现代码 

```java
public class Heap <T extends Comparable<T>>{

    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public Heap(int capacity) {
        // 在0号位不存储内容，因此为capacity+1
        this.items = (T[]) new Comparable[capacity+1];
        this.N = 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置
        while (k>1){
            //比较当前结点和其父结点
            if(less(k/2, k)){
                exch(k/2, k);
            }
            k = k/2;
        }
    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax(){
        T max = items[1];

        //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点
        exch(1, N);
        //最大索引处的元素删除掉
        items[N] = null;
        //元素个数-1
        N--;
        //通过下沉调整堆，让堆重新有序
        sink(1);

        return max;
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置
        while (2*k <= N){
            //获取当前结点的子结点中的较大结点
            int max;
            // 有右节点
            if(2*k+1 <= N){
                if(less(2*k, 2*k+1)){
                    max = 2*k+1;
                }else{
                    max = 2*k;
                }
            }else{
                max = 2*k;
            }

            //比较当前结点和较大结点的值
            if(!less(k, max)){
                break;
            }
            //k节点处的值比其子节点要小，交换k索引处的值和max索引处的值
            exch(k, max);
            //变换k的值
            k = max;
        }
    }

    public static void main(String[] args) {
        Heap<String> heap = new Heap<>(20);

        heap.insert("A");
        heap.insert("B");
        heap.insert("C");
        heap.insert("D");
        heap.insert("E");
        heap.insert("F");
        heap.insert("G");

        String del;
        while ((del=heap.delMax())!=null){
            System.out.println(del);
        }
    }
}
```

### 7.4 堆排序 

给定一个数组：

String[] arr = {"S","O","R","T","E","X","A","M","P","L","E"}

请对数组中的字符按从小到大排序。 

**实现步骤：**

1. 构造堆；
2. 得到堆顶元素，这个值就是最大值；
3. 交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；
4. 对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；
5. 重复2~4这个步骤，直到堆中剩一个元素为止。 

**API设计：** 

| 类名      | `HeapSort<T extends Comparable<T>>`                          |
| --------- | ------------------------------------------------------------ |
| 成员 方法 | 1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br />2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组 source，构造出堆heap <br />3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素 <br />4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值 <br />5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。 |

#### 7.4.1 堆构造过程 

​	堆的构造，最直观的想法就是另外再创建一个新数组，然后从左往右遍历原数组，每得到一个元素后，添加到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。

​	上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组0~length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。 

> 从一半处开始扫是因为后一半没有子节点

![堆的构造过程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112396.PNG)

#### 7.4.2 堆排序过程

对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。

1. 将堆顶元素和堆中最后一个元素交换位置；
2. 通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)
3. 重复1~2步骤，直到堆中剩最后一个元素。 

![堆的排序过程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252114641.PNG)

**代码：**

```java
public class HeapSort <T extends Comparable<T>> {

    //判断heap堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] a, int i, int j){
        return a[i].compareTo(a[j])<0;
    }

    //交换heap堆中i索引和j索引处的值
    private static void exch(Comparable[] a, int i, int j){
        Comparable tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    //根据原数组source，构造出堆heap
    private static void createHeap(Comparable[] source, Comparable[] heap){
        //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆
        System.arraycopy(source, 0, heap, 1, source.length);

        //对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (heap.length)/2; i > 0; i--) {
            sink(heap, i, heap.length-1);
        }
    }

    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source){
        //构建堆
        Comparable[] heap = new Comparable[source.length+1];
        createHeap(source, heap);

        //定义一个变量，记录未排序的元素中最大的索引
        int N = heap.length-1;
        while (N!=1){
            //交换元素
            exch(heap, 1, N);
            //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整
            N--;
            //需要对索引1处的元素进行对的下沉调整
            sink(heap, 1, N);
        }
        //把heap中的数据复制到原数组source中
        System.arraycopy(heap, 1, source, 0, source.length);
    }

    //在heap堆中，对target处的元素做下沉，范围是0~range
    private static void sink(Comparable[] heap, int target, int range){
        while (2*target <= range){
            //1.找出当前结点的较大的子结点
            int max;
            if(2*target+1 <= range){
                if(less(heap,2*target, 2*target+1)){
                    max = 2*target+1;
                }else{
                    max = 2*target;
                }
            }else{
                max = 2*target;
            }

            //2.比较当前结点的值和较大子结点的值
            if(!less(heap, target, max)){
                break;
            }

            // 3. 交换元素
            exch(heap, target, max);
            // 4. 继续后续遍历
            target = max;
        }
    }

    public static void main(String[] args) {
        //待排序数组
        String[] arr = {"S","O","R","T","E","X","A","M","P","L","E"};
        //通过HeapSort对数组中的元素进行排序
        HeapSort.sort(arr);
        //打印排序后数组中的元素
        System.out.println(Arrays.toString(arr));
    }
}
```

## 8. 优先队列 

​	普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。 

![计算机任务队列](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112060.PNG)

优先队列按照其作用不同，可以分为以下两种：

​	最大优先队列：可以获取并删除队列中最大的值

​	最小优先队列：可以获取并删除队列中最小的值 

### 8.1 最大优先队列

​	我们之前学习过堆，而堆这种结构是可以方便的删除最大的值，所以，接下来我们可以基于堆区实现最大优先队列。 

#### 8.1.1 最大优先队列API设计 

| 类名     | `MaxPriorityQueue<T extends Comparable<T>>`                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br />3.public T delMax():删除队列中最大的元素,并返回这个最大元素 <br />4.public void insert(T t)：往队列中插入一个元素 <br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br />7.public int size():获取队列中元素的个数 <br />8.public boolean isEmpty():判断队列是否为空 |
| 成员变量 | 1.private T[] imtes : 用来存储元素的数组 <br />2.private int N：记录堆中元素的个数 |

#### 8.1.2 最大优先队列代码实现 

```java
public class MaxPriorityQueue<T extends Comparable<T>> {

    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MaxPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N = 0;
    }

    //获取队列中元素的个数
    public int size(){
        return this.N;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return this.N == 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j){
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax(){
        T max = items[1];
        exch(1, N);
        N --;
        sink(1);

        return max;
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){

        while (k > 1){
            if(less(k, k/2)){
                break;
            }else{
                exch(k, k/2);
            }

            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置
        while (2*k <= N){
            //获取当前结点的子结点中的较大结点
            int max;
            // 有右节点
            if(2*k+1 <= N){
                if(less(2*k, 2*k+1)){
                    max = 2*k+1;
                }else{
                    max = 2*k;
                }
            }else{
                max = 2*k;
            }

            if(!less(k, max)){
                break;
            }

            exch(k, max);
            k = max;
        }
    }

    public static void main(String[] args) {
        //创建优先队列
        MaxPriorityQueue<String> queue = new MaxPriorityQueue<>(10);
        //往队列中存储元素
        queue.insert("A");
        queue.insert("B");
        queue.insert("C");
        queue.insert("D");
        queue.insert("E");
        queue.insert("F");
        queue.insert("G");

        while (!queue.isEmpty()){
            String max = queue.delMax();
            System.out.print(max + " ");
        }
    }
}
```

### 8.2 最小优先队列 

最小优先队列实现起来也比较简单，我们同样也可以基于堆来完成最小优先队列。

我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性：

1. **最大的元素放在数组的索引1处；**
2. **每个结点的数据总是大于等于它的两个子结点的数据。**

![数组实现二叉树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112560.PNG)

其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足如下特性： 

1. **最小的元素放在数组的索引1处；** 

2. **每个结点的数据总是小于等于它的两个子结点的数据。** 

![最小堆](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112653.PNG)

这样我们就能快速的访问到堆中最小的数据。

#### 8.2.1 最小优先队列API设计 

| 类名     | `MinPriorityQueue<T extends Comparable<T>>`                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br />3.public T delMin():删除队列中最小的元素,并返回这个最小元素 <br />4.public void insert(T t)：往队列中插入一个元素 <br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 <br />7.public int size():获取队列中元素的个数 <br />8.public boolean isEmpty():判断队列是否为空 |
| 成员变量 | 1.private T[] imtes : 用来存储元素的数组 <br />2.private int N：记录堆中元素的个数 |

#### 8.2.2 最小优先队列代码实现 

```java
public class MinPriorityQueue<T extends Comparable<T>> {

    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MinPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N = 0;
    }

    //获取队列中元素的个数
    public int size(){
        return this.N;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return this.N == 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j){
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最小的元素,并返回这个最小元素
    public T delMin(){
        T min = items[1];
        exch(1, N);
        N--;
        sink(1);

        return min;
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){

        while (k > 1){
            if(less(k/2, k)){
                break;
            }else{
                exch(k/2, k);
            }
            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较小值的元素大小，如果当前结点大，则需要交换位置
        while (2*k <= N){
            //获取当前结点的子结点中的较大结点
            int min;
            // 有右节点
            if(2*k+1 <= N){
                if(less(2*k, 2*k+1)){
                    min = 2*k;
                }else{
                    min = 2*k+1;
                }
            }else{
                min = 2*k;
            }

            if(less(k, min)){
                break;
            }

            exch(k, min);
            k = min;
        }
    }

    public static void main(String[] args) {
        //创建优先队列
        MinPriorityQueue<String> queue = new MinPriorityQueue<>(10);
        //往队列中存数据
        queue.insert("G");
        queue.insert("F");
        queue.insert("E");
        queue.insert("D");
        queue.insert("C");
        queue.insert("B");
        queue.insert("A");

        while (!queue.isEmpty()){
            String max = queue.delMin();
            System.out.print(max + " ");
        }
    }
}
```

### 8.3 索引优先队列 

​	在之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。 

#### 8.3.1 索引优先队列实现思路 

**步骤一：**

存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时k这个值需要具有唯一性。

最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。 

![索引优先队列1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112187.PNG)

**步骤二：**

步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是，items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[] pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。 

![索引优先队列2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112889.PNG)

**步骤三：** 

​	通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pq[9]中元素的位置呢？ 

​	最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可，但是效率很低。 

​	我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如： 

​	在pq数组中：pq[1]=6;

​	那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1; 

![索引优先队列3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112548.PNG)

​	当有了pq数组后，如果我们修改items[0]="H"，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]=9,那么直接调整pq[9]即可。 

#### 8.3.2 索引优先队列API设计 

| 类名     | `IndexMinPriorityQueue<T extends Comparable<T>>`             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br />3.public int delMin():删除队列中最小的元素,并返回该元素关联的索引 <br />4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i <br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 <br />7.public int size():获取队列中元素的个数 <br />8.public boolean isEmpty():判断队列是否为空 <br />9.public boolean contains(int k):判断k对应的元素是否存在 <br />10.public void changeItem(int i, T t):把与索引i关联的元素修改为为t <br />11.public int minIndex():最小元素关联的索引 <br />12.public void delete(int i):删除索引i关联的元素 |
| 成员变量 | 1.private T[] imtes : 用来存储元素的数组 <br />2.private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序 <br />3.private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值 <br />4.private int N：记录堆中元素的个数 |

#### 8.3.3 索引优先队列代码实现 

```java
public class IndexMinPriorityQueue<T extends Comparable<T>> {

    //存储堆中的元素
    private T[] items;
    //保存每个元素在items数组中的索引，pq数组需要堆有序
    private int[] pq;
    //保存qp的逆序，pq的值作为索引，pq的索引作为值
    private int[] qp;
    //记录堆中元素的个数
    private int N;

    public IndexMinPriorityQueue(int capacity) {

        this.items = (T[]) new Comparable[capacity+1];
        this.pq = new int[capacity+1];
        this.qp = new int[capacity+1];
        this.N = 0;

        //默认情况下，队列中没有存储任何数据，让qp中的元素都为-1；
        for (int i = 0; i < qp.length; i++) {
            qp[i] = -1;
        }
    }

    //获取队列中元素的个数
    public int size(){
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j){
        return items[pq[i]].compareTo(items[pq[j]])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j){
        //交换pq中的数据
        int tmp = pq[i];
        pq[i] = pq[j];
        pq[j] = tmp;

        //更新qp中的数据
        qp[pq[i]]=i;
        qp[pq[j]]=j;
    }

    //判断k对应的元素是否存在
    public boolean contains(int k){
        return qp[k] != -1;
    }

    //最小元素关联的索引
    public int minIndex(){
        return pq[1];
    }

    //往队列中插入一个元素,并关联索引i
    public void insert(int i, T t){
        //判断i是否已经被关联，如果已经被关联，则不让插入
        if(contains(i)){
            return;
        }
        //元素个数+1
        N++;
        //把数据存储到items对应的i位置处
        items[i] = t;
        //把i存储到pq中
        pq[N] = i;
        //通过qp来记录pq中的i
        qp[i] = N;

        //通过堆上浮完成堆的调整
        swim(N);
    }

    //删除队列中最小的元素,并返回该元素关联的索引
    public int delMin(){
        //获取最小元素关联的索引
        int minIndex = pq[1];
        //交换pq中索引1处和最大索引处的元素
        exch(1, N);
        //删除qp中对应的内容
        qp[pq[N]] = -1;
        //删除pq最大索引处的内容
        pq[N] = -1;
        //删除items中对应的内容
        items[minIndex] = null;
        //元素个数-1
        N--;
        sink(1);

        return minIndex;
    }

    //删除索引i关联的元素
    public void delete(int i){
        //找到i在pq中的索引
        int k = qp[i];
        //交换pq中索引k处的值和索引N处的值
        exch(k, N);
        //删除qp中的内容
        qp[i] = -1;
        //删除pq中的内容
        pq[N] = -1;
        //删除items中的内容
        items[i] = null;
        //元素的数量-1
        N--;

        //堆的调整
        swim(k);
        sink(k);
    }

    //把与索引i关联的元素修改为为t
    public void changeItem(int i, T t){
        //修改items数组中i位置的元素为t
        items[i] = t;
        //找到i在pq中出现的位置
        int k = qp[i];
        //堆的调整
        swim(k);
        sink(k);
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        while (k>1){
            if(less(k, k/2)){
                exch(k, k/2);
            }else {
                break;
            }
            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k <= N){
            //找到子结点中的较小值
            int min;
            if(2*k+1 <= N){
                if(less(2*k, 2*k+1)){
                    min = 2*k;
                }else{
                    min = 2*k+1;
                }
            }else{
                min = 2*k;
            }

            //比较当前结点和较小值
            if(less(k, min)){
                break;
            }
            exch(k, min);
            k = min;
        }
    }

    public static void main(String[] args) {
        //创建索引最小优先队列对象
        IndexMinPriorityQueue<String> queue = new IndexMinPriorityQueue<>(10);

        //往队列中添加元素
        queue.insert(0,"A");
        queue.insert(1,"C");
        queue.insert(2,"F");

        //测试修改
        queue.changeItem(2,"B");
        //测试单个删除
        queue.delete(0);
        queue.insert(0, "P");
        //测试删除
        while(!queue.isEmpty()){
            int index = queue.delMin();
            System.out.print(index+" ");
        }

    }
}
```

## 9. 树的进阶

### 9.1平衡树

​	之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，大部分情况下，确实是这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。 

![极端不平衡树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112486.PNG)

​	我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向左边分支，如果我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情况下，查找的效率依旧会很好。 

#### 9.1.1 2-3查找树 

​	为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我们将一棵标准的二叉查找树中的结点称为**2-结点(含有一个键和两条链)**，而现在我们引入**3-结点，它含有两个键和三条链**。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。 

##### 9.1.1.1 2-3查找树的定义 

一棵2-3查找树要么为空，要么满足满足下面两个要求： 

* 2-结点： 

  含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 

* 3-结点：

  含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 

![2-3树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112683.PNG)

##### 9.1.1.2 查找 

​	将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。 

![2-3树查找](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112794.PNG)

##### 9.1.1.3 插入

###### 9.1.1.3.1 向2-结点中插入新键 

​	往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点麻烦。 

![2-3树插入](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112077.PNG)

###### 9.1.1.3.2 向一棵只含有一个3-结点的树中插入新键 

​	假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。 

![2-3树插入2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112080.PNG)

###### 9.1.1.3.3 向一个父结点为2-结点的3-结点中插入新键 

​	和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。 

![2-3树插入3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112499.PNG)

###### 9.1.3.1.4 向一个父结点为3-结点的3-结点中插入新键 

​	当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点，插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其变为3-结点，不需要继续进行拆分。 

![2-3树插入4](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112371.PNG)

###### 9.1.3.1.5 分解根结点 

​	当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。 

![分解根节点](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112463.PNG)

##### 9.1.1.4 2-3树的性质

​	通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。

一棵完全平衡的2-3树具有以下性质：

1. 任意空链接到根结点的路径长度都是相等的。

2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。 

##### 9.1.1.5 2-3树的实现 

直接实现2-3树比较复杂，因为： 

* 需要处理不同的结点类型，非常繁琐； 
* 需要多次比较操作来将结点下移； 
* 需要上移来拆分4-结点； 
* 拆分4-结点的情况有很多种； 

2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。

#### 9.1.2 红黑树 

​	我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为logN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。 

​	红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型： 

**红链接：将两个2-结点连接起来构成一个3-结点；** 

**黑链接：则是2-3树中的普通链接。** 

确切的说，我们将3-结点表示为由一条**左斜**的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。 

![红黑树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112923.PNG)

##### 9.1.2.1 红黑树的定义 

红黑树是含有红黑链接并满足下列条件的二叉查找树： 

1. 红链接均为左链接；
2. 没有任何一个结点同时和两条红链接相连；
3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同； 

下面是红黑树与2-3树的对应关系： 

![红黑树与2-3关系](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112878.PNG)

##### 9.1.2.2 红黑树结点API 

​	因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的Node结点中添加一个布尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为false。 

![红黑树2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252112924.PNG)

**API设计：** 

| 类名     | Node<Key, Value>                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right，boolean color)：创建Node对象 |
| 成员变量 | 1.public Node left:记录左子结点 <br />2.public Node right:记录右子结点 <br />3.public Key key:存储键 <br />4.public Value value:存储值 <br />5.public boolean color:由其父结点指向它的链接的颜色 |

**代码：** 

```java
private class Node{
    //存储键
    public Key key;
    //存储值
    public Value value;
    //记录左子结点
    public Node left;
    //记录右子结点
    public Node right;
    //由其父结点指向它的链接的颜色
    public boolean color;

    public Node(Key key, Value value, Node left, Node right, boolean color) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        this.color = color;
    }
}
```

##### 9.1.2.3 平衡化 

在对红黑树进行一些增删改查的操作后，很有可能会出现：

1. 红色的右链接；
2. 两条连续红色的链接；

而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。
###### 9.1.2.3.1 左旋 

当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。 

**前提：**当前结点为h，它的右子结点为x；

**左旋过程：** 

1. 让x的左子结点变为h的右子结点：h.right=x.left;
2. 让h成为x的左子结点：x.left=h;
3. 让h的color属性变为x的color属性值：x.color=h.color;
4. 让h的color属性变为RED：h.color=true; 

![左旋](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113695.PNG)

###### 9.1.2.3.2 右旋 

当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋 

**前提：**当前结点为h，它的左子结点为x； 

**右旋过程：**

1. 让x的右子结点成为h的左子结点：h.left = x.right;
2. 让h成为x的右子结点：x.right=h;
3. 让x的color变为h的color属性值：x.color = h.color;
4. 让h的color为RED； 

![右旋](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113744.PNG)

##### 9.1.2.4 向单个2-结点中插入新键 

一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。

* 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。 

  ![红黑树插入1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113629.PNG)

* 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红色链接。 

  ![红黑树插入2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113160.PNG)

##### 9.1.2.5 向底部的2-结点插入新键 

​	用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。 

![红黑树插入3](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113755.PNG)

##### 9.1.2.6 颜色反转 

​	当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 

![红黑树插入4](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113802.PNG)

##### 9.1.2.7 向一棵双键树(即一个3-结点)中插入新键 

这种情况有可以分为三种子情况： 

1. 新键大于原树中的两个键 

   ![红黑树插入5](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113372.PNG)

2. 新键小于原树中的两个键 

   ![红黑树插入6](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113068.PNG)

3. 新键介于原数中两个键之间 

   ![红黑树插入7](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113972.PNG)

##### 9.1.2.8 根结点的颜色总是黑色 

​	之前我们介绍结点API的时候，在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。 

##### 9.1.2.9 向树底部的3-结点插入新键 

​	假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点为止。 

![红黑树插入8](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113523.PNG)

##### 9.1.2.10 红黑树的API设计 

| 类名      | `RedBlackTree<Key extends Comparable<Key>, Value>`           |
| --------- | ------------------------------------------------------------ |
| 构造方 法 | RedBlackTree()：创建RedBlackTree对象                         |
| 成员方 法 | 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色 <br />2.private Node rotateLeft(Node h):左旋调整 <br />3.private Node rotateRight(Node h):右旋调整 <br />4.private void flipColors(Node h)：颜色反转,相当于完成拆分4-结点 <br />5.public void put(Key key, Value val):在整个树上完成插入操作 <br />6.private Node put(Node h, Key key, Value val):在指定树中，完成插入操作,并返回添加元素后 新的树 <br />7.public Value get(Key key):根据key，从树中找出对应的值 <br />8.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 <br />9.public int size():获取树中元素的个数 |
| 成员变 量 | 1.private Node root : 记录根结点 <br />2.private int N:记录树中元素的个数 <br />3.private static final boolean RED：红色链接标识 <br />4.private static final boolean BLACK:黑色链接标识 |

##### 9.1.2.11 红黑树的实现 

```java
public class RedBlackTree <Key extends Comparable<Key>, Value> {

    //根节点
    private Node root;
    //记录树中元素的个数
    private int N;
    //红色链接
    private static final boolean RED=true;
    //黑色链接
    private static final boolean BLACK=false;


    //结点类
    private class Node{
        //存储键
        public Key key;
        //存储值
        public Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;
        //由其父结点指向它的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

    //获取树中元素的个数
    public int size(){
        return this.N;
    }

    /**
     * 判断当前节点的父指向链接是否为红色
     *
     * @param x
     * @return
     */
    private boolean isRed(Node x){
        if(x == null){
            return false;
        }
        return x.color==RED;
    }

    /**
     * 左旋转
     *
     * @param h
     * @return
     */
    private Node rotateLeft(Node h){
        //找到h结点的右子结点x
        Node x = h.right;
        //找到x结点的左子结点，让x结点的左子结点成为h结点的右子结点
        h.right = x.left;
        //让h结点称为x结点的左子结点
        x.left = h;
        //让x结点的color属性变为h结点的color属性
        x.color = h.color;
        //让h结点的color属性变为RED
        h.color = RED;

        return x;
    }

    /**
     * 右旋
     *
     * @param h
     * @return
     */
    private Node rotateRight(Node h){
        //找到h结点的左子结点 x
        Node x = h.left;
        //让x结点的右子结点成为h结点的左子结点
        h.left = x.right;
        //让h结点成为x结点的右子结点
        x.right = h;
        //让x结点的color属性变为h结点的color属性
        x.color = h.color;
        //让h结点的color属性为RED
        h.color = RED;

        return x;
    }

    /**
     * 颜色反转,相当于完成拆分4-节点
     *
     * @param h
     */
    private void flipColors(Node h){
        //当前结点变为红色
        h.color = RED;
        //左子结点和右子结点变为黑色
        h.left.color = BLACK;
        h.right.color = BLACK;
    }

    /**
     * 在整个树上完成插入操作
     *
     * @param key
     * @param val
     */
    public void put(Key key, Value val){
        root = put(root, key, val);
        //根结点的颜色总是黑色
        root.color = BLACK;
    }

    /**
     * 在指定树中，完成插入操作,并返回添加元素后新的树
     *
     * @param h
     * @param key
     * @param val
     */
    private Node put(Node h, Key key, Value val){
        //判断h是否为空，如果为空则直接返回一个红色的结点就可以了
        if(h == null){
            //数量+1
            N++;
            return new Node(key, val, null, null, RED);
        }

        //比较h结点的键和key的大小
        int cmp = key.compareTo(h.key);

        if (cmp < 0){
            //继续往左
            h.left = put(h.left, key, val);
        }else if(cmp > 0){
            //继续往右
            h.right = put(h.right, key, val);
        }else{
            //发生值的替换
            h.value = val;
        }

        //进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }
        //进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        //颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        return h;
    }

    //根据key，从树中找出对应的值
    public Value get(Key key){
        return get(root, key).value;
    }

    //从指定的树x中，查找key对应的值
    private Node get(Node n, Key key){
        if (n==null){
            return null;
        }

        //比较x结点的键和key的大小
        int cmp = key.compareTo(n.key);
        if(cmp > 0){
            return get(n.right, key);
        }else if(cmp < 0){
            return get(n.left, key);
        }else {
            return n;
        }
    }

    public static void main(String[] args) {

        RedBlackTree<String, String> tree = new RedBlackTree<>();

        //往树中插入元素
        tree.put("1","张三");
        tree.put("2","李四");
        tree.put("3","王五");

        //从树中获取元素
        String r1 = tree.get("1");
        System.out.println(r1);


        String r2 = tree.get("2");
        System.out.println(r2);

        String r3 = tree.get("3");
        System.out.println(r3);
    }

}
```

### 9.2 B树

​	前面我们已经学习了二叉查找树、2-3树以及它的实现红黑树。2-3树中，一个结点最多能有两个key，它的实现红黑树中使用对链接染色的方式去表达这两个key。接下来我们学习另外一种树型结构B树，这种数据结构中，一个结点允许多于两个key的存在。 

​	B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插入和删除等操作。 

#### 9.1.1 B树的特性 

​	B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点： 

* 每个结点最多有M-1个key，并且以升序排列；
* 每个结点最多能有M个子结点；
* 根结点至少有两个子结点； 

![B树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113815.PNG)

​	在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。

#### 9.2.2 B树存储数据 

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。 

![B树存储数据](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113243.PNG)

#### 9.2.3 B树在磁盘文件中的应用

在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。 

##### 9.2.3.1 磁盘 

​	磁盘能够保存大量的数据，从GB一直到TB级，但是他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。 

![磁盘](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113672.PNG)

​	磁盘由盘片构成，每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm，一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。 

##### 9.2.3.2 磁盘IO 

![磁盘IO](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113256.PNG)

​	磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为**寻道时间**，**旋转时间**，以及**传送时间**。 

​	由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I/O效率。 

​	页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 

​	文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I/O就可以完全载入。那么3层的B树可以容纳1024×1024×1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。 

### 9.3 B+树 

B+树是对B树的一种变形树，它与B树的差异在于：
1. 非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；
2. 树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。 

#### 9.3.1 B+树存储数据 

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。 

![B+树](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113203.PNG)

#### 9.3.2 B+树和B树的对比 

**B+ 树的优点在于：**

1. 由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此**在内存相同的情况下，能够存放更多的key**。 
2. B+树的叶子结点都是相连的，因此**对整棵树的遍历只需要一次线性遍历叶子结点即可**。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

**B树的优点在于：**

由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。 

#### 9.3.3 B+树在数据库中的应用 

在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，在很多数据库中，都是用到了B+树来提高查询的效率；

在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这个索引就是B+树这种数据结构实现的。 

##### 9.3.3.1 未建立主键索引查询 

![数据库B+树1](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113612.PNG)

​	执行`select * from user where id=18`,需要从第一条数据开始，一直查询到第6条，发现id=18，此时才能查询出目标结果，共需要比较6次； 

##### 9.3.3.2 建立主键索引查询 

![数据库B+树2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113173.PNG)

##### 9.3.3.3 区间查询 

执行`select * from user where id>=12 and id<=18`,如果有了索引，由于B+树的叶子结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。 

## 10. 并查集

并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作： 

* 查询元素p和元素q是否属于同一组
* 合并元素p和元素q所在的组 

![并查集](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113293.PNG)

### 10.1 并查集结构

并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：
1. 每个元素都唯一的对应一个结点；
2. 每一组数据中的多个元素都在同一颗树中；
3. 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；
4. 元素在树中并没有子父级关系的硬性要求； 

![并查集结构](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113854.PNG)

### 10.2 并查集API设计

| 类名     | UF                                                           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF(int N)：初始化并查集，以整数标识(0,N-1)个结点             |
| 成员方法 | 1.public int count()：获取当前并查集中的数据有多少个分组 <br />2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 <br />3.public int find(int p):元素p所在分组的标识符 <br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1.private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识 <br />2.private int count：记录并查集中数据的分组个数 |

### 10.3 并查集的实现

#### 10.3.1 UF(int N)构造方法实现 

1. 初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；
2. 初始化数组eleAndGroup；
3. 把eleAndGroup数组的**索引看做是每个结点存储的元素**，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i 

![UF构造方法实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113813.PNG)

#### 10.3.2 union(int p,int q)合并方法实现

1. 如果p和q已经在同一个分组中，则无需合并
2. 如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可
3. 分组数量-1 

![UNION合并方法实现](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113292.PNG)

#### 10.3.3 代码 

```java
public class UF {

    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGrop;
    //记录并查集中数据的分组个数
    private int count;

    //初始化并查集
    public UF(int N) {
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGrop = new int[N];
        //初始化eleAndGroup中的元素及其所在的组的标识符,
        // 让eleAndGroup数组的索引作为并查集的每个结点的元素，
        // 并且让每个索引处的值(该元素所在的组的标识符)就是该索引
        for (int i = 0; i < eleAndGrop.length; i++) {
            eleAndGrop[i] = i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //元素p所在分组的标识符
    public int find(int p){
        return eleAndGrop[p];
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p, int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p, int q){
        //判断元素q和p是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了
        if(connected(p, q)){
            return;
        }

        //找到p所在分组的标识符
        int pGroup = find(p);
        //找到q所在分组的标识符
        int qGroup = find(q);

        //合并组：让p所在组的所有元素的组标识符变为q所在分组的标识符
        for (int i = 0; i < eleAndGrop.length; i++) {
            if(eleAndGrop[i]==pGroup){
                eleAndGrop[i] = qGroup;
            }
        }

        //分组个数-1
        this.count--;
    }

    public static void main(String[] args) {

        //创建并查集对象
        UF uf = new UF(5);
        System.out.println("默认情况下，并查集中有："+uf.count()+"个分组");

        //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少
        Scanner sc = new Scanner(System.in);

        while (true){
            System.out.println("请输入第一个要合并的元素：");
            int p = sc.nextInt();
            System.out.println("请输入第二个要合并的元素：");
            int q = sc.nextInt();

            //判断这两个元素是否已经在同一组了
            if(uf.connected(p, q)){
                System.out.println(p+"元素和"+q+"元素已经在同一个组中了");
                continue;
            }

            uf.union(p, q);
            System.out.println("当前并查集中还有："+uf.count()+"个分组");
        }
    }
}
```

#### 10.3.4 并查集应用举例

​	如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则我们就可以通过connected(intp,int q)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通信，此时我们又可以调用union(int p,int q)使得p和q之间连通，这样两台计算机之间就可以通信了。

​	一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。 

### 10.4 UF_Tree算法优化 

​	为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结构中的eleAndGourp数组的含义进行重新设定：

1. 我们仍然让eleAndGroup数组的索引作为某个结点的元素；
2. eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点； 

![UFTree算法优化](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113345.PNG)

#### 10.4.1 UF_Tree API设计 

| 类名     | UF_Tree                                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree(int N)：初始化并查集，以整数标识(0,N-1)个结点        |
| 成员方法 | 1.public int count()：获取当前并查集中的数据有多少个分组 <br />2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 <br />3.public int find(int p):元素p所在分组的标识符 <br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1.private int[] eleAndGroup: 记录结点元素和该元素的父结点 <br />2.private int count：记录并查集中数据的分组个数 |

#### 10.4.2 find(int p)查询方法实现 

1. 判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；
2. 如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止； 

![find方法查询](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113818.PNG)

#### 10.4.3 union(int p,int q)合并方法实现

1. 找到p元素所在树的根结点
2. 找到q元素所在树的根结点
3. 如果p和q已经在同一个树中，则无需合并；
4. 如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；
5. 分组数量-1 

![UNION合并方法实现2](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113528.PNG)

#### 10.4.4 代码

```java
public class UFTree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;

    //初始化并查集
    public UFTree(int N){
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];

        //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p,int q){
        return find(p) == find(q);
    }

    //元素p所在分组的标识符
    public int find(int p){
        while (true){
            if(p == eleAndGroup[p]){
                return p;
            }

            p = eleAndGroup[p];
        }
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p, int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //如果p和q已经在同一分组，则不需要合并了
        if(pRoot == qRoot){
            return;
        }

        //让p所在的树的根结点的父结点为q所在树的根结点即可
        eleAndGroup[pRoot] = qRoot;
        //组的数量-1
        count--;
    }

    public static void main(String[] args) {
        //创建并查集对象
        UFTree uf = new UFTree(5);
        System.out.println("默认情况下，并查集中有："+uf.count()+"个分组");

        //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少
        Scanner sc = new Scanner(System.in);

        while(true){
            System.out.println("请输入第一个要合并的元素：");
            int p = sc.nextInt();
            System.out.println("请输入第二个要合并的元素：");
            int q = sc.nextInt();

            //判断这两个元素是否已经在同一组了
            if (uf.connected(p,q)){
                System.out.println(p+"元素和"+q+"元素已经在同一个组中了");
                continue;
            }

            uf.union(p,q);
            System.out.println("当前并查集中还有："+uf.count()+"个分组");
        }
    }
}
```

#### 10.4.5 优化后的性能分析

​	我们优化后的算法union，如果要把并查集中所有的数据连通，仍然至少要调用N-1次union方法，但是，我们发现union方法中已经没有了for循环，所以union算法的时间复杂度由O(N^2)变为了O(N)。

但是这个算法仍然有问题，因为我们之前不仅修改了union算法，还修改了find算法。我们修改前的find算法的时间复杂度在任何情况下都为O(1)，但修改后的find算法在最坏情况下是O(N)： 

![优化后的性能分析](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113987.PNG)

在union方法中调用了find方法，所以在最坏情况下union算法的时间复杂度仍然为O(N^2)。 

### 10.5 路径压缩

​	UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。

之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。 

![压缩路径](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113352.PNG)

​	只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码调整数组中的值。 

#### 10.5.1 UF_Tree_Weighted API设计

| 类名     | UF_Tree_Weighted                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree_Weighted(int N)：初始化并查集，以整数标识(0,N-1)个结点 |
| 成员方法 | 1.public int count()：获取当前并查集中的数据有多少个分组 <br />2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 <br />3.public int find(int p):元素p所在分组的标识符 <br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1.private int[] eleAndGroup: 记录结点元素和该元素的父结点 <br />2.private int[] sz: 存储每个根结点对应的树中元素的个数 <br />3.private int count：记录并查集中数据的分组个数 |

#### 10.5.2 代码

```java
public class UFTreeWeight {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //用来存储每一个根结点对应的树中保存的结点的个数
    private int sz[];

    //初始化并查集
    public UFTreeWeight(int N){
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];

        //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
        }

        this.sz = new int[N];
        //默认情况下，sz中每个索引处的值都是1
        for (int i = 0; i < sz.length; i++) {
            sz[i] = 1;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p,int q){
        return find(p) == find(q);
    }

    //元素p所在分组的标识符
    public int find(int p){
        while (true){
            if(p == eleAndGroup[p]){
                return p;
            }

            p = eleAndGroup[p];
        }
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p, int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //如果p和q已经在同一分组，则不需要合并了
        if(pRoot == qRoot){
            return;
        }

        //判断proot对应的树大还是qroot对应的树大，最终需要把较小的树合并到较大的树中
        if(sz[pRoot]<sz[qRoot]){
            eleAndGroup[pRoot] = qRoot;
            sz[qRoot]+=sz[pRoot];
        }else{
            eleAndGroup[qRoot] = pRoot;
            sz[pRoot]+=sz[qRoot];
        }

        //组的数量-1
        count--;
    }

    public static void main(String[] args) {
        //创建并查集对象
        UFTreeWeight uf = new UFTreeWeight(5);
        System.out.println("默认情况下，并查集中有："+uf.count()+"个分组");

        //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少
        Scanner sc = new Scanner(System.in);

        while(true){
            System.out.println("请输入第一个要合并的元素：");
            int p = sc.nextInt();
            System.out.println("请输入第二个要合并的元素：");
            int q = sc.nextInt();

            //判断这两个元素是否已经在同一组了
            if (uf.connected(p,q)){
                System.out.println(p+"元素和"+q+"元素已经在同一个组中了");
                continue;
            }

            uf.union(p,q);
            System.out.println("当前并查集中还有："+uf.count()+"个分组");
        }
    }
}
```

### 10.6 案例-畅通工程

​	某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？

​	在我们的测试数据文件夹中有一个trffic_project.txt文件，它就是诚征道路统计表，下面是对数据的解释： 

![畅通工程](https://xycnotes.oss-cn-hangzhou.aliyuncs.com/img/202206252113109.PNG)

​	总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？ 

**解题思路：**

1. 创建一个并查集UF_Tree_Weighted(20);

2. 分别调用`union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)`，表示已经修建好的道路把对应的城市连接起来；

3. 如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前并查集中剩余的数目，减去1，就是还需要修建的道路数目；

**代码：**

```java
public class TrafficProjectTest {

    public static void main(String[] args) throws Exception {

        //构建一个缓冲读取流BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(TrafficProjectTest.class.getClassLoader().getResourceAsStream("traffic_project.txt")));

        //读取第一行数据20
        int totalNumber = Integer.parseInt(br.readLine());

        //构建一个并查集对象
        UFTreeWeight uf = new UFTreeWeight(totalNumber);

        //读取第二行数据7
        int roadNumber = Integer.parseInt(br.readLine());
        //循环读取7条道路
        for (int i = 0; i < roadNumber; i++) {
            String line = br.readLine();
            String[] strings = line.split(" ");
            int p = Integer.parseInt(strings[0]);
            int q = Integer.parseInt(strings[1]);

            //调用并查集对象的union方法让两个城市相通
            uf.union(p, q);
        }

        //获取当前并查集中分组的数量-1就可以得到还需要修建的道路的数目
        int roads = uf.count()-1;
        System.out.println("还需要修建"+roads+"条道路，才能实现畅通工程");
    }

}
```

